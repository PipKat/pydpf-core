"""Autogenerated DPF operator classes.

Created on 01/04/2021, 09:21:00
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class MeshProvider(dpf.Operator):
    """DPF "MeshProvider" Operator

    Read a mesh from result files and cure degenerated elements

    Available inputs:
     -   ``data_sources`` : DataSources

     -   ``streams_container`` : StreamsContainer, optional


    Available outputs:
     -   mesh


    Parameters
    ----------
    data_sources : DataSources


    streams_container : streams_container, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.MeshProvider(my_data_sources,
                                        my_streams_container)  # optional
    >>> my_mesh = op.mesh

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.MeshProvider()
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> my_mesh = op.outputs.mesh()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """"""
            return self._mesh


    def __init__(self, data_sources, streams_container=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "MeshProvider"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """"""
        return self.outputs._mesh



class FromScoping(dpf.Operator):
    """DPF "mesh::by_scoping" Operator

    Extracts a meshed region from an other meshed region base on a
    scoping

    Available inputs:
     -   ``mesh`` : MeshedRegion

     -   ``scoping`` : Scoping
         If nodal scoping, then the scoping is transposed respecting the
         inclusive pin

     -   ``inclusive`` : int, optional
         If inclusive == 1 then all the elements adjacent to the nodes ids in
         input are added, if inclusive == 0, only the elements which have all
         their nodes in the scoping are included


    Available outputs:
     -   mesh


    Parameters
    ----------
    scoping : Scoping
        If nodal scoping, then the scoping is transposed respecting
        the inclusive pin

    mesh : MeshedRegion


    inclusive : int, optional
        If inclusive == 1 then all the elements adjacent to the nodes
        ids in input are added, if inclusive == 0, only the elements
        which have all their nodes in the scoping are included

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.FromScoping(my_scoping,
                                       my_mesh,
                                       my_inclusive)  # optional
    >>> my_mesh = op.mesh

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.FromScoping()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.scoping.connect(my_scoping)
    >>> op.inputs.inclusive.connect(my_inclusive)  # optional
    >>> my_mesh = op.outputs.mesh()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(1, InputSpec(document='if nodal scoping, then the scoping is transposed respecting the inclusive pin', ellipsis=False, name='scoping', optional=False, type_names=['scoping'])), (2, InputSpec(document='if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included', ellipsis=False, name='inclusive', optional=True, type_names=['int32'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._scoping = None
            self._inclusive = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def scoping(self):
            """if nodal scoping, then the scoping is transposed respecting the inclusive pin"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def inclusive(self):
            """if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included"""
            return self._inclusive

        @inclusive.setter
        def inclusive(self, inclusive):
            self._inclusive.connect(inclusive)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """"""
            return self._mesh


    def __init__(self, scoping, mesh, inclusive=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mesh::by_scoping"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """"""
        return self.outputs._mesh



class SplitMesh(dpf.Operator):
    """DPF "split_mesh" Operator

    Split the input mesh into several meshes based on a given property
    (material property be default)

    Available inputs:
     -   ``mesh_scoping`` : Scoping, optional
         Scoping

     -   ``property`` : str

     -   ``mesh`` : MeshedRegion


    Available outputs:
     -   mesh_controller


    Parameters
    ----------
    mesh : MeshedRegion


    property : str


    mesh_scoping : Scoping, optional
        Scoping

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.SplitMesh(my_mesh,
                                     my_property,
                                     my_mesh_scoping)  # optional
    >>> my_mesh_controller = op.mesh_controller

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.SplitMesh()
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.property.connect(my_property)
    >>> op.inputs.mesh.connect(my_mesh)
    >>> my_mesh_controller = op.outputs.mesh_controller()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(1, InputSpec(document='Scoping', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (13, InputSpec(document='', ellipsis=False, name='property', optional=False, type_names=['string']))])
        def __init__(self, oper):
            self._mesh_scoping = None
            self._mesh = None
            self._property = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """Scoping"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def property(self):
            return self._property

        @property.setter
        def property(self, property):
            self._property.connect(property)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_controller', type_names=['N14dataProcessing15CMeshControllerE'], document=''))])
        def __init__(self, oper):
            self._mesh_controller = None
            super().__init__(self._spec, oper)

        @property
        def mesh_controller(self):
            """"""
            return self._mesh_controller


    def __init__(self, mesh, property, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "split_mesh"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_controller(self):
        """"""
        return self.outputs._mesh_controller



class Skin(dpf.Operator):
    """DPF "meshed_skin_sector" Operator

    Extracts a skin of the mesh (2D elements) in a new meshed region

    Available inputs:
     -   ``mesh`` : MeshedRegion

     -   ``mesh_scoping`` : Scoping, optional


    Available outputs:
     -   property_field_new_elements_to_old
     -   mesh
     -   nodes_mesh_scoping
     -   map_new_elements_to_old


    Parameters
    ----------
    mesh : MeshedRegion


    mesh_scoping : Scoping, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Skin(my_mesh,
                                my_mesh_scoping)  # optional
    >>> my_property_field_new_elements_to_old = op.property_field_new_elements_to_old
    >>> my_mesh = op.mesh
    >>> my_nodes_mesh_scoping = op.nodes_mesh_scoping
    >>> my_map_new_elements_to_old = op.map_new_elements_to_old

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Skin()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_property_field_new_elements_to_old = op.outputs.property_field_new_elements_to_old()
    >>> my_mesh = op.outputs.mesh()
    >>> my_nodes_mesh_scoping = op.outputs.nodes_mesh_scoping()
    >>> my_map_new_elements_to_old = op.outputs.map_new_elements_to_old()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._mesh = None
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document='skin meshed region with facets and facets_to_ele property fields')), (1, OutputSpec(name='nodes_mesh_scoping', type_names=['scoping'], document='')), (2, OutputSpec(name='map_new_elements_to_old', type_names=['umap<int32,int32>'], document='')), (3, OutputSpec(name='property_field_new_elements_to_old', type_names=['property_field'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            self._nodes_mesh_scoping = None
            self._map_new_elements_to_old = None
            self._property_field_new_elements_to_old = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """skin meshed region with facets and facets_to_ele property fields"""
            return self._mesh

        @property
        def nodes_mesh_scoping(self):
            """"""
            return self._nodes_mesh_scoping

        @property
        def map_new_elements_to_old(self):
            """"""
            return self._map_new_elements_to_old

        @property
        def property_field_new_elements_to_old(self):
            """"""
            return self._property_field_new_elements_to_old


    def __init__(self, mesh, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "meshed_skin_sector"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """skin meshed region with facets and facets_to_ele property fields"""
        return self.outputs._mesh

    @property
    def nodes_mesh_scoping(self):
        """"""
        return self.outputs._nodes_mesh_scoping

    @property
    def map_new_elements_to_old(self):
        """"""
        return self.outputs._map_new_elements_to_old

    @property
    def property_field_new_elements_to_old(self):
        """"""
        return self.outputs._property_field_new_elements_to_old



