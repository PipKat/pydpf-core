"""Autogenerated DPF operator classes.

Created on 01/15/2021, 00:24:02
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class StlExport(dpf.Operator):
    """DPF "stl_export" Operator

    export a mesh into a stl file.

    Available inputs:
     -   ``mesh`` : MeshedRegion

     -   ``file_path`` : str


    Available outputs:
     -   data_sources


    Parameters
    ----------
    mesh : MeshedRegion


    file_path : str




    Examples
    --------
    >>> op = dpf.operators.StlExport()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.file_path.connect(my_file_path)
    >>> my_data_sources = op.outputs.data_sources()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (1, InputSpec(document='', ellipsis=False, name='file_path', optional=False, type_names=['string']))])
        def __init__(self, oper):
            self._mesh = None
            self._file_path = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def file_path(self):
            return self._file_path

        @file_path.setter
        def file_path(self, file_path):
            self._file_path.connect(file_path)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='data_sources', type_names=['data_sources'], document=''))])
        def __init__(self, oper):
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def data_sources(self):
            """"""
            return self._data_sources


    def __init__(self, mesh, file_path):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "stl_export"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def data_sources(self):
        """"""
        return self.outputs._data_sources



class FromField(dpf.Operator):
    """DPF "GetSupportFromField" Operator

    Returns the meshed region contained in the support of the mesh.

    Available inputs:
     -   ``field`` : Field


    Available outputs:
     -   mesh


    Parameters
    ----------
    field : Field




    Examples
    --------
    >>> op = dpf.operators.FromField()
    >>> op.inputs.field.connect(my_field)
    >>> my_mesh = op.outputs.mesh()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """"""
            return self._mesh


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "GetSupportFromField"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """"""
        return self.outputs._mesh



class TriMeshSkin(dpf.Operator):
    """DPF "meshed_skin_sector_triangle" Operator

    Extracts a skin of the mesh in triangles (2D elements) in a new
    meshed region

    Available inputs:
     -   ``mesh`` : MeshedRegion


    Available outputs:
     -   mesh
     -   nodes_mesh_scoping


    Parameters
    ----------
    mesh : MeshedRegion




    Examples
    --------
    >>> op = dpf.operators.TriMeshSkin()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> my_mesh = op.outputs.mesh()
    >>> my_nodes_mesh_scoping = op.outputs.nodes_mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document='')), (1, OutputSpec(name='nodes_mesh_scoping', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            self._nodes_mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """"""
            return self._mesh

        @property
        def nodes_mesh_scoping(self):
            """"""
            return self._nodes_mesh_scoping


    def __init__(self, mesh):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "meshed_skin_sector_triangle"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """"""
        return self.outputs._mesh

    @property
    def nodes_mesh_scoping(self):
        """"""
        return self.outputs._nodes_mesh_scoping



class MeshProvider(dpf.Operator):
    """DPF "MeshProvider" Operator

    Read a mesh from result files and cure degenerated elements

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional

     -   ``data_sources`` : DataSources


    Available outputs:
     -   mesh


    Parameters
    ----------
    data_sources : DataSources


    streams_container : streams_container, optional


    Examples
    --------
    >>> op = dpf.operators.MeshProvider()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_mesh = op.outputs.mesh()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """"""
            return self._mesh


    def __init__(self, data_sources, streams_container=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "MeshProvider"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """"""
        return self.outputs._mesh



class FromScoping(dpf.Operator):
    """DPF "mesh::by_scoping" Operator

    Extracts a meshed region from an other meshed region base on a
    scoping

    Available inputs:
     -   ``inclusive`` : int, optional
         If inclusive == 1 then all the elements adjacent to the nodes ids in
         input are added, if inclusive == 0, only the elements which have all
         their nodes in the scoping are included

     -   ``mesh`` : MeshedRegion

     -   ``scoping`` : Scoping
         If nodal scoping, then the scoping is transposed respecting the
         inclusive pin


    Available outputs:
     -   mesh


    Parameters
    ----------
    scoping : Scoping
        If nodal scoping, then the scoping is transposed respecting
        the inclusive pin

    mesh : MeshedRegion


    inclusive : int, optional
        If inclusive == 1 then all the elements adjacent to the nodes
        ids in input are added, if inclusive == 0, only the elements
        which have all their nodes in the scoping are included

    Examples
    --------
    >>> op = dpf.operators.FromScoping()
    >>> op.inputs.inclusive.connect(my_inclusive)  # optional
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.scoping.connect(my_scoping)
    >>> my_mesh = op.outputs.mesh()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(1, InputSpec(document='if nodal scoping, then the scoping is transposed respecting the inclusive pin', ellipsis=False, name='scoping', optional=False, type_names=['scoping'])), (2, InputSpec(document='if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included', ellipsis=False, name='inclusive', optional=True, type_names=['int32'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._scoping = None
            self._inclusive = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def scoping(self):
            """if nodal scoping, then the scoping is transposed respecting the inclusive pin"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def inclusive(self):
            """if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included"""
            return self._inclusive

        @inclusive.setter
        def inclusive(self, inclusive):
            self._inclusive.connect(inclusive)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """"""
            return self._mesh


    def __init__(self, scoping, mesh, inclusive=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mesh::by_scoping"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """"""
        return self.outputs._mesh



class SplitFields(dpf.Operator):
    """DPF "split_fields" Operator

    Split the input field or fields container based on the input mesh
    regions

    Available inputs:
     -   ``field_or_fields_container`` : Field, FieldsContainer

     -   ``mesh_controller`` : N14Dataprocessing15Cmeshcontrollere
         Body meshes in the mesh controller cannot be mixed shell/solid


    Available outputs:
     -   fields_container


    Parameters
    ----------
    field_or_fields_container : Field or FieldsContainer


    mesh_controller : N14dataProcessing15CMeshControllerE
        Body meshes in the mesh controller cannot be mixed shell/solid



    Examples
    --------
    >>> op = dpf.operators.SplitFields()
    >>> op.inputs.field_or_fields_container.connect(my_field_or_fields_container)
    >>> op.inputs.mesh_controller.connect(my_mesh_controller)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field_or_fields_container', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='body meshes in the mesh controller cannot be mixed shell/solid', ellipsis=False, name='mesh_controller', optional=False, type_names=['N14dataProcessing15CMeshControllerE']))])
        def __init__(self, oper):
            self._field_or_fields_container = None
            self._mesh_controller = None
            super().__init__(self._spec, oper)

        @property
        def field_or_fields_container(self):
            return self._field_or_fields_container

        @field_or_fields_container.setter
        def field_or_fields_container(self, field_or_fields_container):
            self._field_or_fields_container.connect(field_or_fields_container)

        @property
        def mesh_controller(self):
            """body meshes in the mesh controller cannot be mixed shell/solid"""
            return self._mesh_controller

        @mesh_controller.setter
        def mesh_controller(self, mesh_controller):
            self._mesh_controller.connect(mesh_controller)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, field_or_fields_container, mesh_controller):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "split_fields"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class SplitMesh(dpf.Operator):
    """DPF "split_mesh" Operator

    Split the input mesh into several meshes based on a given property
    (material property be default)

    Available inputs:
     -   ``property`` : str

     -   ``mesh_scoping`` : Scoping, optional
         Scoping

     -   ``mesh`` : MeshedRegion


    Available outputs:
     -   mesh_controller


    Parameters
    ----------
    mesh : MeshedRegion


    property : str


    mesh_scoping : Scoping, optional
        Scoping

    Examples
    --------
    >>> op = dpf.operators.SplitMesh()
    >>> op.inputs.property.connect(my_property)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.mesh.connect(my_mesh)
    >>> my_mesh_controller = op.outputs.mesh_controller()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(1, InputSpec(document='Scoping', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (13, InputSpec(document='', ellipsis=False, name='property', optional=False, type_names=['string']))])
        def __init__(self, oper):
            self._mesh_scoping = None
            self._mesh = None
            self._property = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """Scoping"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def property(self):
            return self._property

        @property.setter
        def property(self, property):
            self._property.connect(property)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_controller', type_names=['N14dataProcessing15CMeshControllerE'], document=''))])
        def __init__(self, oper):
            self._mesh_controller = None
            super().__init__(self._spec, oper)

        @property
        def mesh_controller(self):
            """"""
            return self._mesh_controller


    def __init__(self, mesh, property, mesh_scoping=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "split_mesh"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_controller(self):
        """"""
        return self.outputs._mesh_controller



class Skin(dpf.Operator):
    """DPF "meshed_skin_sector" Operator

    Extracts a skin of the mesh (2D elements) in a new meshed region

    Available inputs:
     -   ``mesh`` : MeshedRegion

     -   ``mesh_scoping`` : Scoping, optional


    Available outputs:
     -   nodes_mesh_scoping
     -   mesh
     -   property_field_new_elements_to_old
     -   map_new_elements_to_old


    Parameters
    ----------
    mesh : MeshedRegion


    mesh_scoping : Scoping, optional


    Examples
    --------
    >>> op = dpf.operators.Skin()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_nodes_mesh_scoping = op.outputs.nodes_mesh_scoping()
    >>> my_mesh = op.outputs.mesh()
    >>> my_property_field_new_elements_to_old = op.outputs.property_field_new_elements_to_old()
    >>> my_map_new_elements_to_old = op.outputs.map_new_elements_to_old()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._mesh = None
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document='skin meshed region with facets and facets_to_ele property fields')), (1, OutputSpec(name='nodes_mesh_scoping', type_names=['scoping'], document='')), (2, OutputSpec(name='map_new_elements_to_old', type_names=['umap<int32,int32>'], document='')), (3, OutputSpec(name='property_field_new_elements_to_old', type_names=['property_field'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            self._nodes_mesh_scoping = None
            self._map_new_elements_to_old = None
            self._property_field_new_elements_to_old = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """skin meshed region with facets and facets_to_ele property fields"""
            return self._mesh

        @property
        def nodes_mesh_scoping(self):
            """"""
            return self._nodes_mesh_scoping

        @property
        def map_new_elements_to_old(self):
            """"""
            return self._map_new_elements_to_old

        @property
        def property_field_new_elements_to_old(self):
            """"""
            return self._property_field_new_elements_to_old


    def __init__(self, mesh, mesh_scoping=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "meshed_skin_sector"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """skin meshed region with facets and facets_to_ele property fields"""
        return self.outputs._mesh

    @property
    def nodes_mesh_scoping(self):
        """"""
        return self.outputs._nodes_mesh_scoping

    @property
    def map_new_elements_to_old(self):
        """"""
        return self.outputs._map_new_elements_to_old

    @property
    def property_field_new_elements_to_old(self):
        """"""
        return self.outputs._property_field_new_elements_to_old



class MeshCut(dpf.Operator):
    """DPF "mesh_cut" Operator

    Extracts a skin of the mesh in triangles (2D elements) in a new
    meshed region

    Available inputs:
     -   ``closed_surface`` : float
         1: closed surface, 0:iso surface

     -   ``iso_value`` : float
         Iso value

     -   ``field`` : Field


    Available outputs:
     -   mesh


    Parameters
    ----------
    field : Field


    iso_value : float
        Iso value

    closed_surface : float
        1: closed surface, 0:iso surface



    Examples
    --------
    >>> op = dpf.operators.MeshCut()
    >>> op.inputs.closed_surface.connect(my_closed_surface)
    >>> op.inputs.iso_value.connect(my_iso_value)
    >>> op.inputs.field.connect(my_field)
    >>> my_mesh = op.outputs.mesh()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field'])), (1, InputSpec(document='iso value', ellipsis=False, name='iso_value', optional=False, type_names=['double'])), (3, InputSpec(document='1: closed surface, 0:iso surface', ellipsis=False, name='closed_surface', optional=False, type_names=['double']))])
        def __init__(self, oper):
            self._field = None
            self._iso_value = None
            self._closed_surface = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def iso_value(self):
            """iso value"""
            return self._iso_value

        @iso_value.setter
        def iso_value(self, iso_value):
            self._iso_value.connect(iso_value)

        @property
        def closed_surface(self):
            """1: closed surface, 0:iso surface"""
            return self._closed_surface

        @closed_surface.setter
        def closed_surface(self, closed_surface):
            self._closed_surface.connect(closed_surface)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(2, OutputSpec(name='mesh', type_names=['meshed_region'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """"""
            return self._mesh


    def __init__(self, field, iso_value, closed_surface):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mesh_cut"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """"""
        return self.outputs._mesh



class ExternalLayer(dpf.Operator):
    """DPF "meshed_external_layer_sector" Operator

    Extracts the external layer (thick skin) of the mesh (3D elements)
    in a new meshed region

    Available inputs:
     -   ``mesh`` : MeshedRegion


    Available outputs:
     -   mesh
     -   nodes_mesh_scoping
     -   elements_mesh_scoping


    Parameters
    ----------
    mesh : MeshedRegion




    Examples
    --------
    >>> op = dpf.operators.ExternalLayer()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> my_mesh = op.outputs.mesh()
    >>> my_nodes_mesh_scoping = op.outputs.nodes_mesh_scoping()
    >>> my_elements_mesh_scoping = op.outputs.elements_mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document='')), (1, OutputSpec(name='nodes_mesh_scoping', type_names=['scoping'], document='')), (2, OutputSpec(name='elements_mesh_scoping', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._mesh = None
            self._nodes_mesh_scoping = None
            self._elements_mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            """"""
            return self._mesh

        @property
        def nodes_mesh_scoping(self):
            """"""
            return self._nodes_mesh_scoping

        @property
        def elements_mesh_scoping(self):
            """"""
            return self._elements_mesh_scoping


    def __init__(self, mesh):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "meshed_external_layer_sector"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh(self):
        """"""
        return self.outputs._mesh

    @property
    def nodes_mesh_scoping(self):
        """"""
        return self.outputs._nodes_mesh_scoping

    @property
    def elements_mesh_scoping(self):
        """"""
        return self.outputs._elements_mesh_scoping



