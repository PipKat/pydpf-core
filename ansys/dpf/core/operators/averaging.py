"""Autogenerated DPF operator classes.

Created on 01/04/2021, 09:21:00
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class ElementalFractionFc(dpf.Operator):
    """DPF "elemental_fraction_fc" Operator

    Transform ElementalNodal fields into Elemental fields. Each
    elemental value is the fraction between the elemental difference
    and the entity average. Result is computed on a given elements
    scoping.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``mesh`` : MeshedRegion, optional
         The mesh region in this pin is used to perform the averaging, if there
         is no field's support it is used

     -   ``collapse_shell_layers`` : B, optional
         The elemental difference and the entity average are taken through the
         different shell layers if true (default is false)

     -   ``scoping`` : Scoping, optional
         Average only on these elements, if it is scoping container, the label
         must correspond to the one of the fields container

     -   ``denominator`` : FieldsContainer, optional
         If a fields container is set in this pin, it is used as the
         denominator of the fraction instead of entity_average_fc


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    scoping : Scoping, optional
        Average only on these elements, if it is scoping container,
        the label must correspond to the one of the fields container

    denominator : FieldsContainer, optional
        If a fields container is set in this pin, it is used as the
        denominator of the fraction instead of entity_average_fc

    collapse_shell_layers : bool, optional
        The elemental difference and the entity average are taken
        through the different shell layers if true (default is false)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalFractionFc(my_fields_container,
                                               my_mesh, # optional
                                               my_scoping, # optional
                                               my_denominator, # optional
                                               my_collapse_shell_layers)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalFractionFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.collapse_shell_layers.connect(my_collapse_shell_layers)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> op.inputs.denominator.connect(my_denominator)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (3, InputSpec(document='average only on these elements, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (6, InputSpec(document='if a fields container is set in this pin, it is used as the denominator of the fraction instead of entity_average_fc', ellipsis=False, name='denominator', optional=True, type_names=['fields_container'])), (10, InputSpec(document='the elemental difference and the entity average are taken through the different shell layers if true (default is false)', ellipsis=False, name='collapse_shell_layers', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._scoping = None
            self._denominator = None
            self._collapse_shell_layers = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            """the mesh region in this pin is used to perform the averaging, if there is no field's support it is used"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def scoping(self):
            """average only on these elements, if it is scoping container, the label must correspond to the one of the fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def denominator(self):
            """if a fields container is set in this pin, it is used as the denominator of the fraction instead of entity_average_fc"""
            return self._denominator

        @denominator.setter
        def denominator(self, denominator):
            self._denominator.connect(denominator)

        @property
        def collapse_shell_layers(self):
            """the elemental difference and the entity average are taken through the different shell layers if true (default is false)"""
            return self._collapse_shell_layers

        @collapse_shell_layers.setter
        def collapse_shell_layers(self, collapse_shell_layers):
            self._collapse_shell_layers.connect(collapse_shell_layers)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, scoping=None, denominator=None, collapse_shell_layers=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "elemental_fraction_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ExtendToMidNodesFc(dpf.Operator):
    """DPF "extend_to_mid_nodes_fc" Operator

    Extends ElementalNodal fields defined on corner nodes to
    ElementalNodal fields defined also on the mid nodes.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional
         The mesh region in this pin is used to perform the averaging, if there
         is no field's support it is used

     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ExtendToMidNodesFc(my_fields_container,
                                              my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ExtendToMidNodesFc()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            """the mesh region in this pin is used to perform the averaging, if there is no field's support it is used"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "extend_to_mid_nodes_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalNodalToNodalElementalFc(dpf.Operator):
    """DPF "ElementalNodal_To_NodalElemental_fc" Operator

    Transform ElementalNodal fields to NodalElemental fields, compute
    result on a given node scoping.

    Available inputs:
     -   ``mesh_scoping`` : Scoping, optional

     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh_scoping : Scoping, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalNodalToNodalElementalFc(my_fields_container,
                                                            my_mesh_scoping)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalNodalToNodalElementalFc()
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ElementalNodal_To_NodalElemental_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ToElementalFc(dpf.Operator):
    """DPF "to_elemental_fc" Operator

    Transform input fields into Elemental fields using an averaging
    process, result is computed on a given elements scoping.

    Available inputs:
     -   ``mesh_scoping`` : Scoping, optional

     -   ``smoothen_values`` : B, optional
         If it is set to true, elemental nodal fields are first averaged on
         nodes and then averaged on elements (default is false)

     -   ``fields_container`` : FieldsContainer

     -   ``mesh`` : MeshedRegion, optional

     -   ``collapse_shell_layers`` : B, optional
         If true shell layers are averaged as well (default is false)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional


    mesh_scoping : Scoping, optional


    smoothen_values : bool, optional
        If it is set to true, elemental nodal fields are first
        averaged on nodes and then averaged on elements (default is
        false)

    collapse_shell_layers : bool, optional
        If true shell layers are averaged as well (default is false)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ToElementalFc(my_fields_container,
                                         my_mesh, # optional
                                         my_mesh_scoping, # optional
                                         my_smoothen_values, # optional
                                         my_collapse_shell_layers)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ToElementalFc()
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.smoothen_values.connect(my_smoothen_values)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.collapse_shell_layers.connect(my_collapse_shell_layers)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (3, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (7, InputSpec(document='if it is set to true, elemental nodal fields are first averaged on nodes and then averaged on elements (default is false)', ellipsis=False, name='smoothen_values', optional=True, type_names=['b'])), (10, InputSpec(document='if true shell layers are averaged as well (default is false)', ellipsis=False, name='collapse_shell_layers', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._mesh_scoping = None
            self._smoothen_values = None
            self._collapse_shell_layers = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def smoothen_values(self):
            """if it is set to true, elemental nodal fields are first averaged on nodes and then averaged on elements (default is false)"""
            return self._smoothen_values

        @smoothen_values.setter
        def smoothen_values(self, smoothen_values):
            self._smoothen_values.connect(smoothen_values)

        @property
        def collapse_shell_layers(self):
            """if true shell layers are averaged as well (default is false)"""
            return self._collapse_shell_layers

        @collapse_shell_layers.setter
        def collapse_shell_layers(self, collapse_shell_layers):
            self._collapse_shell_layers.connect(collapse_shell_layers)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, mesh_scoping=None, smoothen_values=None, collapse_shell_layers=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "to_elemental_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalNodalToNodalElemental(dpf.Operator):
    """DPF "ElementalNodal_To_NodalElemental" Operator

    Transform ElementalNodal field to NodalElemental, compute result
    on a given node scoping.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``mesh_scoping`` : Scoping, optional


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    mesh_scoping : Scoping, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalNodalToNodalElemental(my_field,
                                                          my_mesh_scoping)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalNodalToNodalElemental()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._field = None
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ElementalNodal_To_NodalElemental"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ElementalNodalToNodal(dpf.Operator):
    """DPF "elemental_nodal_To_nodal" Operator

    Transform ElementalNodal field into Nodal field using an averaging
    process, result is computed on a given node scoping.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``mesh`` : MeshedRegion

     -   ``should_average`` : B, optional
         Each nodal value is divided by the number of elements linked to this
         node (default is true for discrete quantities)

     -   ``through_layers`` : B, optional
         The max elemental difference is taken through the different shell
         layers if true (default is false)

     -   ``mesh_scoping`` : Scoping
         Average only on these entities


    Available outputs:
     -   fields_container


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    mesh : MeshedRegion


    mesh_scoping : Scoping
        Average only on these entities

    should_average : bool, optional
        Each nodal value is divided by the number of elements linked
        to this node (default is true for discrete quantities)

    through_layers : bool, optional
        The max elemental difference is taken through the different
        shell layers if true (default is false)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalNodalToNodal(my_field,
                                                 my_mesh,
                                                 my_mesh_scoping,
                                                 my_should_average, # optional
                                                 my_through_layers)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalNodalToNodal()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.should_average.connect(my_should_average)  # optional
    >>> op.inputs.through_layers.connect(my_through_layers)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (2, InputSpec(document='each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)', ellipsis=False, name='should_average', optional=True, type_names=['b'])), (3, InputSpec(document='average only on these entities', ellipsis=False, name='mesh_scoping', optional=False, type_names=['scoping'])), (10, InputSpec(document='the max elemental difference is taken through the different shell layers if true (default is false)', ellipsis=False, name='through_layers', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._field = None
            self._mesh = None
            self._should_average = None
            self._mesh_scoping = None
            self._through_layers = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def should_average(self):
            """each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)"""
            return self._should_average

        @should_average.setter
        def should_average(self, should_average):
            self._should_average.connect(should_average)

        @property
        def mesh_scoping(self):
            """average only on these entities"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def through_layers(self):
            """the max elemental difference is taken through the different shell layers if true (default is false)"""
            return self._through_layers

        @through_layers.setter
        def through_layers(self, through_layers):
            self._through_layers.connect(through_layers)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, field, mesh, mesh_scoping, should_average=None, through_layers=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "elemental_nodal_To_nodal"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalNodalToNodalFc(dpf.Operator):
    """DPF "elemental_nodal_To_nodal_fc" Operator

    Transform ElementalNodal fields into Nodal fields using an
    averaging process, result is computed on a given node scoping. If
    the input fields are mixed shell/solid, then the fields are
    splitted by element shape and the output fields container has
    elshape label.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``mesh`` : MeshedRegion, optional
         The mesh region in this pin is used to perform the averaging, if there
         is no field's support it is used

     -   ``should_average`` : B, optional
         Each nodal value is divided by the number of elements linked to this
         node (default is true for discrete quantities)

     -   ``scoping`` : Scoping, optional
         Average only on these nodes, if it is scoping container, the label
         must correspond to the one of the fields container


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    should_average : bool, optional
        Each nodal value is divided by the number of elements linked
        to this node (default is true for discrete quantities)

    scoping : Scoping, optional
        Average only on these nodes, if it is scoping container, the
        label must correspond to the one of the fields container

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalNodalToNodalFc(my_fields_container,
                                                   my_mesh, # optional
                                                   my_should_average, # optional
                                                   my_scoping)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalNodalToNodalFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.should_average.connect(my_should_average)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (2, InputSpec(document='each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)', ellipsis=False, name='should_average', optional=True, type_names=['b'])), (3, InputSpec(document='average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._should_average = None
            self._scoping = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            """the mesh region in this pin is used to perform the averaging, if there is no field's support it is used"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def should_average(self):
            """each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)"""
            return self._should_average

        @should_average.setter
        def should_average(self, should_average):
            self._should_average.connect(should_average)

        @property
        def scoping(self):
            """average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, should_average=None, scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "elemental_nodal_To_nodal_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalToNodal(dpf.Operator):
    """DPF "elemental_to_nodal" Operator

    Transform ElementalNodal field to Nodal field, compute result on a
    given node scoping.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``mesh_scoping`` : Scoping, optional

     -   ``force_averaging`` : int, optional
         Averaging on nodes is used if this pin is set to 1 (default is 1 for
         integrated results and 0 for dicrete ones)


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    mesh_scoping : Scoping, optional


    force_averaging : int, optional
        Averaging on nodes is used if this pin is set to 1 (default is
        1 for integrated results and 0 for dicrete ones)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalToNodal(my_field,
                                            my_mesh_scoping, # optional
                                            my_force_averaging)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalToNodal()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.force_averaging.connect(my_force_averaging)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document='averaging on nodes is used if this pin is set to 1 (default is 1 for integrated results and 0 for dicrete ones)', ellipsis=False, name='force_averaging', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._field = None
            self._mesh_scoping = None
            self._force_averaging = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def force_averaging(self):
            """averaging on nodes is used if this pin is set to 1 (default is 1 for integrated results and 0 for dicrete ones)"""
            return self._force_averaging

        @force_averaging.setter
        def force_averaging(self, force_averaging):
            self._force_averaging.connect(force_averaging)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, mesh_scoping=None, force_averaging=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "elemental_to_nodal"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ElementalToNodalFc(dpf.Operator):
    """DPF "elemental_to_nodal_fc" Operator

    Transform ElementalNodal fields to Nodal fields, compute result on
    a given node scoping.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``mesh_scoping`` : Scoping, optional

     -   ``force_averaging`` : int, optional
         Averaging on nodes is used if this pin is set to 1 (default is one for
         integrated results and 0 for dicrete ones)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh_scoping : Scoping, optional


    force_averaging : int, optional
        Averaging on nodes is used if this pin is set to 1 (default is
        one for integrated results and 0 for dicrete ones)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalToNodalFc(my_fields_container,
                                              my_mesh_scoping, # optional
                                              my_force_averaging)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalToNodalFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.force_averaging.connect(my_force_averaging)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document='averaging on nodes is used if this pin is set to 1 (default is one for integrated results and 0 for dicrete ones)', ellipsis=False, name='force_averaging', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh_scoping = None
            self._force_averaging = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def force_averaging(self):
            """averaging on nodes is used if this pin is set to 1 (default is one for integrated results and 0 for dicrete ones)"""
            return self._force_averaging

        @force_averaging.setter
        def force_averaging(self, force_averaging):
            self._force_averaging.connect(force_averaging)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh_scoping=None, force_averaging=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "elemental_to_nodal_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalDifference(dpf.Operator):
    """DPF "nodal_difference" Operator

    Transform ElementalNodal field into Nodal field. Each nodal value
    is the maximum difference between the unaveraged computed result
    for all elements that share this particular node. Result is
    computed on a given node scoping.

    Available inputs:
     -   ``should_average`` : B, optional
         Each nodal value is divided by the number of elements linked to this
         node (default is true for discrete quantities)

     -   ``through_layers`` : B, optional
         The max elemental difference is taken through the different shell
         layers if true (default is false)

     -   ``mesh_scoping`` : Scoping
         Average only on these entities

     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``mesh`` : MeshedRegion


    Available outputs:
     -   fields_container


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    mesh : MeshedRegion


    mesh_scoping : Scoping
        Average only on these entities

    should_average : bool, optional
        Each nodal value is divided by the number of elements linked
        to this node (default is true for discrete quantities)

    through_layers : bool, optional
        The max elemental difference is taken through the different
        shell layers if true (default is false)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalDifference(my_field,
                                           my_mesh,
                                           my_mesh_scoping,
                                           my_should_average, # optional
                                           my_through_layers)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalDifference()
    >>> op.inputs.should_average.connect(my_should_average)  # optional
    >>> op.inputs.through_layers.connect(my_through_layers)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.mesh.connect(my_mesh)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (2, InputSpec(document='each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)', ellipsis=False, name='should_average', optional=True, type_names=['b'])), (3, InputSpec(document='average only on these entities', ellipsis=False, name='mesh_scoping', optional=False, type_names=['scoping'])), (10, InputSpec(document='the max elemental difference is taken through the different shell layers if true (default is false)', ellipsis=False, name='through_layers', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._field = None
            self._mesh = None
            self._should_average = None
            self._mesh_scoping = None
            self._through_layers = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def should_average(self):
            """each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)"""
            return self._should_average

        @should_average.setter
        def should_average(self, should_average):
            self._should_average.connect(should_average)

        @property
        def mesh_scoping(self):
            """average only on these entities"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def through_layers(self):
            """the max elemental difference is taken through the different shell layers if true (default is false)"""
            return self._through_layers

        @through_layers.setter
        def through_layers(self, through_layers):
            self._through_layers.connect(through_layers)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, field, mesh, mesh_scoping, should_average=None, through_layers=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "nodal_difference"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalDifferenceFc(dpf.Operator):
    """DPF "nodal_difference_fc" Operator

    Transform ElementalNodal fields into Nodal fields. Each nodal
    value is the maximum difference between the unaveraged computed
    result for all elements that share this particular node. Result is
    computed on a given node scoping. If the input fields are mixed
    shell/solid, then the fields are splitted by element shape and the
    output fields container has elshape label.

    Available inputs:
     -   ``scoping`` : Scoping, optional
         Average only on these nodes, if it is scoping container, the label
         must correspond to the one of the fields container

     -   ``fields_container`` : FieldsContainer

     -   ``mesh`` : MeshedRegion, optional
         The mesh region in this pin is used to perform the averaging, if there
         is no field's support it is used


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    scoping : Scoping, optional
        Average only on these nodes, if it is scoping container, the
        label must correspond to the one of the fields container

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalDifferenceFc(my_fields_container,
                                             my_mesh, # optional
                                             my_scoping)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalDifferenceFc()
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (3, InputSpec(document='average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._scoping = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            """the mesh region in this pin is used to perform the averaging, if there is no field's support it is used"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def scoping(self):
            """average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "nodal_difference_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalDifference(dpf.Operator):
    """DPF "elemental_difference" Operator

    Transform ElementalNodal or Nodal field into Elemental field. Each
    elemental value is the maximum difference between the computed
    result for all nodes in this element. Result is computed on a
    given element scoping.

    Available inputs:
     -   ``mesh_scoping`` : Scoping
         Average only on these entities

     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``mesh`` : MeshedRegion

     -   ``should_average`` : B, optional
         Each nodal value is divided by the number of elements linked to this
         node (default is true for discrete quantities)

     -   ``through_layers`` : B, optional
         The max elemental difference is taken through the different shell
         layers if true (default is false)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    mesh : MeshedRegion


    mesh_scoping : Scoping
        Average only on these entities

    should_average : bool, optional
        Each nodal value is divided by the number of elements linked
        to this node (default is true for discrete quantities)

    through_layers : bool, optional
        The max elemental difference is taken through the different
        shell layers if true (default is false)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalDifference(my_field,
                                               my_mesh,
                                               my_mesh_scoping,
                                               my_should_average, # optional
                                               my_through_layers)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalDifference()
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.should_average.connect(my_should_average)  # optional
    >>> op.inputs.through_layers.connect(my_through_layers)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (2, InputSpec(document='each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)', ellipsis=False, name='should_average', optional=True, type_names=['b'])), (3, InputSpec(document='average only on these entities', ellipsis=False, name='mesh_scoping', optional=False, type_names=['scoping'])), (10, InputSpec(document='the max elemental difference is taken through the different shell layers if true (default is false)', ellipsis=False, name='through_layers', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._field = None
            self._mesh = None
            self._should_average = None
            self._mesh_scoping = None
            self._through_layers = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def should_average(self):
            """each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)"""
            return self._should_average

        @should_average.setter
        def should_average(self, should_average):
            self._should_average.connect(should_average)

        @property
        def mesh_scoping(self):
            """average only on these entities"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def through_layers(self):
            """the max elemental difference is taken through the different shell layers if true (default is false)"""
            return self._through_layers

        @through_layers.setter
        def through_layers(self, through_layers):
            self._through_layers.connect(through_layers)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, field, mesh, mesh_scoping, should_average=None, through_layers=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "elemental_difference"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalDifferenceFc(dpf.Operator):
    """DPF "elemental_difference_fc" Operator

    Transform ElementalNodal or Nodal field into Elemental field. Each
    elemental value is the maximum difference between the unaveraged
    or averaged (depending on the input fields) computed result for
    all nodes in this element. Result is computed on a given element
    scoping. If the input fields are mixed shell/solid and the shells
    layers are not asked to be collapsed, then the fields are splitted
    by element shape and the output fields container has elshape
    label.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``mesh`` : MeshedRegion, optional
         The mesh region in this pin is used to perform the averaging, if there
         is no field's support it is used

     -   ``collapse_shell_layers`` : B, optional
         The max elemental difference is taken through the different shell
         layers if true (default is false)

     -   ``scoping`` : Scoping, optional
         Average only on these elements, if it is scoping container, the label
         must correspond to the one of the fields container


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    scoping : Scoping, optional
        Average only on these elements, if it is scoping container,
        the label must correspond to the one of the fields container

    collapse_shell_layers : bool, optional
        The max elemental difference is taken through the different
        shell layers if true (default is false)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalDifferenceFc(my_fields_container,
                                                 my_mesh, # optional
                                                 my_scoping, # optional
                                                 my_collapse_shell_layers)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalDifferenceFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.collapse_shell_layers.connect(my_collapse_shell_layers)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (3, InputSpec(document='average only on these elements, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (10, InputSpec(document='the max elemental difference is taken through the different shell layers if true (default is false)', ellipsis=False, name='collapse_shell_layers', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._scoping = None
            self._collapse_shell_layers = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            """the mesh region in this pin is used to perform the averaging, if there is no field's support it is used"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def scoping(self):
            """average only on these elements, if it is scoping container, the label must correspond to the one of the fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def collapse_shell_layers(self):
            """the max elemental difference is taken through the different shell layers if true (default is false)"""
            return self._collapse_shell_layers

        @collapse_shell_layers.setter
        def collapse_shell_layers(self, collapse_shell_layers):
            self._collapse_shell_layers.connect(collapse_shell_layers)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, scoping=None, collapse_shell_layers=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "elemental_difference_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalFractionFc(dpf.Operator):
    """DPF "nodal_fraction_fc" Operator

    Transform ElementalNodal fields into Nodal fields. Each nodal
    value is the fraction between the nodal difference and the nodal
    average. Result is computed on a given node scoping.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``mesh`` : MeshedRegion, optional
         The mesh region in this pin is used to perform the averaging, if there
         is no field's support it is used

     -   ``scoping`` : Scoping, optional
         Average only on these nodes, if it is scoping container, the label
         must correspond to the one of the fields container

     -   ``denominator`` : FieldsContainer, optional
         If a fields container is set in this pin, it is used as the
         denominator of the fraction instead of elemental_nodal_to_nodal_fc


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    scoping : Scoping, optional
        Average only on these nodes, if it is scoping container, the
        label must correspond to the one of the fields container

    denominator : FieldsContainer, optional
        If a fields container is set in this pin, it is used as the
        denominator of the fraction instead of
        elemental_nodal_to_nodal_fc

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalFractionFc(my_fields_container,
                                           my_mesh, # optional
                                           my_scoping, # optional
                                           my_denominator)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalFractionFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> op.inputs.denominator.connect(my_denominator)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (3, InputSpec(document='average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (6, InputSpec(document='if a fields container is set in this pin, it is used as the denominator of the fraction instead of elemental_nodal_To_nodal_fc', ellipsis=False, name='denominator', optional=True, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._scoping = None
            self._denominator = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            """the mesh region in this pin is used to perform the averaging, if there is no field's support it is used"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def scoping(self):
            """average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def denominator(self):
            """if a fields container is set in this pin, it is used as the denominator of the fraction instead of elemental_nodal_To_nodal_fc"""
            return self._denominator

        @denominator.setter
        def denominator(self, denominator):
            self._denominator.connect(denominator)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, scoping=None, denominator=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "nodal_fraction_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ToNodal(dpf.Operator):
    """DPF "to_nodal" Operator

    Transform input field into Nodal field using an averaging process,
    result is computed on a given node scoping.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``mesh_scoping`` : Scoping, optional


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    mesh_scoping : Scoping, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ToNodal(my_field,
                                   my_mesh_scoping)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ToNodal()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._field = None
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "to_nodal"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ToNodalFc(dpf.Operator):
    """DPF "to_nodal_fc" Operator

    Transform input fields into Nodal fields using an averaging
    process, result is computed on a given node scoping.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``mesh`` : MeshedRegion, optional

     -   ``mesh_scoping`` : Scoping, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional


    mesh_scoping : Scoping, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ToNodalFc(my_fields_container,
                                     my_mesh, # optional
                                     my_mesh_scoping)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ToNodalFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (3, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "to_nodal_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalMean(dpf.Operator):
    """DPF "entity_average" Operator

    Computes the average of a multi-entity fields, (ElementalNodal ->
    Elemental), (NodalElemental -> Nodal).

    Available inputs:
     -   ``field`` : Field

     -   ``collapse_shell_layers`` : B, optional
         If true shell layers are averaged as well (default is false)

     -   ``force_averaging`` : B, optional
         If true you average, if false you just sum

     -   ``scoping`` : Scoping, optional
         Average only on these elements, if it is scoping container, the label
         must correspond to the one of the fields container


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field


    collapse_shell_layers : bool, optional
        If true shell layers are averaged as well (default is false)

    force_averaging : bool, optional
        If true you average, if false you just sum

    scoping : Scoping, optional
        Average only on these elements, if it is scoping container,
        the label must correspond to the one of the fields container

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalMean(my_field,
                                         my_collapse_shell_layers, # optional
                                         my_force_averaging, # optional
                                         my_scoping)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalMean()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.collapse_shell_layers.connect(my_collapse_shell_layers)  # optional
    >>> op.inputs.force_averaging.connect(my_force_averaging)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field'])), (1, InputSpec(document='if true shell layers are averaged as well (default is false)', ellipsis=False, name='collapse_shell_layers', optional=True, type_names=['b'])), (2, InputSpec(document='if true you average, if false you just sum', ellipsis=False, name='force_averaging', optional=True, type_names=['b'])), (3, InputSpec(document='average only on these elements, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping']))])
        def __init__(self, oper):
            self._field = None
            self._collapse_shell_layers = None
            self._force_averaging = None
            self._scoping = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def collapse_shell_layers(self):
            """if true shell layers are averaged as well (default is false)"""
            return self._collapse_shell_layers

        @collapse_shell_layers.setter
        def collapse_shell_layers(self, collapse_shell_layers):
            self._collapse_shell_layers.connect(collapse_shell_layers)

        @property
        def force_averaging(self):
            """if true you average, if false you just sum"""
            return self._force_averaging

        @force_averaging.setter
        def force_averaging(self, force_averaging):
            self._force_averaging.connect(force_averaging)

        @property
        def scoping(self):
            """average only on these elements, if it is scoping container, the label must correspond to the one of the fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, collapse_shell_layers=None, force_averaging=None, scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "entity_average"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ElementalMeanFc(dpf.Operator):
    """DPF "entity_average_fc" Operator

    Computes the average of a multi-entity container of fields,
    (ElementalNodal -> Elemental), (NodalElemental -> Nodal). If the
    input fields are mixed shell/solid and collapseShellLayers is not
    asked, then the fields are splitted by element shape and the
    output fields container has elshape label.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``collapse_shell_layers`` : B, optional
         If true shell layers are averaged as well (default is false)

     -   ``force_averaging`` : B, optional
         If true you average, if false you just sum

     -   ``scoping`` : Scoping, optional
         Average only on these elements, if it is scoping container, the label
         must correspond to the one of the fields container

     -   ``abstract_meshed_region`` : MeshedRegion, optional
         The mesh region in this pin is used to perform the averaging, if there
         is no field's support it is used


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    collapse_shell_layers : bool, optional
        If true shell layers are averaged as well (default is false)

    force_averaging : bool, optional
        If true you average, if false you just sum

    scoping : Scoping, optional
        Average only on these elements, if it is scoping container,
        the label must correspond to the one of the fields container

    abstract_meshed_region : MeshedRegion, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalMeanFc(my_fields_container,
                                           my_collapse_shell_layers, # optional
                                           my_force_averaging, # optional
                                           my_scoping, # optional
                                           my_abstract_meshed_region)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalMeanFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.collapse_shell_layers.connect(my_collapse_shell_layers)  # optional
    >>> op.inputs.force_averaging.connect(my_force_averaging)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> op.inputs.abstract_meshed_region.connect(my_abstract_meshed_region)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='if true shell layers are averaged as well (default is false)', ellipsis=False, name='collapse_shell_layers', optional=True, type_names=['b'])), (2, InputSpec(document='if true you average, if false you just sum', ellipsis=False, name='force_averaging', optional=True, type_names=['b'])), (3, InputSpec(document='average only on these elements, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (4, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='abstract_meshed_region', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._fields_container = None
            self._collapse_shell_layers = None
            self._force_averaging = None
            self._scoping = None
            self._abstract_meshed_region = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def collapse_shell_layers(self):
            """if true shell layers are averaged as well (default is false)"""
            return self._collapse_shell_layers

        @collapse_shell_layers.setter
        def collapse_shell_layers(self, collapse_shell_layers):
            self._collapse_shell_layers.connect(collapse_shell_layers)

        @property
        def force_averaging(self):
            """if true you average, if false you just sum"""
            return self._force_averaging

        @force_averaging.setter
        def force_averaging(self, force_averaging):
            self._force_averaging.connect(force_averaging)

        @property
        def scoping(self):
            """average only on these elements, if it is scoping container, the label must correspond to the one of the fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def abstract_meshed_region(self):
            """the mesh region in this pin is used to perform the averaging, if there is no field's support it is used"""
            return self._abstract_meshed_region

        @abstract_meshed_region.setter
        def abstract_meshed_region(self, abstract_meshed_region):
            self._abstract_meshed_region.connect(abstract_meshed_region)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, collapse_shell_layers=None, force_averaging=None, scoping=None, abstract_meshed_region=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "entity_average_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalToElemental(dpf.Operator):
    """DPF "nodal_to_elemental" Operator

    Transform Nodal field to Elemental field, compute result on a
    given element scoping.

    Available inputs:
     -   ``collapse_shell_layers`` : B, optional
         If true shell layers are averaged as well (default is false)

     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``mesh_scoping`` : Scoping, optional


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    mesh_scoping : Scoping, optional


    collapse_shell_layers : bool, optional
        If true shell layers are averaged as well (default is false)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalToElemental(my_field,
                                            my_mesh_scoping, # optional
                                            my_collapse_shell_layers)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalToElemental()
    >>> op.inputs.collapse_shell_layers.connect(my_collapse_shell_layers)  # optional
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (10, InputSpec(document='if true shell layers are averaged as well (default is false)', ellipsis=False, name='collapse_shell_layers', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._field = None
            self._mesh_scoping = None
            self._collapse_shell_layers = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def collapse_shell_layers(self):
            """if true shell layers are averaged as well (default is false)"""
            return self._collapse_shell_layers

        @collapse_shell_layers.setter
        def collapse_shell_layers(self, collapse_shell_layers):
            self._collapse_shell_layers.connect(collapse_shell_layers)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, mesh_scoping=None, collapse_shell_layers=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "nodal_to_elemental"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class NodalToElementalFc(dpf.Operator):
    """DPF "nodal_to_elemental_fc" Operator

    Transform Nodal fields into Elemental fields using an averaging
    process, result is computed on a given elements scoping. If the
    input fields are mixed shell/solid and the shells layers are not
    asked to be collapsed, then the fields are splitted by element
    shape and the output fields container has elshape label.

    Available inputs:
     -   ``scoping`` : Scoping, optional
         Average only on these elements, if it is scoping container, the label
         must correspond to the one of the fields container

     -   ``fields_container`` : FieldsContainer

     -   ``mesh`` : MeshedRegion, optional
         The mesh region in this pin is used to perform the averaging, if there
         is no field's support it is used

     -   ``collapse_shell_layers`` : B, optional
         If true shell layers are averaged as well (default is false)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    scoping : Scoping, optional
        Average only on these elements, if it is scoping container,
        the label must correspond to the one of the fields container

    collapse_shell_layers : bool, optional
        If true shell layers are averaged as well (default is false)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalToElementalFc(my_fields_container,
                                              my_mesh, # optional
                                              my_scoping, # optional
                                              my_collapse_shell_layers)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalToElementalFc()
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.collapse_shell_layers.connect(my_collapse_shell_layers)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (3, InputSpec(document='average only on these elements, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (10, InputSpec(document='if true shell layers are averaged as well (default is false)', ellipsis=False, name='collapse_shell_layers', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._scoping = None
            self._collapse_shell_layers = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            """the mesh region in this pin is used to perform the averaging, if there is no field's support it is used"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def scoping(self):
            """average only on these elements, if it is scoping container, the label must correspond to the one of the fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def collapse_shell_layers(self):
            """if true shell layers are averaged as well (default is false)"""
            return self._collapse_shell_layers

        @collapse_shell_layers.setter
        def collapse_shell_layers(self, collapse_shell_layers):
            self._collapse_shell_layers.connect(collapse_shell_layers)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh=None, scoping=None, collapse_shell_layers=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "nodal_to_elemental_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



