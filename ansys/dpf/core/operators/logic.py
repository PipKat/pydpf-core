"""Autogenerated DPF operator classes.

Created on 01/04/2021, 09:21:00
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class ComponentSelector(dpf.Operator):
    """DPF "component_selector" Operator

    Create a scalar/vector field based on the selected component.

    Available inputs:
     -   ``field`` : Field, FieldsContainer

     -   ``component_number`` : int, list
         One or several component index that will be extracted from the initial
         field.

     -   ``default_value`` : float, optional
         Set a default value for components that do not exist


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer


    component_number : int or list
        One or several component index that will be extracted from the
        initial field.

    default_value : float, optional
        Set a default value for components that do not exist

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ComponentSelector(my_field,
                                             my_component_number,
                                             my_default_value)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ComponentSelector()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.component_number.connect(my_component_number)
    >>> op.inputs.default_value.connect(my_default_value)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='one or several component index that will be extracted from the initial field.', ellipsis=False, name='component_number', optional=False, type_names=['int32', 'vector<int32>'])), (2, InputSpec(document='set a default value for components that do not exist', ellipsis=False, name='default_value', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._field = None
            self._component_number = None
            self._default_value = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def component_number(self):
            """one or several component index that will be extracted from the initial field."""
            return self._component_number

        @component_number.setter
        def component_number(self, component_number):
            self._component_number.connect(component_number)

        @property
        def default_value(self):
            """set a default value for components that do not exist"""
            return self._default_value

        @default_value.setter
        def default_value(self, default_value):
            self._default_value.connect(default_value)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, component_number, default_value=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "component_selector"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class MergeFieldsByLabel(dpf.Operator):
    """DPF "merge::fields_container_label" Operator

    Take a fields container and merge its fields that share the same
    label value.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``label`` : str
         Label identifier that should be merged.

     -   ``merged_field_support`` : AbstractFieldSupport, optional
         The fieldscontainer's support that has already been merged.

     -   ``sumMerge`` : B, optional
         Default is false. if true redundant quantities are summed instead of
         being ignored.


    Available outputs:
     -   fields_container
     -   merged_field_support


    Parameters
    ----------
    fields_container : FieldsContainer


    label : str
        Label identifier that should be merged.

    merged_field_support : abstract_field_support, optional
        The fieldscontainer's support that has already been merged.

    sumMerge : bool, optional
        Default is false. if true redundant quantities are summed
        instead of being ignored.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.MergeFieldsByLabel(my_fields_container,
                                              my_label,
                                              my_merged_field_support, # optional
                                              my_sumMerge)  # optional
    >>> my_fields_container = op.fields_container
    >>> my_merged_field_support = op.merged_field_support

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.MergeFieldsByLabel()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.label.connect(my_label)
    >>> op.inputs.merged_field_support.connect(my_merged_field_support)  # optional
    >>> op.inputs.sumMerge.connect(my_sumMerge)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    >>> my_merged_field_support = op.outputs.merged_field_support()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Label identifier that should be merged.', ellipsis=False, name='label', optional=False, type_names=['string'])), (2, InputSpec(document="The FieldsContainer's support that has already been merged.", ellipsis=False, name='merged_field_support', optional=True, type_names=['abstract_field_support'])), (3, InputSpec(document='Default is false. If true redundant quantities are summed instead of being ignored.', ellipsis=False, name='sumMerge', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._label = None
            self._merged_field_support = None
            self._sumMerge = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def label(self):
            """Label identifier that should be merged."""
            return self._label

        @label.setter
        def label(self, label):
            self._label.connect(label)

        @property
        def merged_field_support(self):
            """The FieldsContainer's support that has already been merged."""
            return self._merged_field_support

        @merged_field_support.setter
        def merged_field_support(self, merged_field_support):
            self._merged_field_support.connect(merged_field_support)

        @property
        def sumMerge(self):
            """Default is false. If true redundant quantities are summed instead of being ignored."""
            return self._sumMerge

        @sumMerge.setter
        def sumMerge(self, sumMerge):
            self._sumMerge.connect(sumMerge)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='')), (1, OutputSpec(name='merged_field_support', type_names=['abstract_field_support'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            self._merged_field_support = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container

        @property
        def merged_field_support(self):
            """"""
            return self._merged_field_support


    def __init__(self, fields_container, label, merged_field_support=None, sumMerge=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "merge::fields_container_label"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container

    @property
    def merged_field_support(self):
        """"""
        return self.outputs._merged_field_support



class IdenticalFields(dpf.Operator):
    """DPF "AreFieldsIdentical" Operator

    Check if two fields are identical.

    Available inputs:
     -   ``double_tolerance`` : float, optional
         Double relative tolerance.maximum tolerance gap between to compared
         values : values within relative tolerance are considered identical(v1
         - v2) / v2 < relativetol(default is 0.001).

     -   ``fieldA`` : Field

     -   ``fieldB`` : Field

     -   ``double_value`` : float, optional
         Double positive small value. smallest value which will be considered
         during the comparison step: all the abs(values) in field less than
         this value is considered as null, (default value:1.0e-14).


    Available outputs:
     -   boolean
     -   message


    Parameters
    ----------
    fieldA : Field


    fieldB : Field


    double_value : float, optional
        Double positive small value. smallest value which will be
        considered during the comparison step: all the abs(values) in
        field less than this value is considered as null, (default
        value:1.0e-14).

    double_tolerance : float, optional
        Double relative tolerance.maximum tolerance gap between to
        compared values : values within relative tolerance are
        considered identical(v1 - v2) / v2 < relativetol(default is
        0.001).

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.IdenticalFields(my_fieldA,
                                           my_fieldB,
                                           my_double_value, # optional
                                           my_double_tolerance)  # optional
    >>> my_boolean = op.boolean
    >>> my_message = op.message

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.IdenticalFields()
    >>> op.inputs.double_tolerance.connect(my_double_tolerance)  # optional
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.double_value.connect(my_double_value)  # optional
    >>> my_boolean = op.outputs.boolean()
    >>> my_message = op.outputs.message()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fieldA', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='fieldB', optional=False, type_names=['field'])), (2, InputSpec(document='Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14).', ellipsis=False, name='double_value', optional=True, type_names=['double'])), (3, InputSpec(document='Double relative tolerance.Maximum tolerance gap between to compared values : values within relative tolerance are considered identical(v1 - v2) / v2 < relativeTol(default is 0.001).', ellipsis=False, name='double_tolerance', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            self._double_value = None
            self._double_tolerance = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)

        @property
        def double_value(self):
            """Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14)."""
            return self._double_value

        @double_value.setter
        def double_value(self, double_value):
            self._double_value.connect(double_value)

        @property
        def double_tolerance(self):
            """Double relative tolerance.Maximum tolerance gap between to compared values : values within relative tolerance are considered identical(v1 - v2) / v2 < relativeTol(default is 0.001)."""
            return self._double_tolerance

        @double_tolerance.setter
        def double_tolerance(self, double_tolerance):
            self._double_tolerance.connect(double_tolerance)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='boolean', type_names=['b'], document='bool (true if identical...)')), (1, OutputSpec(name='message', type_names=['string'], document=''))])
        def __init__(self, oper):
            self._boolean = None
            self._message = None
            super().__init__(self._spec, oper)

        @property
        def boolean(self):
            """bool (true if identical...)"""
            return self._boolean

        @property
        def message(self):
            """"""
            return self._message


    def __init__(self, fieldA, fieldB, double_value=None, double_tolerance=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "AreFieldsIdentical"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def boolean(self):
        """bool (true if identical...)"""
        return self.outputs._boolean

    @property
    def message(self):
        """"""
        return self.outputs._message



class IncludedFields(dpf.Operator):
    """DPF "Are_fields_included" Operator

    Check if one field belongs to another.

    Available inputs:
     -   ``double_value`` : float
         Double positive small value. smallest value which will be considered
         during the comparison step: all the abs(values) in field less than
         this value is considered as null, (default value:1.0e-14).

     -   ``double_tolerance`` : float, optional
         Double relative tolerance. maximum tolerance gap between to compared
         values: values within relative tolerance are considered identical
         (v1-v2)/v2 < relativetol (default is 0.001).

     -   ``fieldA`` : Field

     -   ``fieldB`` : Field


    Available outputs:
     -   included
     -   message


    Parameters
    ----------
    fieldA : Field


    fieldB : Field


    double_value : float
        Double positive small value. smallest value which will be
        considered during the comparison step: all the abs(values) in
        field less than this value is considered as null, (default
        value:1.0e-14).

    double_tolerance : float, optional
        Double relative tolerance. maximum tolerance gap between to
        compared values: values within relative tolerance are
        considered identical (v1-v2)/v2 < relativetol (default is
        0.001).

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.IncludedFields(my_fieldA,
                                          my_fieldB,
                                          my_double_value,
                                          my_double_tolerance)  # optional
    >>> my_included = op.included
    >>> my_message = op.message

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.IncludedFields()
    >>> op.inputs.double_value.connect(my_double_value)
    >>> op.inputs.double_tolerance.connect(my_double_tolerance)  # optional
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> my_included = op.outputs.included()
    >>> my_message = op.outputs.message()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fieldA', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='fieldB', optional=False, type_names=['field'])), (2, InputSpec(document='Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14).', ellipsis=False, name='double_value', optional=False, type_names=['double'])), (3, InputSpec(document='Double relative tolerance. Maximum tolerance gap between to compared values: values within relative tolerance are considered identical (v1-v2)/v2 < relativeTol (default is 0.001).', ellipsis=False, name='double_tolerance', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            self._double_value = None
            self._double_tolerance = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)

        @property
        def double_value(self):
            """Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14)."""
            return self._double_value

        @double_value.setter
        def double_value(self, double_value):
            self._double_value.connect(double_value)

        @property
        def double_tolerance(self):
            """Double relative tolerance. Maximum tolerance gap between to compared values: values within relative tolerance are considered identical (v1-v2)/v2 < relativeTol (default is 0.001)."""
            return self._double_tolerance

        @double_tolerance.setter
        def double_tolerance(self, double_tolerance):
            self._double_tolerance.connect(double_tolerance)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='included', type_names=['b'], document='bool (true if belongs...)')), (1, OutputSpec(name='message', type_names=['string'], document=''))])
        def __init__(self, oper):
            self._included = None
            self._message = None
            super().__init__(self._spec, oper)

        @property
        def included(self):
            """bool (true if belongs...)"""
            return self._included

        @property
        def message(self):
            """"""
            return self._message


    def __init__(self, fieldA, fieldB, double_value, double_tolerance=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "Are_fields_included"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def included(self):
        """bool (true if belongs...)"""
        return self.outputs._included

    @property
    def message(self):
        """"""
        return self.outputs._message



