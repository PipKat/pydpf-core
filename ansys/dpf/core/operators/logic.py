"""Autogenerated DPF operator classes.

Created on 01/15/2021, 00:24:02
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class IdenticalMeshes(dpf.Operator):
    """DPF "compare::mesh" Operator

    Take two meshes and compare them.

    Available inputs:
     -   ``small_value`` : float
         Define what is a small value for numeric comparison.

     -   ``meshB`` : MeshedRegion

     -   ``meshA`` : MeshedRegion

     -   ``tolerence`` : float
         Define the relative tolerence ceil for numeric comparison.


    Available outputs:
     -   are_identical


    Parameters
    ----------
    meshA : MeshedRegion


    meshB : MeshedRegion


    small_value : float
        Define what is a small value for numeric comparison.

    tolerence : float
        Define the relative tolerence ceil for numeric comparison.



    Examples
    --------
    >>> op = dpf.operators.IdenticalMeshes()
    >>> op.inputs.small_value.connect(my_small_value)
    >>> op.inputs.meshB.connect(my_meshB)
    >>> op.inputs.meshA.connect(my_meshA)
    >>> op.inputs.tolerence.connect(my_tolerence)
    >>> my_are_identical = op.outputs.are_identical()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='meshA', optional=False, type_names=['abstract_meshed_region'])), (1, InputSpec(document='', ellipsis=False, name='meshB', optional=False, type_names=['abstract_meshed_region'])), (2, InputSpec(document='define what is a small value for numeric comparison.', ellipsis=False, name='small_value', optional=False, type_names=['double'])), (3, InputSpec(document='define the relative tolerence ceil for numeric comparison.', ellipsis=False, name='tolerence', optional=False, type_names=['double']))])
        def __init__(self, oper):
            self._meshA = None
            self._meshB = None
            self._small_value = None
            self._tolerence = None
            super().__init__(self._spec, oper)

        @property
        def meshA(self):
            return self._meshA

        @meshA.setter
        def meshA(self, meshA):
            self._meshA.connect(meshA)

        @property
        def meshB(self):
            return self._meshB

        @meshB.setter
        def meshB(self, meshB):
            self._meshB.connect(meshB)

        @property
        def small_value(self):
            """define what is a small value for numeric comparison."""
            return self._small_value

        @small_value.setter
        def small_value(self, small_value):
            self._small_value.connect(small_value)

        @property
        def tolerence(self):
            """define the relative tolerence ceil for numeric comparison."""
            return self._tolerence

        @tolerence.setter
        def tolerence(self, tolerence):
            self._tolerence.connect(tolerence)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='are_identical', type_names=['b'], document=''))])
        def __init__(self, oper):
            self._are_identical = None
            super().__init__(self._spec, oper)

        @property
        def are_identical(self):
            """"""
            return self._are_identical


    def __init__(self, meshA, meshB, small_value, tolerence):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "compare::mesh"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def are_identical(self):
        """"""
        return self.outputs._are_identical



class ComponentSelectorFc(dpf.Operator):
    """DPF "component_selector_fc" Operator

    Create a scalar fields container based on the selected component
    for each field.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``component_number`` : int


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    component_number : int




    Examples
    --------
    >>> op = dpf.operators.ComponentSelectorFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.component_number.connect(my_component_number)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='component_number', optional=False, type_names=['int32']))])
        def __init__(self, oper):
            self._fields_container = None
            self._component_number = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def component_number(self):
            return self._component_number

        @component_number.setter
        def component_number(self, component_number):
            self._component_number.connect(component_number)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, component_number):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "component_selector_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ComponentSelector(dpf.Operator):
    """DPF "component_selector" Operator

    Create a scalar/vector field based on the selected component.

    Available inputs:
     -   ``default_value`` : float, optional
         Set a default value for components that do not exist

     -   ``component_number`` : int, list
         One or several component index that will be extracted from the initial
         field.

     -   ``field`` : Field, FieldsContainer


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer


    component_number : int or list
        One or several component index that will be extracted from the
        initial field.

    default_value : float, optional
        Set a default value for components that do not exist

    Examples
    --------
    >>> op = dpf.operators.ComponentSelector()
    >>> op.inputs.default_value.connect(my_default_value)  # optional
    >>> op.inputs.component_number.connect(my_component_number)
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='one or several component index that will be extracted from the initial field.', ellipsis=False, name='component_number', optional=False, type_names=['int32', 'vector<int32>'])), (2, InputSpec(document='set a default value for components that do not exist', ellipsis=False, name='default_value', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._field = None
            self._component_number = None
            self._default_value = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def component_number(self):
            """one or several component index that will be extracted from the initial field."""
            return self._component_number

        @component_number.setter
        def component_number(self, component_number):
            self._component_number.connect(component_number)

        @property
        def default_value(self):
            """set a default value for components that do not exist"""
            return self._default_value

        @default_value.setter
        def default_value(self, default_value):
            self._default_value.connect(default_value)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, component_number, default_value=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "component_selector"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class IdenticalPropertyFields(dpf.Operator):
    """DPF "compare::property_field" Operator

    Take two property fields and compare them.

    Available inputs:
     -   ``property_fieldA`` : MeshedRegion

     -   ``property_fieldB`` : MeshedRegion


    Available outputs:
     -   informations
     -   are_identical


    Parameters
    ----------
    property_fieldA : MeshedRegion


    property_fieldB : MeshedRegion




    Examples
    --------
    >>> op = dpf.operators.IdenticalPropertyFields()
    >>> op.inputs.property_fieldA.connect(my_property_fieldA)
    >>> op.inputs.property_fieldB.connect(my_property_fieldB)
    >>> my_informations = op.outputs.informations()
    >>> my_are_identical = op.outputs.are_identical()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='property_fieldA', optional=False, type_names=['abstract_meshed_region'])), (1, InputSpec(document='', ellipsis=False, name='property_fieldB', optional=False, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._property_fieldA = None
            self._property_fieldB = None
            super().__init__(self._spec, oper)

        @property
        def property_fieldA(self):
            return self._property_fieldA

        @property_fieldA.setter
        def property_fieldA(self, property_fieldA):
            self._property_fieldA.connect(property_fieldA)

        @property
        def property_fieldB(self):
            return self._property_fieldB

        @property_fieldB.setter
        def property_fieldB(self, property_fieldB):
            self._property_fieldB.connect(property_fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='are_identical', type_names=['b'], document='')), (1, OutputSpec(name='informations', type_names=['string'], document=''))])
        def __init__(self, oper):
            self._are_identical = None
            self._informations = None
            super().__init__(self._spec, oper)

        @property
        def are_identical(self):
            """"""
            return self._are_identical

        @property
        def informations(self):
            """"""
            return self._informations


    def __init__(self, property_fieldA, property_fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "compare::property_field"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def are_identical(self):
        """"""
        return self.outputs._are_identical

    @property
    def informations(self):
        """"""
        return self.outputs._informations



class MergeFieldsByLabel(dpf.Operator):
    """DPF "merge::fields_container_label" Operator

    Take a fields container and merge its fields that share the same
    label value.

    Available inputs:
     -   ``label`` : str
         Label identifier that should be merged.

     -   ``fields_container`` : FieldsContainer

     -   ``sumMerge`` : B, optional
         Default is false. if true redundant quantities are summed instead of
         being ignored.

     -   ``merged_field_support`` : AbstractFieldSupport, optional
         The fieldscontainer's support that has already been merged.


    Available outputs:
     -   fields_container
     -   merged_field_support


    Parameters
    ----------
    fields_container : FieldsContainer


    label : str
        Label identifier that should be merged.

    merged_field_support : abstract_field_support, optional
        The fieldscontainer's support that has already been merged.

    sumMerge : bool, optional
        Default is false. if true redundant quantities are summed
        instead of being ignored.

    Examples
    --------
    >>> op = dpf.operators.MergeFieldsByLabel()
    >>> op.inputs.label.connect(my_label)
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.sumMerge.connect(my_sumMerge)  # optional
    >>> op.inputs.merged_field_support.connect(my_merged_field_support)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    >>> my_merged_field_support = op.outputs.merged_field_support()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Label identifier that should be merged.', ellipsis=False, name='label', optional=False, type_names=['string'])), (2, InputSpec(document="The FieldsContainer's support that has already been merged.", ellipsis=False, name='merged_field_support', optional=True, type_names=['abstract_field_support'])), (3, InputSpec(document='Default is false. If true redundant quantities are summed instead of being ignored.', ellipsis=False, name='sumMerge', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._label = None
            self._merged_field_support = None
            self._sumMerge = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def label(self):
            """Label identifier that should be merged."""
            return self._label

        @label.setter
        def label(self, label):
            self._label.connect(label)

        @property
        def merged_field_support(self):
            """The FieldsContainer's support that has already been merged."""
            return self._merged_field_support

        @merged_field_support.setter
        def merged_field_support(self, merged_field_support):
            self._merged_field_support.connect(merged_field_support)

        @property
        def sumMerge(self):
            """Default is false. If true redundant quantities are summed instead of being ignored."""
            return self._sumMerge

        @sumMerge.setter
        def sumMerge(self, sumMerge):
            self._sumMerge.connect(sumMerge)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='')), (1, OutputSpec(name='merged_field_support', type_names=['abstract_field_support'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            self._merged_field_support = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container

        @property
        def merged_field_support(self):
            """"""
            return self._merged_field_support


    def __init__(self, fields_container, label, merged_field_support=None, sumMerge=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "merge::fields_container_label"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container

    @property
    def merged_field_support(self):
        """"""
        return self.outputs._merged_field_support



class SolidShellFields(dpf.Operator):
    """DPF "merge::solid_shell_fields" Operator

    Makes a fields based on fields container containing shell and
    solid fields with respect to time steps/frequencies.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.SolidShellFields()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "merge::solid_shell_fields"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class IdenticalFields(dpf.Operator):
    """DPF "AreFieldsIdentical" Operator

    Check if two fields are identical.

    Available inputs:
     -   ``double_tolerance`` : float, optional
         Double relative tolerance.maximum tolerance gap between to compared
         values : values within relative tolerance are considered identical(v1
         - v2) / v2 < relativetol(default is 0.001).

     -   ``fieldA`` : Field

     -   ``fieldB`` : Field

     -   ``double_value`` : float, optional
         Double positive small value. smallest value which will be considered
         during the comparison step: all the abs(values) in field less than
         this value is considered as null, (default value:1.0e-14).


    Available outputs:
     -   message
     -   boolean


    Parameters
    ----------
    fieldA : Field


    fieldB : Field


    double_value : float, optional
        Double positive small value. smallest value which will be
        considered during the comparison step: all the abs(values) in
        field less than this value is considered as null, (default
        value:1.0e-14).

    double_tolerance : float, optional
        Double relative tolerance.maximum tolerance gap between to
        compared values : values within relative tolerance are
        considered identical(v1 - v2) / v2 < relativetol(default is
        0.001).

    Examples
    --------
    >>> op = dpf.operators.IdenticalFields()
    >>> op.inputs.double_tolerance.connect(my_double_tolerance)  # optional
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.double_value.connect(my_double_value)  # optional
    >>> my_message = op.outputs.message()
    >>> my_boolean = op.outputs.boolean()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fieldA', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='fieldB', optional=False, type_names=['field'])), (2, InputSpec(document='Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14).', ellipsis=False, name='double_value', optional=True, type_names=['double'])), (3, InputSpec(document='Double relative tolerance.Maximum tolerance gap between to compared values : values within relative tolerance are considered identical(v1 - v2) / v2 < relativeTol(default is 0.001).', ellipsis=False, name='double_tolerance', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            self._double_value = None
            self._double_tolerance = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)

        @property
        def double_value(self):
            """Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14)."""
            return self._double_value

        @double_value.setter
        def double_value(self, double_value):
            self._double_value.connect(double_value)

        @property
        def double_tolerance(self):
            """Double relative tolerance.Maximum tolerance gap between to compared values : values within relative tolerance are considered identical(v1 - v2) / v2 < relativeTol(default is 0.001)."""
            return self._double_tolerance

        @double_tolerance.setter
        def double_tolerance(self, double_tolerance):
            self._double_tolerance.connect(double_tolerance)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='boolean', type_names=['b'], document='bool (true if identical...)')), (1, OutputSpec(name='message', type_names=['string'], document=''))])
        def __init__(self, oper):
            self._boolean = None
            self._message = None
            super().__init__(self._spec, oper)

        @property
        def boolean(self):
            """bool (true if identical...)"""
            return self._boolean

        @property
        def message(self):
            """"""
            return self._message


    def __init__(self, fieldA, fieldB, double_value=None, double_tolerance=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "AreFieldsIdentical"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def boolean(self):
        """bool (true if identical...)"""
        return self.outputs._boolean

    @property
    def message(self):
        """"""
        return self.outputs._message



class IncludedFields(dpf.Operator):
    """DPF "Are_fields_included" Operator

    Check if one field belongs to another.

    Available inputs:
     -   ``fieldA`` : Field

     -   ``double_tolerance`` : float, optional
         Double relative tolerance. maximum tolerance gap between to compared
         values: values within relative tolerance are considered identical
         (v1-v2)/v2 < relativetol (default is 0.001).

     -   ``double_value`` : float
         Double positive small value. smallest value which will be considered
         during the comparison step: all the abs(values) in field less than
         this value is considered as null, (default value:1.0e-14).

     -   ``fieldB`` : Field


    Available outputs:
     -   included
     -   message


    Parameters
    ----------
    fieldA : Field


    fieldB : Field


    double_value : float
        Double positive small value. smallest value which will be
        considered during the comparison step: all the abs(values) in
        field less than this value is considered as null, (default
        value:1.0e-14).

    double_tolerance : float, optional
        Double relative tolerance. maximum tolerance gap between to
        compared values: values within relative tolerance are
        considered identical (v1-v2)/v2 < relativetol (default is
        0.001).

    Examples
    --------
    >>> op = dpf.operators.IncludedFields()
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.double_tolerance.connect(my_double_tolerance)  # optional
    >>> op.inputs.double_value.connect(my_double_value)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> my_included = op.outputs.included()
    >>> my_message = op.outputs.message()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fieldA', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='fieldB', optional=False, type_names=['field'])), (2, InputSpec(document='Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14).', ellipsis=False, name='double_value', optional=False, type_names=['double'])), (3, InputSpec(document='Double relative tolerance. Maximum tolerance gap between to compared values: values within relative tolerance are considered identical (v1-v2)/v2 < relativeTol (default is 0.001).', ellipsis=False, name='double_tolerance', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            self._double_value = None
            self._double_tolerance = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)

        @property
        def double_value(self):
            """Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14)."""
            return self._double_value

        @double_value.setter
        def double_value(self, double_value):
            self._double_value.connect(double_value)

        @property
        def double_tolerance(self):
            """Double relative tolerance. Maximum tolerance gap between to compared values: values within relative tolerance are considered identical (v1-v2)/v2 < relativeTol (default is 0.001)."""
            return self._double_tolerance

        @double_tolerance.setter
        def double_tolerance(self, double_tolerance):
            self._double_tolerance.connect(double_tolerance)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='included', type_names=['b'], document='bool (true if belongs...)')), (1, OutputSpec(name='message', type_names=['string'], document=''))])
        def __init__(self, oper):
            self._included = None
            self._message = None
            super().__init__(self._spec, oper)

        @property
        def included(self):
            """bool (true if belongs...)"""
            return self._included

        @property
        def message(self):
            """"""
            return self._message


    def __init__(self, fieldA, fieldB, double_value, double_tolerance=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "Are_fields_included"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def included(self):
        """bool (true if belongs...)"""
        return self.outputs._included

    @property
    def message(self):
        """"""
        return self.outputs._message



class IdenticalFc(dpf.Operator):
    """DPF "AreFieldsIdentical_fc" Operator

    Check if two fields container are identical.

    Available inputs:
     -   ``fields_containerB`` : FieldsContainer

     -   ``fields_containerA`` : FieldsContainer

     -   ``small_value`` : float
         Double positive small value.smallest value which will be considered
         during the comparison step : all the abs(values) in field less than
         this value is considered as null, (default value:1.0e-14).

     -   ``tolerance`` : float
         Double relative tolerance. maximum tolerance gap between to compared
         values: values within relative tolerance are considered identical
         (v1-v2)/v2 < relativetol (default is 0.001).


    Available outputs:
     -   boolean


    Parameters
    ----------
    fields_containerA : FieldsContainer


    fields_containerB : FieldsContainer


    tolerance : float
        Double relative tolerance. maximum tolerance gap between to
        compared values: values within relative tolerance are
        considered identical (v1-v2)/v2 < relativetol (default is
        0.001).

    small_value : float
        Double positive small value.smallest value which will be
        considered during the comparison step : all the abs(values) in
        field less than this value is considered as null, (default
        value:1.0e-14).



    Examples
    --------
    >>> op = dpf.operators.IdenticalFc()
    >>> op.inputs.fields_containerB.connect(my_fields_containerB)
    >>> op.inputs.fields_containerA.connect(my_fields_containerA)
    >>> op.inputs.small_value.connect(my_small_value)
    >>> op.inputs.tolerance.connect(my_tolerance)
    >>> my_boolean = op.outputs.boolean()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_containerA', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='fields_containerB', optional=False, type_names=['fields_container'])), (2, InputSpec(document='Double relative tolerance. Maximum tolerance gap between to compared values: values within relative tolerance are considered identical (v1-v2)/v2 < relativeTol (default is 0.001).', ellipsis=False, name='tolerance', optional=False, type_names=['double'])), (3, InputSpec(document='Double positive small value.Smallest value which will be considered during the comparison step : all the abs(values) in field less than this value is considered as null, (default value:1.0e-14).', ellipsis=False, name='small_value', optional=False, type_names=['double']))])
        def __init__(self, oper):
            self._fields_containerA = None
            self._fields_containerB = None
            self._tolerance = None
            self._small_value = None
            super().__init__(self._spec, oper)

        @property
        def fields_containerA(self):
            return self._fields_containerA

        @fields_containerA.setter
        def fields_containerA(self, fields_containerA):
            self._fields_containerA.connect(fields_containerA)

        @property
        def fields_containerB(self):
            return self._fields_containerB

        @fields_containerB.setter
        def fields_containerB(self, fields_containerB):
            self._fields_containerB.connect(fields_containerB)

        @property
        def tolerance(self):
            """Double relative tolerance. Maximum tolerance gap between to compared values: values within relative tolerance are considered identical (v1-v2)/v2 < relativeTol (default is 0.001)."""
            return self._tolerance

        @tolerance.setter
        def tolerance(self, tolerance):
            self._tolerance.connect(tolerance)

        @property
        def small_value(self):
            """Double positive small value.Smallest value which will be considered during the comparison step : all the abs(values) in field less than this value is considered as null, (default value:1.0e-14)."""
            return self._small_value

        @small_value.setter
        def small_value(self, small_value):
            self._small_value.connect(small_value)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='boolean', type_names=['b'], document='bool (true if identical...)'))])
        def __init__(self, oper):
            self._boolean = None
            super().__init__(self._spec, oper)

        @property
        def boolean(self):
            """bool (true if identical...)"""
            return self._boolean


    def __init__(self, fields_containerA, fields_containerB, tolerance, small_value):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "AreFieldsIdentical_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def boolean(self):
        """bool (true if identical...)"""
        return self.outputs._boolean



