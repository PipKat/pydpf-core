"""Autogenerated DPF operator classes.

Created on 01/04/2021, 09:21:00
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class PlasticStrainPrincipal1(dpf.Operator):
    """DPF "EPPL1" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component plastic strains 1st principal component).

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainPrincipal1(my_data_sources,
                                                   my_time_scoping, # optional
                                                   my_mesh_scoping, # optional
                                                   my_fields_container, # optional
                                                   my_streams_container, # optional
                                                   my_bool_rotate_to_global, # optional
                                                   my_mesh, # optional
                                                   my_requested_location, # optional
                                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainPrincipal1()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPL1"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class RigidTransformation(dpf.Operator):
    """DPF "RigidTransformationProvider" Operator

    Extracts rigid body motions from a displacement in input.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.RigidTransformation(my_data_sources,
                                               my_streams_container)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.RigidTransformation()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, streams_container=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "RigidTransformationProvider"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalAveragedElasticStrains(dpf.Operator):
    """DPF "mapdl::rst::NPEL" Operator

    Read nodal averaged elastic strains as averaged nodal result from
    rst file.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedElasticStrains(my_data_sources,
                                                       my_time_scoping, # optional
                                                       my_mesh_scoping, # optional
                                                       my_fields_container, # optional
                                                       my_streams_container, # optional
                                                       my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedElasticStrains()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NPEL"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class ElasticStrainY(dpf.Operator):
    """DPF "EPELY" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component elastic strains YY normal
    component (11 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainY(my_data_sources,
                                          my_time_scoping, # optional
                                          my_mesh_scoping, # optional
                                          my_fields_container, # optional
                                          my_streams_container, # optional
                                          my_bool_rotate_to_global, # optional
                                          my_mesh, # optional
                                          my_requested_location, # optional
                                          my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainY()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPELY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalMass(dpf.Operator):
    """DPF "ElementalMass" Operator

    Load the appropriate operator based on the data sources and
    read/compute element mass. Regarding the requested location and
    the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalMass(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalMass()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ElementalMass"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class CoEnergy(dpf.Operator):
    """DPF "ENG_CO" Operator

    Load the appropriate operator based on the data sources and
    read/compute co-energy (magnetics). Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CoEnergy(my_data_sources,
                                    my_time_scoping, # optional
                                    my_mesh_scoping, # optional
                                    my_fields_container, # optional
                                    my_streams_container, # optional
                                    my_bool_rotate_to_global, # optional
                                    my_mesh, # optional
                                    my_requested_location, # optional
                                    my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CoEnergy()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENG_CO"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalAveragedEquivalentThermalStrains(dpf.Operator):
    """DPF "mapdl::rst::NTH_EQV" Operator

    Read nodal averaged equivalent thermal strains as averaged nodal
    result from rst file.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedEquivalentThermalStrains(my_data_sources,
                                                                 my_time_scoping, # optional
                                                                 my_mesh_scoping, # optional
                                                                 my_fields_container, # optional
                                                                 my_streams_container, # optional
                                                                 my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedEquivalentThermalStrains()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NTH_EQV"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class CyclicExpandedAcceleration(dpf.Operator):
    """DPF "mapdl::rst::A_cyclic" Operator

    Read acceleration from an rst file and expand it with cyclic
    symmetry.

    Available inputs:
     -   ``sector_mesh`` : MeshedRegion, optional
         Mesh of the base sector (can be a skin).

     -   ``requested_location`` : str, optional
         Location needed in output

     -   ``read_cyclic`` : N14Dataprocessing14Ecyclicreadinge, int, optional
         If 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2
         cyclic expansion is done (default is 1)

     -   ``expanded_meshed_region`` : MeshedRegion, optional
         Mesh expanded.

     -   ``cyclic_support`` : CyclicSupport, optional

     -   ``sectors_to_expand`` : list, Scoping, ScopingsContainer, optional
         Sectors to expand (start at 0), for multistage: use scopings container
         with 'stage' label.

     -   ``phi`` : float, optional
         Angle phi (default value 0.0)

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container
     -   expanded_meshed_region


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    sector_mesh : MeshedRegion, optional
        Mesh of the base sector (can be a skin).

    requested_location : str, optional
        Location needed in output

    read_cyclic : N14dataProcessing14ECyclicReadingE or int, optional
        If 0 cyclic symmetry is ignored, if 1 cyclic sector is read,
        if 2 cyclic expansion is done (default is 1)

    expanded_meshed_region : MeshedRegion, optional
        Mesh expanded.

    cyclic_support : cyclic_support, optional


    sectors_to_expand : list or Scoping or scopings_container, optional
        Sectors to expand (start at 0), for multistage: use scopings
        container with 'stage' label.

    phi : float, optional
        Angle phi (default value 0.0)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicExpandedAcceleration(my_data_sources,
                                                      my_time_scoping, # optional
                                                      my_mesh_scoping, # optional
                                                      my_fields_container, # optional
                                                      my_streams_container, # optional
                                                      my_bool_rotate_to_global, # optional
                                                      my_sector_mesh, # optional
                                                      my_requested_location, # optional
                                                      my_read_cyclic, # optional
                                                      my_expanded_meshed_region, # optional
                                                      my_cyclic_support, # optional
                                                      my_sectors_to_expand, # optional
                                                      my_phi)  # optional
    >>> my_fields_container = op.fields_container
    >>> my_expanded_meshed_region = op.expanded_meshed_region

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicExpandedAcceleration()
    >>> op.inputs.sector_mesh.connect(my_sector_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.read_cyclic.connect(my_read_cyclic)  # optional
    >>> op.inputs.expanded_meshed_region.connect(my_expanded_meshed_region)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)  # optional
    >>> op.inputs.sectors_to_expand.connect(my_sectors_to_expand)  # optional
    >>> op.inputs.phi.connect(my_phi)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    >>> my_expanded_meshed_region = op.outputs.expanded_meshed_region()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='mesh of the base sector (can be a skin).', ellipsis=False, name='sector_mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='location needed in output', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (14, InputSpec(document='if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)', ellipsis=False, name='read_cyclic', optional=True, type_names=['N14dataProcessing14ECyclicReadingE', 'int32'])), (15, InputSpec(document='mesh expanded.', ellipsis=False, name='expanded_meshed_region', optional=True, type_names=['abstract_meshed_region'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=True, type_names=['cyclic_support'])), (18, InputSpec(document="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label.", ellipsis=False, name='sectors_to_expand', optional=True, type_names=['vector<int32>', 'scoping', 'scopings_container'])), (19, InputSpec(document='angle phi (default value 0.0)', ellipsis=False, name='phi', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._sector_mesh = None
            self._requested_location = None
            self._read_cyclic = None
            self._expanded_meshed_region = None
            self._cyclic_support = None
            self._sectors_to_expand = None
            self._phi = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def sector_mesh(self):
            """mesh of the base sector (can be a skin)."""
            return self._sector_mesh

        @sector_mesh.setter
        def sector_mesh(self, sector_mesh):
            self._sector_mesh.connect(sector_mesh)

        @property
        def requested_location(self):
            """location needed in output"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def read_cyclic(self):
            """if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)"""
            return self._read_cyclic

        @read_cyclic.setter
        def read_cyclic(self, read_cyclic):
            self._read_cyclic.connect(read_cyclic)

        @property
        def expanded_meshed_region(self):
            """mesh expanded."""
            return self._expanded_meshed_region

        @expanded_meshed_region.setter
        def expanded_meshed_region(self, expanded_meshed_region):
            self._expanded_meshed_region.connect(expanded_meshed_region)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)

        @property
        def sectors_to_expand(self):
            """sectors to expand (start at 0), for multistage: use scopings container with 'stage' label."""
            return self._sectors_to_expand

        @sectors_to_expand.setter
        def sectors_to_expand(self, sectors_to_expand):
            self._sectors_to_expand.connect(sectors_to_expand)

        @property
        def phi(self):
            """angle phi (default value 0.0)"""
            return self._phi

        @phi.setter
        def phi(self, phi):
            self._phi.connect(phi)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in')), (1, OutputSpec(name='expanded_meshed_region', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            self._expanded_meshed_region = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container

        @property
        def expanded_meshed_region(self):
            """"""
            return self._expanded_meshed_region


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, sector_mesh=None, requested_location=None, read_cyclic=None, expanded_meshed_region=None, cyclic_support=None, sectors_to_expand=None, phi=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::A_cyclic"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container

    @property
    def expanded_meshed_region(self):
        """"""
        return self.outputs._expanded_meshed_region



class ElasticStrainZ(dpf.Operator):
    """DPF "EPELZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component elastic strains ZZ normal
    component (22 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainZ(my_data_sources,
                                          my_time_scoping, # optional
                                          my_mesh_scoping, # optional
                                          my_fields_container, # optional
                                          my_streams_container, # optional
                                          my_bool_rotate_to_global, # optional
                                          my_mesh, # optional
                                          my_requested_location, # optional
                                          my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainZ()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPELZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Stress(dpf.Operator):
    """DPF "S" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal component stresses. Regarding the
    requested location and the input mesh scoping, the result location
    can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Stress(my_data_sources,
                                  my_time_scoping, # optional
                                  my_mesh_scoping, # optional
                                  my_fields_container, # optional
                                  my_streams_container, # optional
                                  my_bool_rotate_to_global, # optional
                                  my_mesh, # optional
                                  my_requested_location, # optional
                                  my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Stress()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "S"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressX(dpf.Operator):
    """DPF "SX" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component stresses XX normal component
    (00 component). Regarding the requested location and the input
    mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressX(my_data_sources,
                                   my_time_scoping, # optional
                                   my_mesh_scoping, # optional
                                   my_fields_container, # optional
                                   my_streams_container, # optional
                                   my_bool_rotate_to_global, # optional
                                   my_mesh, # optional
                                   my_requested_location, # optional
                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressX()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "SX"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressY(dpf.Operator):
    """DPF "SY" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component stresses YY normal component
    (11 component). Regarding the requested location and the input
    mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressY(my_data_sources,
                                   my_time_scoping, # optional
                                   my_mesh_scoping, # optional
                                   my_fields_container, # optional
                                   my_streams_container, # optional
                                   my_bool_rotate_to_global, # optional
                                   my_mesh, # optional
                                   my_requested_location, # optional
                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressY()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "SY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressZ(dpf.Operator):
    """DPF "SZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component stresses ZZ normal component
    (22 component). Regarding the requested location and the input
    mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressZ(my_data_sources,
                                   my_time_scoping, # optional
                                   my_mesh_scoping, # optional
                                   my_fields_container, # optional
                                   my_streams_container, # optional
                                   my_bool_rotate_to_global, # optional
                                   my_mesh, # optional
                                   my_requested_location, # optional
                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressZ()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "SZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressXy(dpf.Operator):
    """DPF "SXY" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component stresses XY shear component
    (01 component). Regarding the requested location and the input
    mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressXy(my_data_sources,
                                    my_time_scoping, # optional
                                    my_mesh_scoping, # optional
                                    my_fields_container, # optional
                                    my_streams_container, # optional
                                    my_bool_rotate_to_global, # optional
                                    my_mesh, # optional
                                    my_requested_location, # optional
                                    my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressXy()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "SXY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressYz(dpf.Operator):
    """DPF "SYZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component stresses YZ shear component
    (12 component). Regarding the requested location and the input
    mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressYz(my_data_sources,
                                    my_time_scoping, # optional
                                    my_mesh_scoping, # optional
                                    my_fields_container, # optional
                                    my_streams_container, # optional
                                    my_bool_rotate_to_global, # optional
                                    my_mesh, # optional
                                    my_requested_location, # optional
                                    my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressYz()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "SYZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressXz(dpf.Operator):
    """DPF "SXZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component stresses XZ shear component
    (02 component). Regarding the requested location and the input
    mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressXz(my_data_sources,
                                    my_time_scoping, # optional
                                    my_mesh_scoping, # optional
                                    my_fields_container, # optional
                                    my_streams_container, # optional
                                    my_bool_rotate_to_global, # optional
                                    my_mesh, # optional
                                    my_requested_location, # optional
                                    my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressXz()
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "SXZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ModalBasis(dpf.Operator):
    """DPF "ModalBasis" Operator

    Load the appropriate operator based on the data sources and
    read/compute modal basis. Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ModalBasis(my_data_sources,
                                      my_time_scoping, # optional
                                      my_mesh_scoping, # optional
                                      my_fields_container, # optional
                                      my_streams_container, # optional
                                      my_bool_rotate_to_global, # optional
                                      my_mesh, # optional
                                      my_requested_location, # optional
                                      my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ModalBasis()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ModalBasis"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressPrincipal1(dpf.Operator):
    """DPF "S1" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component stresses 1st principal component).

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressPrincipal1(my_data_sources,
                                            my_time_scoping, # optional
                                            my_mesh_scoping, # optional
                                            my_fields_container, # optional
                                            my_streams_container, # optional
                                            my_bool_rotate_to_global, # optional
                                            my_mesh, # optional
                                            my_requested_location, # optional
                                            my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressPrincipal1()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "S1"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressPrincipal2(dpf.Operator):
    """DPF "S2" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component stresses 2nd principal component).

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressPrincipal2(my_data_sources,
                                            my_time_scoping, # optional
                                            my_mesh_scoping, # optional
                                            my_fields_container, # optional
                                            my_streams_container, # optional
                                            my_bool_rotate_to_global, # optional
                                            my_mesh, # optional
                                            my_requested_location, # optional
                                            my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressPrincipal2()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "S2"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressPrincipal3(dpf.Operator):
    """DPF "S3" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component stresses 3rd principal component).

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressPrincipal3(my_data_sources,
                                            my_time_scoping, # optional
                                            my_mesh_scoping, # optional
                                            my_fields_container, # optional
                                            my_streams_container, # optional
                                            my_bool_rotate_to_global, # optional
                                            my_mesh, # optional
                                            my_requested_location, # optional
                                            my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressPrincipal3()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "S3"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalRotationByEulerNodes(dpf.Operator):
    """DPF "mapdl::rst::RotateNodalFCByEulerNodes" Operator

    read Euler angles on nodes from the rst file and rotate the fields
    in the fieldsContainer.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, Stream, N14Dataprocessing15Crstfilewrappere, optional

     -   ``data_sources`` : DataSources

     -   ``fields_container`` : FieldsContainer, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources


    fields_container : FieldsContainer, optional


    streams_container : streams_container or stream or N14dataProcessing15CRstFileWrapperE, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalRotationByEulerNodes(my_data_sources,
                                                     my_fields_container, # optional
                                                     my_streams_container)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalRotationByEulerNodes()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(2, InputSpec(document='', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream', 'N14dataProcessing15CRstFileWrapperE'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, fields_container=None, streams_container=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::RotateNodalFCByEulerNodes"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElasticStrain(dpf.Operator):
    """DPF "EPEL" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal component elastic strains. Regarding
    the requested location and the input mesh scoping, the result
    location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrain(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrain()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPEL"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElasticStrainX(dpf.Operator):
    """DPF "EPELX" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component elastic strains XX normal
    component (00 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainX(my_data_sources,
                                          my_time_scoping, # optional
                                          my_mesh_scoping, # optional
                                          my_fields_container, # optional
                                          my_streams_container, # optional
                                          my_bool_rotate_to_global, # optional
                                          my_mesh, # optional
                                          my_requested_location, # optional
                                          my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainX()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPELX"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElasticStrainXy(dpf.Operator):
    """DPF "EPELXY" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component elastic strains XY shear
    component (01 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainXy(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainXy()
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPELXY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElasticStrainYz(dpf.Operator):
    """DPF "EPELYZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component elastic strains YZ shear
    component (12 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainYz(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainYz()
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPELYZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElasticStrainXz(dpf.Operator):
    """DPF "EPELXZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component elastic strains XZ shear
    component (02 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainXz(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainXz()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPELXZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElasticStrainPrincipal1(dpf.Operator):
    """DPF "EPEL1" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component elastic strains 1st principal component).

    Available inputs:
     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainPrincipal1(my_data_sources,
                                                   my_time_scoping, # optional
                                                   my_mesh_scoping, # optional
                                                   my_fields_container, # optional
                                                   my_streams_container, # optional
                                                   my_bool_rotate_to_global, # optional
                                                   my_mesh, # optional
                                                   my_requested_location, # optional
                                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainPrincipal1()
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPEL1"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElasticStrainPrincipal2(dpf.Operator):
    """DPF "EPEL2" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component elastic strains 2nd principal component).

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainPrincipal2(my_data_sources,
                                                   my_time_scoping, # optional
                                                   my_mesh_scoping, # optional
                                                   my_fields_container, # optional
                                                   my_streams_container, # optional
                                                   my_bool_rotate_to_global, # optional
                                                   my_mesh, # optional
                                                   my_requested_location, # optional
                                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainPrincipal2()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPEL2"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElasticStrainPrincipal3(dpf.Operator):
    """DPF "EPEL3" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component elastic strains 3rd principal component).

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainPrincipal3(my_data_sources,
                                                   my_time_scoping, # optional
                                                   my_mesh_scoping, # optional
                                                   my_fields_container, # optional
                                                   my_streams_container, # optional
                                                   my_bool_rotate_to_global, # optional
                                                   my_mesh, # optional
                                                   my_requested_location, # optional
                                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainPrincipal3()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPEL3"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrain(dpf.Operator):
    """DPF "EPPL" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal component plastic strains. Regarding
    the requested location and the input mesh scoping, the result
    location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrain(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrain()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPL"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainX(dpf.Operator):
    """DPF "EPPLX" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component plastic strains XX normal
    component (00 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainX(my_data_sources,
                                          my_time_scoping, # optional
                                          my_mesh_scoping, # optional
                                          my_fields_container, # optional
                                          my_streams_container, # optional
                                          my_bool_rotate_to_global, # optional
                                          my_mesh, # optional
                                          my_requested_location, # optional
                                          my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainX()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPLX"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainY(dpf.Operator):
    """DPF "EPPLY" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component plastic strains YY normal
    component (11 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainY(my_data_sources,
                                          my_time_scoping, # optional
                                          my_mesh_scoping, # optional
                                          my_fields_container, # optional
                                          my_streams_container, # optional
                                          my_bool_rotate_to_global, # optional
                                          my_mesh, # optional
                                          my_requested_location, # optional
                                          my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainY()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPLY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainZ(dpf.Operator):
    """DPF "EPPLZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component plastic strains ZZ normal
    component (22 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainZ(my_data_sources,
                                          my_time_scoping, # optional
                                          my_mesh_scoping, # optional
                                          my_fields_container, # optional
                                          my_streams_container, # optional
                                          my_bool_rotate_to_global, # optional
                                          my_mesh, # optional
                                          my_requested_location, # optional
                                          my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainZ()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPLZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainXy(dpf.Operator):
    """DPF "EPPLXY" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component plastic strains XY shear
    component (01 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainXy(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainXy()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPLXY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class HydrostaticPressure(dpf.Operator):
    """DPF "ENL_HPRES" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal hydrostatic pressure. Regarding the
    requested location and the input mesh scoping, the result location
    can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.HydrostaticPressure(my_data_sources,
                                               my_time_scoping, # optional
                                               my_mesh_scoping, # optional
                                               my_fields_container, # optional
                                               my_streams_container, # optional
                                               my_bool_rotate_to_global, # optional
                                               my_mesh, # optional
                                               my_requested_location, # optional
                                               my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.HydrostaticPressure()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_HPRES"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainYz(dpf.Operator):
    """DPF "EPPLYZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component plastic strains YZ shear
    component (12 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainYz(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainYz()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPLYZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainXz(dpf.Operator):
    """DPF "EPPLXZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute element nodal component plastic strains XZ shear
    component (02 component). Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainXz(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainXz()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPLXZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainPrincipal2(dpf.Operator):
    """DPF "EPPL2" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component plastic strains 2nd principal component).

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainPrincipal2(my_data_sources,
                                                   my_time_scoping, # optional
                                                   my_mesh_scoping, # optional
                                                   my_fields_container, # optional
                                                   my_streams_container, # optional
                                                   my_bool_rotate_to_global, # optional
                                                   my_mesh, # optional
                                                   my_requested_location, # optional
                                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainPrincipal2()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPL2"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainPrincipal3(dpf.Operator):
    """DPF "EPPL3" Operator

     Load the appropriate operator based on the data sources,
    reads/computes the result and find its eigen values (element nodal
    component plastic strains 3rd principal component).

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainPrincipal3(my_data_sources,
                                                   my_time_scoping, # optional
                                                   my_mesh_scoping, # optional
                                                   my_fields_container, # optional
                                                   my_streams_container, # optional
                                                   my_bool_rotate_to_global, # optional
                                                   my_mesh, # optional
                                                   my_requested_location, # optional
                                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainPrincipal3()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EPPL3"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Acceleration(dpf.Operator):
    """DPF "A" Operator

    Load the appropriate operator based on the data sources and
    read/compute nodal accelerations. Regarding the requested location
    and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Acceleration(my_data_sources,
                                        my_time_scoping, # optional
                                        my_mesh_scoping, # optional
                                        my_fields_container, # optional
                                        my_streams_container, # optional
                                        my_bool_rotate_to_global, # optional
                                        my_mesh, # optional
                                        my_requested_location, # optional
                                        my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Acceleration()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "A"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class AccelerationX(dpf.Operator):
    """DPF "AX" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal accelerations X component of the vector (1st
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.AccelerationX(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.AccelerationX()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "AX"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class AccelerationY(dpf.Operator):
    """DPF "AY" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal accelerations Y component of the vector (2nd
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.AccelerationY(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.AccelerationY()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "AY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class AccelerationZ(dpf.Operator):
    """DPF "AZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal accelerations Z component of the vector (3rd
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.AccelerationZ(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.AccelerationZ()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "AZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Velocity(dpf.Operator):
    """DPF "V" Operator

    Load the appropriate operator based on the data sources and
    read/compute nodal velocities. Regarding the requested location
    and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Velocity(my_data_sources,
                                    my_time_scoping, # optional
                                    my_mesh_scoping, # optional
                                    my_fields_container, # optional
                                    my_streams_container, # optional
                                    my_bool_rotate_to_global, # optional
                                    my_mesh, # optional
                                    my_requested_location, # optional
                                    my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Velocity()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "V"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ReactionForce(dpf.Operator):
    """DPF "RF" Operator

    Load the appropriate operator based on the data sources and
    read/compute nodal reaction forces. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ReactionForce(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ReactionForce()
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "RF"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class VelocityX(dpf.Operator):
    """DPF "VX" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal velocities X component of the vector (1st
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.VelocityX(my_data_sources,
                                     my_time_scoping, # optional
                                     my_mesh_scoping, # optional
                                     my_fields_container, # optional
                                     my_streams_container, # optional
                                     my_bool_rotate_to_global, # optional
                                     my_mesh, # optional
                                     my_requested_location, # optional
                                     my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.VelocityX()
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "VX"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class VelocityY(dpf.Operator):
    """DPF "VY" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal velocities Y component of the vector (2nd
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.VelocityY(my_data_sources,
                                     my_time_scoping, # optional
                                     my_mesh_scoping, # optional
                                     my_fields_container, # optional
                                     my_streams_container, # optional
                                     my_bool_rotate_to_global, # optional
                                     my_mesh, # optional
                                     my_requested_location, # optional
                                     my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.VelocityY()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "VY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class VelocityZ(dpf.Operator):
    """DPF "VZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal velocities Z component of the vector (3rd
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.VelocityZ(my_data_sources,
                                     my_time_scoping, # optional
                                     my_mesh_scoping, # optional
                                     my_fields_container, # optional
                                     my_streams_container, # optional
                                     my_bool_rotate_to_global, # optional
                                     my_mesh, # optional
                                     my_requested_location, # optional
                                     my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.VelocityZ()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "VZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Displacement(dpf.Operator):
    """DPF "U" Operator

    Load the appropriate operator based on the data sources and
    read/compute nodal displacements. Regarding the requested location
    and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Displacement(my_data_sources,
                                        my_time_scoping, # optional
                                        my_mesh_scoping, # optional
                                        my_fields_container, # optional
                                        my_streams_container, # optional
                                        my_bool_rotate_to_global, # optional
                                        my_mesh, # optional
                                        my_requested_location, # optional
                                        my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Displacement()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "U"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class DisplacementX(dpf.Operator):
    """DPF "UX" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal displacements X component of the vector (1st
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.DisplacementX(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.DisplacementX()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "UX"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class DisplacementY(dpf.Operator):
    """DPF "UY" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal displacements Y component of the vector (2nd
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.DisplacementY(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.DisplacementY()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "UY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class DisplacementZ(dpf.Operator):
    """DPF "UZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute nodal displacements Z component of the vector (3rd
    component). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.DisplacementZ(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.DisplacementZ()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "UZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class HeatFlux(dpf.Operator):
    """DPF "TF" Operator

    Load the appropriate operator based on the data sources and
    read/compute heat flux. Regarding the requested location and the
    input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.HeatFlux(my_data_sources,
                                    my_time_scoping, # optional
                                    my_mesh_scoping, # optional
                                    my_fields_container, # optional
                                    my_streams_container, # optional
                                    my_bool_rotate_to_global, # optional
                                    my_mesh, # optional
                                    my_requested_location, # optional
                                    my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.HeatFlux()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "TF"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class HeatFluxX(dpf.Operator):
    """DPF "TFX" Operator

     Load the appropriate operator based on the data sources and
    read/compute heat flux X component of the vector (1st component).
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.HeatFluxX(my_data_sources,
                                     my_time_scoping, # optional
                                     my_mesh_scoping, # optional
                                     my_fields_container, # optional
                                     my_streams_container, # optional
                                     my_bool_rotate_to_global, # optional
                                     my_mesh, # optional
                                     my_requested_location, # optional
                                     my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.HeatFluxX()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "TFX"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class HeatFluxY(dpf.Operator):
    """DPF "TFY" Operator

     Load the appropriate operator based on the data sources and
    read/compute heat flux Y component of the vector (2nd component).
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.HeatFluxY(my_data_sources,
                                     my_time_scoping, # optional
                                     my_mesh_scoping, # optional
                                     my_fields_container, # optional
                                     my_streams_container, # optional
                                     my_bool_rotate_to_global, # optional
                                     my_mesh, # optional
                                     my_requested_location, # optional
                                     my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.HeatFluxY()
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "TFY"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElectricField(dpf.Operator):
    """DPF "EF" Operator

    Load the appropriate operator based on the data sources and
    read/compute electric field. Regarding the requested location and
    the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElectricField(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElectricField()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "EF"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class HeatFluxZ(dpf.Operator):
    """DPF "TFZ" Operator

     Load the appropriate operator based on the data sources and
    read/compute heat flux Z component of the vector (3rd component).
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         Data sources // if stream is null then we need to get the file path
         from the data sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional
         Requested location, default is nodal


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources // if stream is null then we need to get the file
        path from the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional
        Requested location, default is nodal

    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.HeatFluxZ(my_data_sources,
                                     my_time_scoping, # optional
                                     my_mesh_scoping, # optional
                                     my_fields_container, # optional
                                     my_streams_container, # optional
                                     my_bool_rotate_to_global, # optional
                                     my_mesh, # optional
                                     my_requested_location, # optional
                                     my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.HeatFluxZ()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data sources // if stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='requested location, default is Nodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources // if stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location, default is Nodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "TFZ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementNodalForces(dpf.Operator):
    """DPF "ENF" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal forces. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementNodalForces(my_data_sources,
                                              my_time_scoping, # optional
                                              my_mesh_scoping, # optional
                                              my_fields_container, # optional
                                              my_streams_container, # optional
                                              my_bool_rotate_to_global, # optional
                                              my_mesh, # optional
                                              my_requested_location, # optional
                                              my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementNodalForces()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENF"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StructuralTemperature(dpf.Operator):
    """DPF "BFE" Operator

    Load the appropriate operator based on the data sources and
    read/compute element structural nodal temperatures. Regarding the
    requested location and the input mesh scoping, the result location
    can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StructuralTemperature(my_data_sources,
                                                 my_time_scoping, # optional
                                                 my_mesh_scoping, # optional
                                                 my_fields_container, # optional
                                                 my_streams_container, # optional
                                                 my_bool_rotate_to_global, # optional
                                                 my_mesh, # optional
                                                 my_requested_location, # optional
                                                 my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StructuralTemperature()
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "BFE"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ThermalStrain(dpf.Operator):
    """DPF "ETH" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal component thermal strains. Regarding
    the requested location and the input mesh scoping, the result
    location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ThermalStrain(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ThermalStrain()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ETH"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class IncrementalEnergy(dpf.Operator):
    """DPF "ENG_INC" Operator

    Load the appropriate operator based on the data sources and
    read/compute incremental energy (magnetics). Regarding the
    requested location and the input mesh scoping, the result location
    can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.IncrementalEnergy(my_data_sources,
                                             my_time_scoping, # optional
                                             my_mesh_scoping, # optional
                                             my_fields_container, # optional
                                             my_streams_container, # optional
                                             my_bool_rotate_to_global, # optional
                                             my_mesh, # optional
                                             my_requested_location, # optional
                                             my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.IncrementalEnergy()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENG_INC"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StiffnessMatrixEnergy(dpf.Operator):
    """DPF "ENG_SE" Operator

    Load the appropriate operator based on the data sources and
    read/compute element energy associated with the stiffness matrix.
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StiffnessMatrixEnergy(my_data_sources,
                                                 my_time_scoping, # optional
                                                 my_mesh_scoping, # optional
                                                 my_fields_container, # optional
                                                 my_streams_container, # optional
                                                 my_bool_rotate_to_global, # optional
                                                 my_mesh, # optional
                                                 my_requested_location, # optional
                                                 my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StiffnessMatrixEnergy()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENG_SE"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class EqvStressParameter(dpf.Operator):
    """DPF "ENL_SEPL" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal equivalent stress parameter. Regarding
    the requested location and the input mesh scoping, the result
    location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.EqvStressParameter(my_data_sources,
                                              my_time_scoping, # optional
                                              my_mesh_scoping, # optional
                                              my_fields_container, # optional
                                              my_streams_container, # optional
                                              my_bool_rotate_to_global, # optional
                                              my_mesh, # optional
                                              my_requested_location, # optional
                                              my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.EqvStressParameter()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_SEPL"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressRatio(dpf.Operator):
    """DPF "ENL_SRAT" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal stress ratio. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressRatio(my_data_sources,
                                       my_time_scoping, # optional
                                       my_mesh_scoping, # optional
                                       my_fields_container, # optional
                                       my_streams_container, # optional
                                       my_bool_rotate_to_global, # optional
                                       my_mesh, # optional
                                       my_requested_location, # optional
                                       my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressRatio()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_SRAT"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class AccuEqvPlasticStrain(dpf.Operator):
    """DPF "ENL_EPEQ" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal accumulated equivalent plastic strain.
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.AccuEqvPlasticStrain(my_data_sources,
                                                my_time_scoping, # optional
                                                my_mesh_scoping, # optional
                                                my_fields_container, # optional
                                                my_streams_container, # optional
                                                my_bool_rotate_to_global, # optional
                                                my_mesh, # optional
                                                my_requested_location, # optional
                                                my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.AccuEqvPlasticStrain()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_EPEQ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStateVariable(dpf.Operator):
    """DPF "ENL_PSV" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal plastic state variable. Regarding the
    requested location and the input mesh scoping, the result location
    can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStateVariable(my_data_sources,
                                                my_time_scoping, # optional
                                                my_mesh_scoping, # optional
                                                my_fields_container, # optional
                                                my_streams_container, # optional
                                                my_bool_rotate_to_global, # optional
                                                my_mesh, # optional
                                                my_requested_location, # optional
                                                my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStateVariable()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_PSV"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class AccuEqvCreepStrain(dpf.Operator):
    """DPF "ENL_CREQ" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal accumulated equivalent creep strain.
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.AccuEqvCreepStrain(my_data_sources,
                                              my_time_scoping, # optional
                                              my_mesh_scoping, # optional
                                              my_fields_container, # optional
                                              my_streams_container, # optional
                                              my_bool_rotate_to_global, # optional
                                              my_mesh, # optional
                                              my_requested_location, # optional
                                              my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.AccuEqvCreepStrain()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_CREQ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainEnergyDensity(dpf.Operator):
    """DPF "ENL_PLWK" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal plastic strain energy density.
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainEnergyDensity(my_data_sources,
                                                      my_time_scoping, # optional
                                                      my_mesh_scoping, # optional
                                                      my_fields_container, # optional
                                                      my_streams_container, # optional
                                                      my_bool_rotate_to_global, # optional
                                                      my_mesh, # optional
                                                      my_requested_location, # optional
                                                      my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainEnergyDensity()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_PLWK"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class CyclicExpandedElStrain(dpf.Operator):
    """DPF "mapdl::rst::EPEL_cyclic" Operator

    Read mapdl::rst::EPEL from an rst file and expand it with cyclic
    symmetry.

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``sector_mesh`` : MeshedRegion, optional
         Mesh of the base sector (can be a skin).

     -   ``requested_location`` : str, optional
         Location needed in output

     -   ``read_cyclic`` : N14Dataprocessing14Ecyclicreadinge, int, optional
         If 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2
         cyclic expansion is done (default is 1)

     -   ``expanded_meshed_region`` : MeshedRegion, optional
         Mesh expanded.

     -   ``cyclic_support`` : CyclicSupport, optional

     -   ``sectors_to_expand`` : list, Scoping, ScopingsContainer, optional
         Sectors to expand (start at 0), for multistage: use scopings container
         with 'stage' label.

     -   ``phi`` : float, optional
         Phi angle (default value 0.0)

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.


    Available outputs:
     -   expanded_meshed_region
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    sector_mesh : MeshedRegion, optional
        Mesh of the base sector (can be a skin).

    requested_location : str, optional
        Location needed in output

    read_cyclic : N14dataProcessing14ECyclicReadingE or int, optional
        If 0 cyclic symmetry is ignored, if 1 cyclic sector is read,
        if 2 cyclic expansion is done (default is 1)

    expanded_meshed_region : MeshedRegion, optional
        Mesh expanded.

    cyclic_support : cyclic_support, optional


    sectors_to_expand : list or Scoping or scopings_container, optional
        Sectors to expand (start at 0), for multistage: use scopings
        container with 'stage' label.

    phi : float, optional
        Phi angle (default value 0.0)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicExpandedElStrain(my_data_sources,
                                                  my_time_scoping, # optional
                                                  my_mesh_scoping, # optional
                                                  my_fields_container, # optional
                                                  my_streams_container, # optional
                                                  my_bool_rotate_to_global, # optional
                                                  my_sector_mesh, # optional
                                                  my_requested_location, # optional
                                                  my_read_cyclic, # optional
                                                  my_expanded_meshed_region, # optional
                                                  my_cyclic_support, # optional
                                                  my_sectors_to_expand, # optional
                                                  my_phi)  # optional
    >>> my_expanded_meshed_region = op.expanded_meshed_region
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicExpandedElStrain()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.sector_mesh.connect(my_sector_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.read_cyclic.connect(my_read_cyclic)  # optional
    >>> op.inputs.expanded_meshed_region.connect(my_expanded_meshed_region)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)  # optional
    >>> op.inputs.sectors_to_expand.connect(my_sectors_to_expand)  # optional
    >>> op.inputs.phi.connect(my_phi)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_expanded_meshed_region = op.outputs.expanded_meshed_region()
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='mesh of the base sector (can be a skin).', ellipsis=False, name='sector_mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='location needed in output', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (14, InputSpec(document='if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)', ellipsis=False, name='read_cyclic', optional=True, type_names=['N14dataProcessing14ECyclicReadingE', 'int32'])), (15, InputSpec(document='mesh expanded.', ellipsis=False, name='expanded_meshed_region', optional=True, type_names=['abstract_meshed_region'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=True, type_names=['cyclic_support'])), (18, InputSpec(document="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label.", ellipsis=False, name='sectors_to_expand', optional=True, type_names=['vector<int32>', 'scoping', 'scopings_container'])), (19, InputSpec(document='phi angle (default value 0.0)', ellipsis=False, name='phi', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._sector_mesh = None
            self._requested_location = None
            self._read_cyclic = None
            self._expanded_meshed_region = None
            self._cyclic_support = None
            self._sectors_to_expand = None
            self._phi = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def sector_mesh(self):
            """mesh of the base sector (can be a skin)."""
            return self._sector_mesh

        @sector_mesh.setter
        def sector_mesh(self, sector_mesh):
            self._sector_mesh.connect(sector_mesh)

        @property
        def requested_location(self):
            """location needed in output"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def read_cyclic(self):
            """if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)"""
            return self._read_cyclic

        @read_cyclic.setter
        def read_cyclic(self, read_cyclic):
            self._read_cyclic.connect(read_cyclic)

        @property
        def expanded_meshed_region(self):
            """mesh expanded."""
            return self._expanded_meshed_region

        @expanded_meshed_region.setter
        def expanded_meshed_region(self, expanded_meshed_region):
            self._expanded_meshed_region.connect(expanded_meshed_region)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)

        @property
        def sectors_to_expand(self):
            """sectors to expand (start at 0), for multistage: use scopings container with 'stage' label."""
            return self._sectors_to_expand

        @sectors_to_expand.setter
        def sectors_to_expand(self, sectors_to_expand):
            self._sectors_to_expand.connect(sectors_to_expand)

        @property
        def phi(self):
            """phi angle (default value 0.0)"""
            return self._phi

        @phi.setter
        def phi(self, phi):
            self._phi.connect(phi)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in')), (1, OutputSpec(name='expanded_meshed_region', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            self._expanded_meshed_region = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container

        @property
        def expanded_meshed_region(self):
            """"""
            return self._expanded_meshed_region


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, sector_mesh=None, requested_location=None, read_cyclic=None, expanded_meshed_region=None, cyclic_support=None, sectors_to_expand=None, phi=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::EPEL_cyclic"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container

    @property
    def expanded_meshed_region(self):
        """"""
        return self.outputs._expanded_meshed_region



class CreepStrainEnergyDensity(dpf.Operator):
    """DPF "ENL_CRWK" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal creep strain energy density. Regarding
    the requested location and the input mesh scoping, the result
    location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CreepStrainEnergyDensity(my_data_sources,
                                                    my_time_scoping, # optional
                                                    my_mesh_scoping, # optional
                                                    my_fields_container, # optional
                                                    my_streams_container, # optional
                                                    my_bool_rotate_to_global, # optional
                                                    my_mesh, # optional
                                                    my_requested_location, # optional
                                                    my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CreepStrainEnergyDensity()
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_CRWK"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class MaterialPropertyOfElement(dpf.Operator):
    """DPF "MaterialPropertyOfElement" Operator

     Load the appropriate operator based on the data sources and get
    material properties

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional

     -   ``data_sources`` : DataSources


    Available outputs:
     -   material_properties


    Parameters
    ----------
    data_sources : DataSources


    streams_container : streams_container, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.MaterialPropertyOfElement(my_data_sources,
                                                     my_streams_container)  # optional
    >>> my_material_properties = op.material_properties

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.MaterialPropertyOfElement()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_material_properties = op.outputs.material_properties()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='material_properties', type_names=['field'], document='material properties'))])
        def __init__(self, oper):
            self._material_properties = None
            super().__init__(self._spec, oper)

        @property
        def material_properties(self):
            """material properties"""
            return self._material_properties


    def __init__(self, data_sources, streams_container=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "MaterialPropertyOfElement"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def material_properties(self):
        """material properties"""
        return self.outputs._material_properties



class ElasticStrainEnergyDensity(dpf.Operator):
    """DPF "ENL_ELENG" Operator

    Load the appropriate operator based on the data sources and
    read/compute element nodal elastic strain energy density.
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainEnergyDensity(my_data_sources,
                                                      my_time_scoping, # optional
                                                      my_mesh_scoping, # optional
                                                      my_fields_container, # optional
                                                      my_streams_container, # optional
                                                      my_bool_rotate_to_global, # optional
                                                      my_mesh, # optional
                                                      my_requested_location, # optional
                                                      my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainEnergyDensity()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_ELENG"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ContactStatus(dpf.Operator):
    """DPF "ECT_STAT" Operator

    Load the appropriate operator based on the data sources and
    read/compute element contact status. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactStatus(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactStatus()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_STAT"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ContactPenetration(dpf.Operator):
    """DPF "ECT_PENE" Operator

    Load the appropriate operator based on the data sources and
    read/compute element contact penetration. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactPenetration(my_data_sources,
                                              my_time_scoping, # optional
                                              my_mesh_scoping, # optional
                                              my_fields_container, # optional
                                              my_streams_container, # optional
                                              my_bool_rotate_to_global, # optional
                                              my_mesh, # optional
                                              my_requested_location, # optional
                                              my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactPenetration()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_PENE"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ContactPressure(dpf.Operator):
    """DPF "ECT_PRES" Operator

    Load the appropriate operator based on the data sources and
    read/compute element contact pressure. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactPressure(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactPressure()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_PRES"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ContactFrictionStress(dpf.Operator):
    """DPF "ECT_SFRIC" Operator

    Load the appropriate operator based on the data sources and
    read/compute element contact friction stress. Regarding the
    requested location and the input mesh scoping, the result location
    can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactFrictionStress(my_data_sources,
                                                 my_time_scoping, # optional
                                                 my_mesh_scoping, # optional
                                                 my_fields_container, # optional
                                                 my_streams_container, # optional
                                                 my_bool_rotate_to_global, # optional
                                                 my_mesh, # optional
                                                 my_requested_location, # optional
                                                 my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactFrictionStress()
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_SFRIC"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ContactTotalStress(dpf.Operator):
    """DPF "ECT_STOT" Operator

    Load the appropriate operator based on the data sources and
    read/compute element contact total stress (pressure plus
    friction). Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactTotalStress(my_data_sources,
                                              my_time_scoping, # optional
                                              my_mesh_scoping, # optional
                                              my_fields_container, # optional
                                              my_streams_container, # optional
                                              my_bool_rotate_to_global, # optional
                                              my_mesh, # optional
                                              my_requested_location, # optional
                                              my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactTotalStress()
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_STOT"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ContactSlidingDistance(dpf.Operator):
    """DPF "ECT_SLIDE" Operator

    Load the appropriate operator based on the data sources and
    read/compute element contact sliding distance. Regarding the
    requested location and the input mesh scoping, the result location
    can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactSlidingDistance(my_data_sources,
                                                  my_time_scoping, # optional
                                                  my_mesh_scoping, # optional
                                                  my_fields_container, # optional
                                                  my_streams_container, # optional
                                                  my_bool_rotate_to_global, # optional
                                                  my_mesh, # optional
                                                  my_requested_location, # optional
                                                  my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactSlidingDistance()
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_SLIDE"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ToField(dpf.Operator):
    """DPF "vtk::vtk::FieldProvider" Operator

    Write a field based on a vtk file.

    Available inputs:
     -   ``streams`` : StreamsContainer, optional
         Streams

     -   ``data_sources`` : DataSources, optional
         Data_sources


    Available outputs:
     -   fields_container


    Parameters
    ----------


    streams : streams_container, optional
        Streams

    data_sources : DataSources, optional
        Data_sources

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ToField(my_streams,
                                   my_streams, # optional
                                   my_data_sources)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ToField()
    >>> op.inputs.streams.connect(my_streams)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(3, InputSpec(document='streams', ellipsis=False, name='streams', optional=True, type_names=['streams_container'])), (4, InputSpec(document='data_sources', ellipsis=False, name='data_sources', optional=True, type_names=['data_sources']))])
        def __init__(self, oper):
            self._streams = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def streams(self):
            """streams"""
            return self._streams

        @streams.setter
        def streams(self, streams):
            self._streams.connect(streams)

        @property
        def data_sources(self):
            """data_sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='fields_container'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """fields_container"""
            return self._fields_container


    def __init__(self, , streams=None, data_sources=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "vtk::vtk::FieldProvider"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """fields_container"""
        return self.outputs._fields_container



class ContactGapDistance(dpf.Operator):
    """DPF "ECT_GAP" Operator

    Load the appropriate operator based on the data sources and
    read/compute element contact gap distance. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactGapDistance(my_data_sources,
                                              my_time_scoping, # optional
                                              my_mesh_scoping, # optional
                                              my_fields_container, # optional
                                              my_streams_container, # optional
                                              my_bool_rotate_to_global, # optional
                                              my_mesh, # optional
                                              my_requested_location, # optional
                                              my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactGapDistance()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_GAP"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ContactSurfaceHeatFlux(dpf.Operator):
    """DPF "ECT_FLUX" Operator

    Load the appropriate operator based on the data sources and
    read/compute element total heat flux at contact surface. Regarding
    the requested location and the input mesh scoping, the result
    location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactSurfaceHeatFlux(my_data_sources,
                                                  my_time_scoping, # optional
                                                  my_mesh_scoping, # optional
                                                  my_fields_container, # optional
                                                  my_streams_container, # optional
                                                  my_bool_rotate_to_global, # optional
                                                  my_mesh, # optional
                                                  my_requested_location, # optional
                                                  my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactSurfaceHeatFlux()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_FLUX"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NumSurfaceStatusChanges(dpf.Operator):
    """DPF "ECT_CNOS" Operator

    Load the appropriate operator based on the data sources and
    read/compute element total number of contact status changes during
    substep. Regarding the requested location and the input mesh
    scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NumSurfaceStatusChanges(my_data_sources,
                                                   my_time_scoping, # optional
                                                   my_mesh_scoping, # optional
                                                   my_fields_container, # optional
                                                   my_streams_container, # optional
                                                   my_bool_rotate_to_global, # optional
                                                   my_mesh, # optional
                                                   my_requested_location, # optional
                                                   my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NumSurfaceStatusChanges()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_CNOS"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ContactFluidPenetrationPressure(dpf.Operator):
    """DPF "ECT_FRES" Operator

    Load the appropriate operator based on the data sources and
    read/compute element actual applied fluid penetration pressure.
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ContactFluidPenetrationPressure(my_data_sources,
                                                           my_time_scoping, # optional
                                                           my_mesh_scoping, # optional
                                                           my_fields_container, # optional
                                                           my_streams_container, # optional
                                                           my_bool_rotate_to_global, # optional
                                                           my_mesh, # optional
                                                           my_requested_location, # optional
                                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ContactFluidPenetrationPressure()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ECT_FRES"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementalVolume(dpf.Operator):
    """DPF "ENG_VOL" Operator

    Load the appropriate operator based on the data sources and
    read/compute element volume. Regarding the requested location and
    the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementalVolume(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementalVolume()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENG_VOL"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ArtificialHourglassEnergy(dpf.Operator):
    """DPF "ENG_AHO" Operator

    Load the appropriate operator based on the data sources and
    read/compute artificial hourglass energy. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ArtificialHourglassEnergy(my_data_sources,
                                                     my_time_scoping, # optional
                                                     my_mesh_scoping, # optional
                                                     my_fields_container, # optional
                                                     my_streams_container, # optional
                                                     my_bool_rotate_to_global, # optional
                                                     my_mesh, # optional
                                                     my_requested_location, # optional
                                                     my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ArtificialHourglassEnergy()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENG_AHO"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class KineticEnergy(dpf.Operator):
    """DPF "ENG_KE" Operator

    Load the appropriate operator based on the data sources and
    read/compute kinetic energy. Regarding the requested location and
    the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.KineticEnergy(my_data_sources,
                                         my_time_scoping, # optional
                                         my_mesh_scoping, # optional
                                         my_fields_container, # optional
                                         my_streams_container, # optional
                                         my_bool_rotate_to_global, # optional
                                         my_mesh, # optional
                                         my_requested_location, # optional
                                         my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.KineticEnergy()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENG_KE"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ThermalDissipationEnergy(dpf.Operator):
    """DPF "ENG_TH" Operator

    Load the appropriate operator based on the data sources and
    read/compute thermal dissipation energy. Regarding the requested
    location and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ThermalDissipationEnergy(my_data_sources,
                                                    my_time_scoping, # optional
                                                    my_mesh_scoping, # optional
                                                    my_fields_container, # optional
                                                    my_streams_container, # optional
                                                    my_bool_rotate_to_global, # optional
                                                    my_mesh, # optional
                                                    my_requested_location, # optional
                                                    my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ThermalDissipationEnergy()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENG_TH"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalForce(dpf.Operator):
    """DPF "F" Operator

    Load the appropriate operator based on the data sources and
    read/compute nodal forces. Regarding the requested location and
    the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalForce(my_data_sources,
                                      my_time_scoping, # optional
                                      my_mesh_scoping, # optional
                                      my_fields_container, # optional
                                      my_streams_container, # optional
                                      my_bool_rotate_to_global, # optional
                                      my_mesh, # optional
                                      my_requested_location, # optional
                                      my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalForce()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "F"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalMoment(dpf.Operator):
    """DPF "M" Operator

    Load the appropriate operator based on the data sources and
    read/compute nodal moment. Regarding the requested location and
    the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``domain_id`` : int, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalMoment(my_data_sources,
                                       my_time_scoping, # optional
                                       my_mesh_scoping, # optional
                                       my_fields_container, # optional
                                       my_streams_container, # optional
                                       my_bool_rotate_to_global, # optional
                                       my_mesh, # optional
                                       my_requested_location, # optional
                                       my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalMoment()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "M"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Temperature(dpf.Operator):
    """DPF "TEMP" Operator

    Load the appropriate operator based on the data sources and
    read/compute temperature field. Regarding the requested location
    and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Temperature(my_data_sources,
                                       my_time_scoping, # optional
                                       my_mesh_scoping, # optional
                                       my_fields_container, # optional
                                       my_streams_container, # optional
                                       my_bool_rotate_to_global, # optional
                                       my_mesh, # optional
                                       my_requested_location, # optional
                                       my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Temperature()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "TEMP"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalAveragedEquivalentPlasticStrain(dpf.Operator):
    """DPF "mapdl::rst::NPPL_EQV" Operator

    Read nodal averaged equivalent plastic strain as averaged nodal
    result from rst file.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedEquivalentPlasticStrain(my_data_sources,
                                                                my_time_scoping, # optional
                                                                my_mesh_scoping, # optional
                                                                my_fields_container, # optional
                                                                my_streams_container, # optional
                                                                my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedEquivalentPlasticStrain()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NPPL_EQV"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class RawDisplacement(dpf.Operator):
    """DPF "UTOT" Operator

    Load the appropriate operator based on the data sources and
    read/compute U vector from the finite element problem KU=F.
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.RawDisplacement(my_data_sources,
                                           my_time_scoping, # optional
                                           my_mesh_scoping, # optional
                                           my_fields_container, # optional
                                           my_streams_container, # optional
                                           my_bool_rotate_to_global, # optional
                                           my_mesh, # optional
                                           my_requested_location, # optional
                                           my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.RawDisplacement()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "UTOT"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class RawReactionForce(dpf.Operator):
    """DPF "RFTOT" Operator

    Load the appropriate operator based on the data sources and
    read/compute F vector from the finite element problem KU=F.
    Regarding the requested location and the input mesh scoping, the
    result location can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.RawReactionForce(my_data_sources,
                                            my_time_scoping, # optional
                                            my_mesh_scoping, # optional
                                            my_fields_container, # optional
                                            my_streams_container, # optional
                                            my_bool_rotate_to_global, # optional
                                            my_mesh, # optional
                                            my_requested_location, # optional
                                            my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.RawReactionForce()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "RFTOT"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElectricPotential(dpf.Operator):
    """DPF "VOLT" Operator

    Load the appropriate operator based on the data sources and
    read/compute electric Potential. Regarding the requested location
    and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElectricPotential(my_data_sources,
                                             my_time_scoping, # optional
                                             my_mesh_scoping, # optional
                                             my_fields_container, # optional
                                             my_streams_container, # optional
                                             my_bool_rotate_to_global, # optional
                                             my_mesh, # optional
                                             my_requested_location, # optional
                                             my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElectricPotential()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "VOLT"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StressVonMises(dpf.Operator):
    """DPF "S_eqv" Operator

    Reads/computes element nodal component stresses, average it one
    nodes and computes its element nodal component stresses nodal /
    elemental Mises equivalent

    Available inputs:
     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        If the stream is null then we need to get the file path from
        the data sources

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping, optional
        Mesh entities scoping, unordered_map<int, int> id to index
        (optional) (index is optional, to be set if a user wants the
        results at a given order)

    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container, optional
        Streams (result file container) (optional)

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    mesh : MeshedRegion, optional


    requested_location : str, optional


    domain_id : int, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressVonMises(my_data_sources,
                                          my_time_scoping, # optional
                                          my_mesh_scoping, # optional
                                          my_fields_container, # optional
                                          my_streams_container, # optional
                                          my_bool_rotate_to_global, # optional
                                          my_mesh, # optional
                                          my_requested_location, # optional
                                          my_domain_id)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressVonMises()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, mesh=None, requested_location=None, domain_id=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "S_eqv"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalAveragedThermalStrains(dpf.Operator):
    """DPF "mapdl::rst::NTH" Operator

    Read nodal averaged thermal strains as averaged nodal result from
    rst file.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedThermalStrains(my_data_sources,
                                                       my_time_scoping, # optional
                                                       my_mesh_scoping, # optional
                                                       my_fields_container, # optional
                                                       my_streams_container, # optional
                                                       my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedThermalStrains()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NTH"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class CyclicExpandedVelocity(dpf.Operator):
    """DPF "mapdl::rst::V_cyclic" Operator

    Read velocity from an rst file and expand it with cyclic symmetry.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``sector_mesh`` : MeshedRegion, optional
         Mesh of the base sector (can be a skin).

     -   ``requested_location`` : str, optional
         Location needed in output

     -   ``read_cyclic`` : N14Dataprocessing14Ecyclicreadinge, int, optional
         If 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2
         cyclic expansion is done (default is 1)

     -   ``expanded_meshed_region`` : MeshedRegion, optional
         Mesh expanded.

     -   ``cyclic_support`` : CyclicSupport, optional

     -   ``sectors_to_expand`` : list, Scoping, ScopingsContainer, optional
         Sectors to expand (start at 0), for multistage: use scopings container
         with 'stage' label.

     -   ``phi`` : float, optional
         Angle phi (default value 0.0)


    Available outputs:
     -   fields_container
     -   expanded_meshed_region


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    sector_mesh : MeshedRegion, optional
        Mesh of the base sector (can be a skin).

    requested_location : str, optional
        Location needed in output

    read_cyclic : N14dataProcessing14ECyclicReadingE or int, optional
        If 0 cyclic symmetry is ignored, if 1 cyclic sector is read,
        if 2 cyclic expansion is done (default is 1)

    expanded_meshed_region : MeshedRegion, optional
        Mesh expanded.

    cyclic_support : cyclic_support, optional


    sectors_to_expand : list or Scoping or scopings_container, optional
        Sectors to expand (start at 0), for multistage: use scopings
        container with 'stage' label.

    phi : float, optional
        Angle phi (default value 0.0)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicExpandedVelocity(my_data_sources,
                                                  my_time_scoping, # optional
                                                  my_mesh_scoping, # optional
                                                  my_fields_container, # optional
                                                  my_streams_container, # optional
                                                  my_bool_rotate_to_global, # optional
                                                  my_sector_mesh, # optional
                                                  my_requested_location, # optional
                                                  my_read_cyclic, # optional
                                                  my_expanded_meshed_region, # optional
                                                  my_cyclic_support, # optional
                                                  my_sectors_to_expand, # optional
                                                  my_phi)  # optional
    >>> my_fields_container = op.fields_container
    >>> my_expanded_meshed_region = op.expanded_meshed_region

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicExpandedVelocity()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.sector_mesh.connect(my_sector_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.read_cyclic.connect(my_read_cyclic)  # optional
    >>> op.inputs.expanded_meshed_region.connect(my_expanded_meshed_region)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)  # optional
    >>> op.inputs.sectors_to_expand.connect(my_sectors_to_expand)  # optional
    >>> op.inputs.phi.connect(my_phi)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    >>> my_expanded_meshed_region = op.outputs.expanded_meshed_region()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='mesh of the base sector (can be a skin).', ellipsis=False, name='sector_mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='location needed in output', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (14, InputSpec(document='if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)', ellipsis=False, name='read_cyclic', optional=True, type_names=['N14dataProcessing14ECyclicReadingE', 'int32'])), (15, InputSpec(document='mesh expanded.', ellipsis=False, name='expanded_meshed_region', optional=True, type_names=['abstract_meshed_region'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=True, type_names=['cyclic_support'])), (18, InputSpec(document="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label.", ellipsis=False, name='sectors_to_expand', optional=True, type_names=['vector<int32>', 'scoping', 'scopings_container'])), (19, InputSpec(document='angle phi (default value 0.0)', ellipsis=False, name='phi', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._sector_mesh = None
            self._requested_location = None
            self._read_cyclic = None
            self._expanded_meshed_region = None
            self._cyclic_support = None
            self._sectors_to_expand = None
            self._phi = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def sector_mesh(self):
            """mesh of the base sector (can be a skin)."""
            return self._sector_mesh

        @sector_mesh.setter
        def sector_mesh(self, sector_mesh):
            self._sector_mesh.connect(sector_mesh)

        @property
        def requested_location(self):
            """location needed in output"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def read_cyclic(self):
            """if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)"""
            return self._read_cyclic

        @read_cyclic.setter
        def read_cyclic(self, read_cyclic):
            self._read_cyclic.connect(read_cyclic)

        @property
        def expanded_meshed_region(self):
            """mesh expanded."""
            return self._expanded_meshed_region

        @expanded_meshed_region.setter
        def expanded_meshed_region(self, expanded_meshed_region):
            self._expanded_meshed_region.connect(expanded_meshed_region)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)

        @property
        def sectors_to_expand(self):
            """sectors to expand (start at 0), for multistage: use scopings container with 'stage' label."""
            return self._sectors_to_expand

        @sectors_to_expand.setter
        def sectors_to_expand(self, sectors_to_expand):
            self._sectors_to_expand.connect(sectors_to_expand)

        @property
        def phi(self):
            """angle phi (default value 0.0)"""
            return self._phi

        @phi.setter
        def phi(self, phi):
            self._phi.connect(phi)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in')), (1, OutputSpec(name='expanded_meshed_region', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            self._expanded_meshed_region = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container

        @property
        def expanded_meshed_region(self):
            """"""
            return self._expanded_meshed_region


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, sector_mesh=None, requested_location=None, read_cyclic=None, expanded_meshed_region=None, cyclic_support=None, sectors_to_expand=None, phi=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::V_cyclic"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container

    @property
    def expanded_meshed_region(self):
        """"""
        return self.outputs._expanded_meshed_region



class StressRotationByEulerNodes(dpf.Operator):
    """DPF "mapdl::rst::S_rotation_by_euler_nodes" Operator

    read Euler angles on elements from the rst file and rotate the
    fields in the fieldsContainer.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional

     -   ``streams_container`` : StreamsContainer, Stream, N14Dataprocessing15Crstfilewrappere, optional

     -   ``data_sources`` : DataSources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources


    fields_container : FieldsContainer, optional


    streams_container : streams_container or stream or N14dataProcessing15CRstFileWrapperE, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.StressRotationByEulerNodes(my_data_sources,
                                                      my_fields_container, # optional
                                                      my_streams_container)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.StressRotationByEulerNodes()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(2, InputSpec(document='', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream', 'N14dataProcessing15CRstFileWrapperE'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, fields_container=None, streams_container=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::S_rotation_by_euler_nodes"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Mapdl.run(dpf.Operator):
    """DPF "mapdl::run" Operator

    Solve in mapdl a dat/inp file and returns a datasources with the
    rst file.

    Available inputs:
     -   ``mapdl_exe_path`` : str, optional

     -   ``working_dir`` : str, optional

     -   ``number_of_processes`` : int, optional
         Set the number of mpi processes used for resolution (default is 2)

     -   ``data_sources`` : DataSources
         Data sources containing the input file.


    Available outputs:
     -   data_sources


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the input file.

    mapdl_exe_path : str, optional


    working_dir : str, optional


    number_of_processes : int, optional
        Set the number of mpi processes used for resolution (default
        is 2)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Mapdl.run(my_data_sources,
                                     my_mapdl_exe_path, # optional
                                     my_working_dir, # optional
                                     my_number_of_processes)  # optional
    >>> my_data_sources = op.data_sources

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Mapdl.run()
    >>> op.inputs.mapdl_exe_path.connect(my_mapdl_exe_path)  # optional
    >>> op.inputs.working_dir.connect(my_working_dir)  # optional
    >>> op.inputs.number_of_processes.connect(my_number_of_processes)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_data_sources = op.outputs.data_sources()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mapdl_exe_path', optional=True, type_names=['string'])), (1, InputSpec(document='', ellipsis=False, name='working_dir', optional=True, type_names=['string'])), (2, InputSpec(document='Set the number of MPI processes used for resolution (default is 2)', ellipsis=False, name='number_of_processes', optional=True, type_names=['int32'])), (4, InputSpec(document='data sources containing the input file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._mapdl_exe_path = None
            self._working_dir = None
            self._number_of_processes = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def mapdl_exe_path(self):
            return self._mapdl_exe_path

        @mapdl_exe_path.setter
        def mapdl_exe_path(self, mapdl_exe_path):
            self._mapdl_exe_path.connect(mapdl_exe_path)

        @property
        def working_dir(self):
            return self._working_dir

        @working_dir.setter
        def working_dir(self, working_dir):
            self._working_dir.connect(working_dir)

        @property
        def number_of_processes(self):
            """Set the number of MPI processes used for resolution (default is 2)"""
            return self._number_of_processes

        @number_of_processes.setter
        def number_of_processes(self, number_of_processes):
            self._number_of_processes.connect(number_of_processes)

        @property
        def data_sources(self):
            """data sources containing the input file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='data_sources', type_names=['data_sources'], document=''))])
        def __init__(self, oper):
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def data_sources(self):
            """"""
            return self._data_sources


    def __init__(self, data_sources, mapdl_exe_path=None, working_dir=None, number_of_processes=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::run"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def data_sources(self):
        """"""
        return self.outputs._data_sources



class CyclicExpansion(dpf.Operator):
    """DPF "cyclic_expansion" Operator

    Expand cyclic results from a fieldsContainer for given sets,
    sectors and scoping (optionals).

    Available inputs:
     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer
         Field container with the base and duplicate sectors

     -   ``time_scoping`` : Scoping, list, optional

     -   ``cyclic_support`` : CyclicSupport


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field container with the base and duplicate sectors

    cyclic_support : cyclic_support


    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicExpansion(my_fields_container,
                                           my_cyclic_support,
                                           my_time_scoping, # optional
                                           my_mesh_scoping)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicExpansion()
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='field container with the base and duplicate sectors', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=False, type_names=['cyclic_support']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._cyclic_support = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """field container with the base and duplicate sectors"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, fields_container, cyclic_support, time_scoping=None, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cyclic_expansion"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class EquivalentRadiatedPower(dpf.Operator):
    """DPF "ERP" Operator

    Compute the Equivalent Radiated Power (ERP)

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``abstract_meshed_region`` : MeshedRegion, optional
         The mesh region in this pin have to be boundary or skin mesh

     -   ``int32`` : int, optional
         Load step number, if it's specified, the erp is computed only on the
         substeps of this step


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    abstract_meshed_region : MeshedRegion, optional
        The mesh region in this pin have to be boundary or skin mesh

    int32 : int, optional
        Load step number, if it's specified, the erp is computed only
        on the substeps of this step

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.EquivalentRadiatedPower(my_fields_container,
                                                   my_abstract_meshed_region, # optional
                                                   my_int32)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.EquivalentRadiatedPower()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.abstract_meshed_region.connect(my_abstract_meshed_region)  # optional
    >>> op.inputs.int32.connect(my_int32)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='the mesh region in this pin have to be boundary or skin mesh', ellipsis=False, name='abstract_meshed_region', optional=True, type_names=['abstract_meshed_region'])), (2, InputSpec(document="load step number, if it's specified, the ERP is computed only on the substeps of this step", ellipsis=False, name='int32', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._fields_container = None
            self._abstract_meshed_region = None
            self._int32 = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def abstract_meshed_region(self):
            """the mesh region in this pin have to be boundary or skin mesh"""
            return self._abstract_meshed_region

        @abstract_meshed_region.setter
        def abstract_meshed_region(self, abstract_meshed_region):
            self._abstract_meshed_region.connect(abstract_meshed_region)

        @property
        def int32(self):
            """load step number, if it's specified, the ERP is computed only on the substeps of this step"""
            return self._int32

        @int32.setter
        def int32(self, int32):
            self._int32.connect(int32)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, abstract_meshed_region=None, int32=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ERP"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class CyclicMeshExpansion(dpf.Operator):
    """DPF "cyclic_expansion_mesh" Operator

    Read the cyclic support.

    Available inputs:
     -   ``sector_meshed_region`` : MeshedRegion, optional

     -   ``sectors_to_expand`` : list, optional
         Vector sectors to expand (start at 0).

     -   ``cyclic_support`` : CyclicSupport


    Available outputs:
     -   meshed_region
     -   cyclic_support


    Parameters
    ----------
    cyclic_support : cyclic_support


    sectors_to_expand : list, optional
        Vector sectors to expand (start at 0).

    sector_meshed_region : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicMeshExpansion(my_cyclic_support,
                                               my_sectors_to_expand, # optional
                                               my_sector_meshed_region)  # optional
    >>> my_meshed_region = op.meshed_region
    >>> my_cyclic_support = op.cyclic_support

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicMeshExpansion()
    >>> op.inputs.sector_meshed_region.connect(my_sector_meshed_region)  # optional
    >>> op.inputs.sectors_to_expand.connect(my_sectors_to_expand)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)
    >>> my_meshed_region = op.outputs.meshed_region()
    >>> my_cyclic_support = op.outputs.cyclic_support()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='vector sectors to expand (start at 0).', ellipsis=False, name='sectors_to_expand', optional=True, type_names=['vector<int32>'])), (7, InputSpec(document='', ellipsis=False, name='sector_meshed_region', optional=True, type_names=['abstract_meshed_region'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=False, type_names=['cyclic_support']))])
        def __init__(self, oper):
            self._sectors_to_expand = None
            self._sector_meshed_region = None
            self._cyclic_support = None
            super().__init__(self._spec, oper)

        @property
        def sectors_to_expand(self):
            """vector sectors to expand (start at 0)."""
            return self._sectors_to_expand

        @sectors_to_expand.setter
        def sectors_to_expand(self, sectors_to_expand):
            self._sectors_to_expand.connect(sectors_to_expand)

        @property
        def sector_meshed_region(self):
            return self._sector_meshed_region

        @sector_meshed_region.setter
        def sector_meshed_region(self, sector_meshed_region):
            self._sector_meshed_region.connect(sector_meshed_region)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='meshed_region', type_names=['abstract_meshed_region'], document='expanded meshed region.')), (1, OutputSpec(name='cyclic_support', type_names=['cyclic_support'], document='input cyclic support modified in place containing the new expanded meshed region.'))])
        def __init__(self, oper):
            self._meshed_region = None
            self._cyclic_support = None
            super().__init__(self._spec, oper)

        @property
        def meshed_region(self):
            """expanded meshed region."""
            return self._meshed_region

        @property
        def cyclic_support(self):
            """input cyclic support modified in place containing the new expanded meshed region."""
            return self._cyclic_support


    def __init__(self, cyclic_support, sectors_to_expand=None, sector_meshed_region=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cyclic_expansion_mesh"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def meshed_region(self):
        """expanded meshed region."""
        return self.outputs._meshed_region

    @property
    def cyclic_support(self):
        """input cyclic support modified in place containing the new expanded meshed region."""
        return self.outputs._cyclic_support



class CyclicAnalyticUsumMax(dpf.Operator):
    """DPF "cyclic_analytic_usum_max" Operator

    Compute the maximum of the total deformation that can be expected
    on 360 degrees

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``cyclic_support`` : CyclicSupport

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer
         Field container with the base and duplicate sectors


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field container with the base and duplicate sectors

    cyclic_support : cyclic_support


    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicAnalyticUsumMax(my_fields_container,
                                                 my_cyclic_support,
                                                 my_time_scoping, # optional
                                                 my_mesh_scoping)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicAnalyticUsumMax()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='field container with the base and duplicate sectors', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=False, type_names=['cyclic_support']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._cyclic_support = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """field container with the base and duplicate sectors"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, fields_container, cyclic_support, time_scoping=None, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cyclic_analytic_usum_max"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class CyclicAnalyticSeqvMax(dpf.Operator):
    """DPF "cyclic_analytic_stress_eqv_max" Operator

    Compute the maximum of the Von Mises equivalent stress that can be
    expected on 360 degrees

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``cyclic_support`` : CyclicSupport

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer
         Field container with the base and duplicate sectors


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field container with the base and duplicate sectors

    cyclic_support : cyclic_support


    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicAnalyticSeqvMax(my_fields_container,
                                                 my_cyclic_support,
                                                 my_time_scoping, # optional
                                                 my_mesh_scoping)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicAnalyticSeqvMax()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='field container with the base and duplicate sectors', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=False, type_names=['cyclic_support']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._cyclic_support = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """field container with the base and duplicate sectors"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, fields_container, cyclic_support, time_scoping=None, mesh_scoping=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cyclic_analytic_stress_eqv_max"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class RemoveRigidBodyMotionFc(dpf.Operator):
    """DPF "ExtractRigidBodyMotion_fc" Operator

    Removes rigid body mode from a total displacement field by
    minimization. Use a reference point in order to substract its
    displacement to the result displacement field.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional
         Default is the mesh in the support

     -   ``fields_container`` : FieldsContainer
         Field or fields container with only one field is expected

     -   ``reference_node_id`` : int, optional
         Id of the reference entity (node).


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field or fields container with only one field is expected

    reference_node_id : int, optional
        Id of the reference entity (node).

    mesh : MeshedRegion, optional
        Default is the mesh in the support

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.RemoveRigidBodyMotionFc(my_fields_container,
                                                   my_reference_node_id, # optional
                                                   my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.RemoveRigidBodyMotionFc()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.reference_node_id.connect(my_reference_node_id)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Id of the reference entity (node).', ellipsis=False, name='reference_node_id', optional=True, type_names=['int32'])), (7, InputSpec(document='default is the mesh in the support', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._fields_container = None
            self._reference_node_id = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """field or fields container with only one field is expected"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def reference_node_id(self):
            """Id of the reference entity (node)."""
            return self._reference_node_id

        @reference_node_id.setter
        def reference_node_id(self, reference_node_id):
            self._reference_node_id.connect(reference_node_id)

        @property
        def mesh(self):
            """default is the mesh in the support"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, reference_node_id=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ExtractRigidBodyMotion_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NodalAveragedThermalSwellingStrains(dpf.Operator):
    """DPF "mapdl::rst::NTH_SWL" Operator

    Read nodal averaged thermal swelling strains as averaged nodal
    result from rst file.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedThermalSwellingStrains(my_data_sources,
                                                               my_time_scoping, # optional
                                                               my_mesh_scoping, # optional
                                                               my_fields_container, # optional
                                                               my_streams_container, # optional
                                                               my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedThermalSwellingStrains()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NTH_SWL"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class AddRigidBodyMotion(dpf.Operator):
    """DPF "RigidBodyAddition" Operator

    Adds a given rigid translation, center and rotation from a
    displacement field. The rotation is given in terms of rotations
    angles. Note that the displacement field has to be in the global
    coordinate sytem

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional
         Default is the mesh in the support

     -   ``displacement_field`` : Field

     -   ``translation_field`` : Field

     -   ``rotation_field`` : Field

     -   ``center_field`` : Field


    Available outputs:
     -   field


    Parameters
    ----------
    displacement_field : Field


    translation_field : Field


    rotation_field : Field


    center_field : Field


    mesh : MeshedRegion, optional
        Default is the mesh in the support

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.AddRigidBodyMotion(my_displacement_field,
                                              my_translation_field,
                                              my_rotation_field,
                                              my_center_field,
                                              my_mesh)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.AddRigidBodyMotion()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.displacement_field.connect(my_displacement_field)
    >>> op.inputs.translation_field.connect(my_translation_field)
    >>> op.inputs.rotation_field.connect(my_rotation_field)
    >>> op.inputs.center_field.connect(my_center_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='displacement_field', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='translation_field', optional=False, type_names=['field'])), (2, InputSpec(document='', ellipsis=False, name='rotation_field', optional=False, type_names=['field'])), (3, InputSpec(document='', ellipsis=False, name='center_field', optional=False, type_names=['field'])), (7, InputSpec(document='default is the mesh in the support', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._displacement_field = None
            self._translation_field = None
            self._rotation_field = None
            self._center_field = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def displacement_field(self):
            return self._displacement_field

        @displacement_field.setter
        def displacement_field(self, displacement_field):
            self._displacement_field.connect(displacement_field)

        @property
        def translation_field(self):
            return self._translation_field

        @translation_field.setter
        def translation_field(self, translation_field):
            self._translation_field.connect(translation_field)

        @property
        def rotation_field(self):
            return self._rotation_field

        @rotation_field.setter
        def rotation_field(self, rotation_field):
            self._rotation_field.connect(rotation_field)

        @property
        def center_field(self):
            return self._center_field

        @center_field.setter
        def center_field(self, center_field):
            self._center_field.connect(center_field)

        @property
        def mesh(self):
            """default is the mesh in the support"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, displacement_field, translation_field, rotation_field, center_field, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "RigidBodyAddition"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class NodalAveragedStresses(dpf.Operator):
    """DPF "mapdl::rst::NS" Operator

    Read nodal averaged stresses as averaged nodal result from rst
    file.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedStresses(my_data_sources,
                                                 my_time_scoping, # optional
                                                 my_mesh_scoping, # optional
                                                 my_fields_container, # optional
                                                 my_streams_container, # optional
                                                 my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedStresses()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NS"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class NodalAveragedPlasticStrains(dpf.Operator):
    """DPF "mapdl::rst::NPPL" Operator

    Read nodal averaged plastic strains as averaged nodal result from
    rst file.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedPlasticStrains(my_data_sources,
                                                       my_time_scoping, # optional
                                                       my_mesh_scoping, # optional
                                                       my_fields_container, # optional
                                                       my_streams_container, # optional
                                                       my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedPlasticStrains()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NPPL"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class NodalAveragedCreepStrains(dpf.Operator):
    """DPF "mapdl::rst::NCR" Operator

    Read nodal averaged creep strains as averaged nodal result from
    rst file.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedCreepStrains(my_data_sources,
                                                     my_time_scoping, # optional
                                                     my_mesh_scoping, # optional
                                                     my_fields_container, # optional
                                                     my_streams_container, # optional
                                                     my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedCreepStrains()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NCR"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class NodalAveragedEquivalentElasticStrain(dpf.Operator):
    """DPF "mapdl::rst::NPEL_EQV" Operator

    Read nodal averaged equivalent elastic strain as averaged nodal
    result from rst file.

    Available inputs:
     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedEquivalentElasticStrain(my_data_sources,
                                                                my_time_scoping, # optional
                                                                my_mesh_scoping, # optional
                                                                my_fields_container, # optional
                                                                my_streams_container, # optional
                                                                my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedEquivalentElasticStrain()
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NPEL_EQV"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class NodalAveragedEquivalentCreepStrain(dpf.Operator):
    """DPF "mapdl::rst::NCR_EQV" Operator

    Read nodal averaged equivalent creep strain as averaged nodal
    result from rst file.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.NodalAveragedEquivalentCreepStrain(my_data_sources,
                                                              my_time_scoping, # optional
                                                              my_mesh_scoping, # optional
                                                              my_fields_container, # optional
                                                              my_streams_container, # optional
                                                              my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.NodalAveragedEquivalentCreepStrain()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::NCR_EQV"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class EulerNodes(dpf.Operator):
    """DPF "mapdl::rst::coords_and_euler_nodes" Operator

    read a field made of 3 coordinates and 3 Euler angles (6 dofs) by
    node from the rst file.

    Available inputs:
     -   ``streams_container`` : StreamsContainer, Stream, N14Dataprocessing15Crstfilewrappere, optional

     -   ``data_sources`` : DataSources

     -   ``coord_and_euler`` : B
         If true, then the field has ncomp=6 with 3 oords and 3 euler angles,
         else there is only the euler angles (default is true)

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources


    coord_and_euler : bool
        If true, then the field has ncomp=6 with 3 oords and 3 euler
        angles, else there is only the euler angles (default is true)

    streams_container : streams_container or stream or N14dataProcessing15CRstFileWrapperE, optional


    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.EulerNodes(my_data_sources,
                                      my_coord_and_euler,
                                      my_streams_container, # optional
                                      my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.EulerNodes()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.coord_and_euler.connect(my_coord_and_euler)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream', 'N14dataProcessing15CRstFileWrapperE'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (6, InputSpec(document='if true, then the field has ncomp=6 with 3 oords and 3 euler angles, else there is only the euler angles (default is true)', ellipsis=False, name='coord_and_euler', optional=False, type_names=['b'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._streams_container = None
            self._data_sources = None
            self._coord_and_euler = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def coord_and_euler(self):
            """if true, then the field has ncomp=6 with 3 oords and 3 euler angles, else there is only the euler angles (default is true)"""
            return self._coord_and_euler

        @coord_and_euler.setter
        def coord_and_euler(self, coord_and_euler):
            self._coord_and_euler.connect(coord_and_euler)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, coord_and_euler, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::coords_and_euler_nodes"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Mapdl.nmisc(dpf.Operator):
    """DPF "mapdl::nmisc" Operator

    Read NMISC results from the rst file.

    Available inputs:
     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional

     -   ``time_scoping`` : Scoping, list, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Mapdl.nmisc(my_data_sources,
                                       my_time_scoping, # optional
                                       my_mesh_scoping, # optional
                                       my_fields_container, # optional
                                       my_streams_container, # optional
                                       my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Mapdl.nmisc()
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::nmisc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class EnfRotationByEulerNodes(dpf.Operator):
    """DPF "ENF_rotation_by_euler_nodes" Operator

    read Euler angles on elements from the rst file and rotate the
    fields in the fieldsContainer.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional

     -   ``streams_container`` : StreamsContainer, Stream, N14Dataprocessing15Crstfilewrappere, optional

     -   ``data_sources`` : DataSources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources


    fields_container : FieldsContainer, optional


    streams_container : streams_container or stream or N14dataProcessing15CRstFileWrapperE, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.EnfRotationByEulerNodes(my_data_sources,
                                                   my_fields_container, # optional
                                                   my_streams_container)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.EnfRotationByEulerNodes()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(2, InputSpec(document='', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream', 'N14dataProcessing15CRstFileWrapperE'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, fields_container=None, streams_container=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENF_rotation_by_euler_nodes"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Mapdl.smisc(dpf.Operator):
    """DPF "mapdl::smisc" Operator

    Read SMISC results from the rst file.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``mesh`` : MeshedRegion, optional


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    mesh : MeshedRegion, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Mapdl.smisc(my_data_sources,
                                       my_time_scoping, # optional
                                       my_mesh_scoping, # optional
                                       my_fields_container, # optional
                                       my_streams_container, # optional
                                       my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Mapdl.smisc()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in'))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::smisc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container



class ElasticStrainRotationByEulerNodes(dpf.Operator):
    """DPF "mapdl::rst::EPEL_rotation_by_euler_nodes" Operator

    read Euler angles on elements from the rst file and rotate the
    fields in the fieldsContainer.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional

     -   ``streams_container`` : StreamsContainer, Stream, N14Dataprocessing15Crstfilewrappere, optional

     -   ``data_sources`` : DataSources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources


    fields_container : FieldsContainer, optional


    streams_container : streams_container or stream or N14dataProcessing15CRstFileWrapperE, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElasticStrainRotationByEulerNodes(my_data_sources,
                                                             my_fields_container, # optional
                                                             my_streams_container)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElasticStrainRotationByEulerNodes()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(2, InputSpec(document='', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream', 'N14dataProcessing15CRstFileWrapperE'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, fields_container=None, streams_container=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::EPEL_rotation_by_euler_nodes"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PlasticStrainRotationByEulerNodes(dpf.Operator):
    """DPF "mapdl::rst::EPPL_rotation_by_euler_nodes" Operator

    read Euler angles on elements from the rst file and rotate the
    fields in the fieldsContainer.

    Available inputs:
     -   ``fields_container`` : FieldsContainer, optional

     -   ``streams_container`` : StreamsContainer, Stream, N14Dataprocessing15Crstfilewrappere, optional

     -   ``data_sources`` : DataSources


    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources


    fields_container : FieldsContainer, optional


    streams_container : streams_container or stream or N14dataProcessing15CRstFileWrapperE, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PlasticStrainRotationByEulerNodes(my_data_sources,
                                                             my_fields_container, # optional
                                                             my_streams_container)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PlasticStrainRotationByEulerNodes()
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(2, InputSpec(document='', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream', 'N14dataProcessing15CRstFileWrapperE'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, data_sources, fields_container=None, streams_container=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::EPPL_rotation_by_euler_nodes"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class RemoveRigidBodyMotion(dpf.Operator):
    """DPF "ExtractRigidBodyMotion" Operator

    Removes rigid body mode from a total displacement field by
    minimization. Use a reference point in order to substract its
    displacement to the result displacement field.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``reference_node_id`` : int, optional
         Id of the reference entity (node).

     -   ``mesh`` : MeshedRegion, optional
         Default is the mesh in the support


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    reference_node_id : int, optional
        Id of the reference entity (node).

    mesh : MeshedRegion, optional
        Default is the mesh in the support

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.RemoveRigidBodyMotion(my_field,
                                                 my_reference_node_id, # optional
                                                 my_mesh)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.RemoveRigidBodyMotion()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.reference_node_id.connect(my_reference_node_id)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='Id of the reference entity (node).', ellipsis=False, name='reference_node_id', optional=True, type_names=['int32'])), (7, InputSpec(document='default is the mesh in the support', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._field = None
            self._reference_node_id = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def reference_node_id(self):
            """Id of the reference entity (node)."""
            return self._reference_node_id

        @reference_node_id.setter
        def reference_node_id(self, reference_node_id):
            self._reference_node_id.connect(reference_node_id)

        @property
        def mesh(self):
            """default is the mesh in the support"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, reference_node_id=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ExtractRigidBodyMotion"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class AddRigidBodyMotionFc(dpf.Operator):
    """DPF "RigidBodyAddition_fc" Operator

    Adds a given rigid translation, center and rotation from a
    displacement field. The rotation is given in terms of rotations
    angles. Note that the displacement field has to be in the global
    coordinate sytem

    Available inputs:
     -   ``translation_field`` : Field

     -   ``rotation_field`` : Field

     -   ``center_field`` : Field

     -   ``mesh`` : MeshedRegion, optional
         Default is the mesh in the support

     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    translation_field : Field


    rotation_field : Field


    center_field : Field


    mesh : MeshedRegion, optional
        Default is the mesh in the support

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.AddRigidBodyMotionFc(my_fields_container,
                                                my_translation_field,
                                                my_rotation_field,
                                                my_center_field,
                                                my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.AddRigidBodyMotionFc()
    >>> op.inputs.translation_field.connect(my_translation_field)
    >>> op.inputs.rotation_field.connect(my_rotation_field)
    >>> op.inputs.center_field.connect(my_center_field)
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='translation_field', optional=False, type_names=['field'])), (2, InputSpec(document='', ellipsis=False, name='rotation_field', optional=False, type_names=['field'])), (3, InputSpec(document='', ellipsis=False, name='center_field', optional=False, type_names=['field'])), (7, InputSpec(document='default is the mesh in the support', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._fields_container = None
            self._translation_field = None
            self._rotation_field = None
            self._center_field = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def translation_field(self):
            return self._translation_field

        @translation_field.setter
        def translation_field(self, translation_field):
            self._translation_field.connect(translation_field)

        @property
        def rotation_field(self):
            return self._rotation_field

        @rotation_field.setter
        def rotation_field(self, rotation_field):
            self._rotation_field.connect(rotation_field)

        @property
        def center_field(self):
            return self._center_field

        @center_field.setter
        def center_field(self, center_field):
            self._center_field.connect(center_field)

        @property
        def mesh(self):
            """default is the mesh in the support"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, translation_field, rotation_field, center_field, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "RigidBodyAddition_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class CyclicExpandedDisplacement(dpf.Operator):
    """DPF "mapdl::rst::U_cyclic" Operator

    Read displacements from an rst file and expand it with cyclic
    symmetry.

    Available inputs:
     -   ``sectors_to_expand`` : list, Scoping, ScopingsContainer, optional
         Sectors to expand (start at 0), for multistage: use scopings container
         with 'stage' label.

     -   ``phi`` : float, optional
         Angle phi (default value 0.0)

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``sector_mesh`` : MeshedRegion, optional
         Mesh of the base sector (can be a skin).

     -   ``requested_location`` : str, optional
         Location needed in output

     -   ``read_cyclic`` : N14Dataprocessing14Ecyclicreadinge, int, optional
         If 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2
         cyclic expansion is done (default is 1)

     -   ``expanded_meshed_region`` : MeshedRegion, optional
         Mesh expanded.

     -   ``cyclic_support`` : CyclicSupport, optional


    Available outputs:
     -   fields_container
     -   expanded_meshed_region


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    sector_mesh : MeshedRegion, optional
        Mesh of the base sector (can be a skin).

    requested_location : str, optional
        Location needed in output

    read_cyclic : N14dataProcessing14ECyclicReadingE or int, optional
        If 0 cyclic symmetry is ignored, if 1 cyclic sector is read,
        if 2 cyclic expansion is done (default is 1)

    expanded_meshed_region : MeshedRegion, optional
        Mesh expanded.

    cyclic_support : cyclic_support, optional


    sectors_to_expand : list or Scoping or scopings_container, optional
        Sectors to expand (start at 0), for multistage: use scopings
        container with 'stage' label.

    phi : float, optional
        Angle phi (default value 0.0)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicExpandedDisplacement(my_data_sources,
                                                      my_time_scoping, # optional
                                                      my_mesh_scoping, # optional
                                                      my_fields_container, # optional
                                                      my_streams_container, # optional
                                                      my_bool_rotate_to_global, # optional
                                                      my_sector_mesh, # optional
                                                      my_requested_location, # optional
                                                      my_read_cyclic, # optional
                                                      my_expanded_meshed_region, # optional
                                                      my_cyclic_support, # optional
                                                      my_sectors_to_expand, # optional
                                                      my_phi)  # optional
    >>> my_fields_container = op.fields_container
    >>> my_expanded_meshed_region = op.expanded_meshed_region

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicExpandedDisplacement()
    >>> op.inputs.sectors_to_expand.connect(my_sectors_to_expand)  # optional
    >>> op.inputs.phi.connect(my_phi)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.sector_mesh.connect(my_sector_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.read_cyclic.connect(my_read_cyclic)  # optional
    >>> op.inputs.expanded_meshed_region.connect(my_expanded_meshed_region)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    >>> my_expanded_meshed_region = op.outputs.expanded_meshed_region()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='mesh of the base sector (can be a skin).', ellipsis=False, name='sector_mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='location needed in output', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (14, InputSpec(document='if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)', ellipsis=False, name='read_cyclic', optional=True, type_names=['N14dataProcessing14ECyclicReadingE', 'int32'])), (15, InputSpec(document='mesh expanded.', ellipsis=False, name='expanded_meshed_region', optional=True, type_names=['abstract_meshed_region'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=True, type_names=['cyclic_support'])), (18, InputSpec(document="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label.", ellipsis=False, name='sectors_to_expand', optional=True, type_names=['vector<int32>', 'scoping', 'scopings_container'])), (19, InputSpec(document='angle phi (default value 0.0)', ellipsis=False, name='phi', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._sector_mesh = None
            self._requested_location = None
            self._read_cyclic = None
            self._expanded_meshed_region = None
            self._cyclic_support = None
            self._sectors_to_expand = None
            self._phi = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def sector_mesh(self):
            """mesh of the base sector (can be a skin)."""
            return self._sector_mesh

        @sector_mesh.setter
        def sector_mesh(self, sector_mesh):
            self._sector_mesh.connect(sector_mesh)

        @property
        def requested_location(self):
            """location needed in output"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def read_cyclic(self):
            """if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)"""
            return self._read_cyclic

        @read_cyclic.setter
        def read_cyclic(self, read_cyclic):
            self._read_cyclic.connect(read_cyclic)

        @property
        def expanded_meshed_region(self):
            """mesh expanded."""
            return self._expanded_meshed_region

        @expanded_meshed_region.setter
        def expanded_meshed_region(self, expanded_meshed_region):
            self._expanded_meshed_region.connect(expanded_meshed_region)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)

        @property
        def sectors_to_expand(self):
            """sectors to expand (start at 0), for multistage: use scopings container with 'stage' label."""
            return self._sectors_to_expand

        @sectors_to_expand.setter
        def sectors_to_expand(self, sectors_to_expand):
            self._sectors_to_expand.connect(sectors_to_expand)

        @property
        def phi(self):
            """angle phi (default value 0.0)"""
            return self._phi

        @phi.setter
        def phi(self, phi):
            self._phi.connect(phi)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in')), (1, OutputSpec(name='expanded_meshed_region', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            self._expanded_meshed_region = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container

        @property
        def expanded_meshed_region(self):
            """"""
            return self._expanded_meshed_region


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, sector_mesh=None, requested_location=None, read_cyclic=None, expanded_meshed_region=None, cyclic_support=None, sectors_to_expand=None, phi=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::U_cyclic"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container

    @property
    def expanded_meshed_region(self):
        """"""
        return self.outputs._expanded_meshed_region



class CyclicExpandedStress(dpf.Operator):
    """DPF "mapdl::rst::S_cyclic" Operator

    Read mapdl::rst::S from an rst file and expand it with cyclic
    symmetry.

    Available inputs:
     -   ``read_cyclic`` : N14Dataprocessing14Ecyclicreadinge, int, optional
         If 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2
         cyclic expansion is done (default is 1)

     -   ``expanded_meshed_region`` : MeshedRegion, optional
         Mesh expanded.

     -   ``cyclic_support`` : CyclicSupport, optional

     -   ``sectors_to_expand`` : list, Scoping, ScopingsContainer, optional
         Sectors to expand (start at 0), for multistage: use scopings container
         with 'stage' label.

     -   ``phi`` : float, optional
         Phi angle (default value 0.0)

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``sector_mesh`` : MeshedRegion, optional
         Mesh of the base sector (can be a skin).

     -   ``requested_location`` : str, optional
         Location needed in output


    Available outputs:
     -   fields_container
     -   expanded_meshed_region


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    sector_mesh : MeshedRegion, optional
        Mesh of the base sector (can be a skin).

    requested_location : str, optional
        Location needed in output

    read_cyclic : N14dataProcessing14ECyclicReadingE or int, optional
        If 0 cyclic symmetry is ignored, if 1 cyclic sector is read,
        if 2 cyclic expansion is done (default is 1)

    expanded_meshed_region : MeshedRegion, optional
        Mesh expanded.

    cyclic_support : cyclic_support, optional


    sectors_to_expand : list or Scoping or scopings_container, optional
        Sectors to expand (start at 0), for multistage: use scopings
        container with 'stage' label.

    phi : float, optional
        Phi angle (default value 0.0)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicExpandedStress(my_data_sources,
                                                my_time_scoping, # optional
                                                my_mesh_scoping, # optional
                                                my_fields_container, # optional
                                                my_streams_container, # optional
                                                my_bool_rotate_to_global, # optional
                                                my_sector_mesh, # optional
                                                my_requested_location, # optional
                                                my_read_cyclic, # optional
                                                my_expanded_meshed_region, # optional
                                                my_cyclic_support, # optional
                                                my_sectors_to_expand, # optional
                                                my_phi)  # optional
    >>> my_fields_container = op.fields_container
    >>> my_expanded_meshed_region = op.expanded_meshed_region

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicExpandedStress()
    >>> op.inputs.read_cyclic.connect(my_read_cyclic)  # optional
    >>> op.inputs.expanded_meshed_region.connect(my_expanded_meshed_region)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)  # optional
    >>> op.inputs.sectors_to_expand.connect(my_sectors_to_expand)  # optional
    >>> op.inputs.phi.connect(my_phi)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.sector_mesh.connect(my_sector_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    >>> my_expanded_meshed_region = op.outputs.expanded_meshed_region()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='mesh of the base sector (can be a skin).', ellipsis=False, name='sector_mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='location needed in output', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (14, InputSpec(document='if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)', ellipsis=False, name='read_cyclic', optional=True, type_names=['N14dataProcessing14ECyclicReadingE', 'int32'])), (15, InputSpec(document='mesh expanded.', ellipsis=False, name='expanded_meshed_region', optional=True, type_names=['abstract_meshed_region'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=True, type_names=['cyclic_support'])), (18, InputSpec(document="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label.", ellipsis=False, name='sectors_to_expand', optional=True, type_names=['vector<int32>', 'scoping', 'scopings_container'])), (19, InputSpec(document='phi angle (default value 0.0)', ellipsis=False, name='phi', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._sector_mesh = None
            self._requested_location = None
            self._read_cyclic = None
            self._expanded_meshed_region = None
            self._cyclic_support = None
            self._sectors_to_expand = None
            self._phi = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def sector_mesh(self):
            """mesh of the base sector (can be a skin)."""
            return self._sector_mesh

        @sector_mesh.setter
        def sector_mesh(self, sector_mesh):
            self._sector_mesh.connect(sector_mesh)

        @property
        def requested_location(self):
            """location needed in output"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def read_cyclic(self):
            """if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)"""
            return self._read_cyclic

        @read_cyclic.setter
        def read_cyclic(self, read_cyclic):
            self._read_cyclic.connect(read_cyclic)

        @property
        def expanded_meshed_region(self):
            """mesh expanded."""
            return self._expanded_meshed_region

        @expanded_meshed_region.setter
        def expanded_meshed_region(self, expanded_meshed_region):
            self._expanded_meshed_region.connect(expanded_meshed_region)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)

        @property
        def sectors_to_expand(self):
            """sectors to expand (start at 0), for multistage: use scopings container with 'stage' label."""
            return self._sectors_to_expand

        @sectors_to_expand.setter
        def sectors_to_expand(self, sectors_to_expand):
            self._sectors_to_expand.connect(sectors_to_expand)

        @property
        def phi(self):
            """phi angle (default value 0.0)"""
            return self._phi

        @phi.setter
        def phi(self, phi):
            self._phi.connect(phi)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in')), (1, OutputSpec(name='expanded_meshed_region', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            self._expanded_meshed_region = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container

        @property
        def expanded_meshed_region(self):
            """"""
            return self._expanded_meshed_region


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, sector_mesh=None, requested_location=None, read_cyclic=None, expanded_meshed_region=None, cyclic_support=None, sectors_to_expand=None, phi=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::S_cyclic"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container

    @property
    def expanded_meshed_region(self):
        """"""
        return self.outputs._expanded_meshed_region



class CyclicVolume(dpf.Operator):
    """DPF "mapdl::rst::ENG_VOL_cyclic" Operator

    Read mapdl::rst::ENG_VOL from an rst file.

    Available inputs:
     -   ``requested_location`` : str, optional
         Location needed in output

     -   ``read_cyclic`` : N14Dataprocessing14Ecyclicreadinge, int, optional
         If 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2
         cyclic expansion is done (default is 1)

     -   ``expanded_meshed_region`` : MeshedRegion, optional
         Mesh expanded.

     -   ``cyclic_support`` : CyclicSupport, optional

     -   ``sectors_to_expand`` : list, Scoping, ScopingsContainer, optional
         Sectors to expand (start at 0), for multistage: use scopings container
         with 'stage' label.

     -   ``phi`` : float, optional
         Phi angle (default value 0.0)

     -   ``time_scoping`` : Scoping, list, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, list, optional

     -   ``fields_container`` : FieldsContainer, optional
         Fieldscontainer already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, Stream, optional
         Streams containing the result file.

     -   ``data_sources`` : DataSources
         Data sources containing the result file.

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``sector_mesh`` : MeshedRegion, optional
         Mesh of the base sector (can be a skin).


    Available outputs:
     -   fields_container
     -   expanded_meshed_region


    Parameters
    ----------
    data_sources : DataSources
        Data sources containing the result file.

    time_scoping : Scoping or list, optional


    mesh_scoping : scopings_container or Scoping or list, optional


    fields_container : FieldsContainer, optional
        Fieldscontainer already allocated modified inplace

    streams_container : streams_container or stream, optional
        Streams containing the result file.

    bool_rotate_to_global : bool, optional
        If true the field is roated to global coordinate system
        (default true)

    sector_mesh : MeshedRegion, optional
        Mesh of the base sector (can be a skin).

    requested_location : str, optional
        Location needed in output

    read_cyclic : N14dataProcessing14ECyclicReadingE or int, optional
        If 0 cyclic symmetry is ignored, if 1 cyclic sector is read,
        if 2 cyclic expansion is done (default is 1)

    expanded_meshed_region : MeshedRegion, optional
        Mesh expanded.

    cyclic_support : cyclic_support, optional


    sectors_to_expand : list or Scoping or scopings_container, optional
        Sectors to expand (start at 0), for multistage: use scopings
        container with 'stage' label.

    phi : float, optional
        Phi angle (default value 0.0)

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CyclicVolume(my_data_sources,
                                        my_time_scoping, # optional
                                        my_mesh_scoping, # optional
                                        my_fields_container, # optional
                                        my_streams_container, # optional
                                        my_bool_rotate_to_global, # optional
                                        my_sector_mesh, # optional
                                        my_requested_location, # optional
                                        my_read_cyclic, # optional
                                        my_expanded_meshed_region, # optional
                                        my_cyclic_support, # optional
                                        my_sectors_to_expand, # optional
                                        my_phi)  # optional
    >>> my_fields_container = op.fields_container
    >>> my_expanded_meshed_region = op.expanded_meshed_region

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CyclicVolume()
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.read_cyclic.connect(my_read_cyclic)  # optional
    >>> op.inputs.expanded_meshed_region.connect(my_expanded_meshed_region)  # optional
    >>> op.inputs.cyclic_support.connect(my_cyclic_support)  # optional
    >>> op.inputs.sectors_to_expand.connect(my_sectors_to_expand)  # optional
    >>> op.inputs.phi.connect(my_phi)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.sector_mesh.connect(my_sector_mesh)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    >>> my_expanded_meshed_region = op.outputs.expanded_meshed_region()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping', 'vector<int32>'])), (2, InputSpec(document='FieldsContainer already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='Streams containing the result file.', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container', 'stream'])), (4, InputSpec(document='data sources containing the result file.', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b'])), (7, InputSpec(document='mesh of the base sector (can be a skin).', ellipsis=False, name='sector_mesh', optional=True, type_names=['abstract_meshed_region'])), (9, InputSpec(document='location needed in output', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (14, InputSpec(document='if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)', ellipsis=False, name='read_cyclic', optional=True, type_names=['N14dataProcessing14ECyclicReadingE', 'int32'])), (15, InputSpec(document='mesh expanded.', ellipsis=False, name='expanded_meshed_region', optional=True, type_names=['abstract_meshed_region'])), (16, InputSpec(document='', ellipsis=False, name='cyclic_support', optional=True, type_names=['cyclic_support'])), (18, InputSpec(document="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label.", ellipsis=False, name='sectors_to_expand', optional=True, type_names=['vector<int32>', 'scoping', 'scopings_container'])), (19, InputSpec(document='phi angle (default value 0.0)', ellipsis=False, name='phi', optional=True, type_names=['double']))])
        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._sector_mesh = None
            self._requested_location = None
            self._read_cyclic = None
            self._expanded_meshed_region = None
            self._cyclic_support = None
            self._sectors_to_expand = None
            self._phi = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """FieldsContainer already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """Streams containing the result file."""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """data sources containing the result file."""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def sector_mesh(self):
            """mesh of the base sector (can be a skin)."""
            return self._sector_mesh

        @sector_mesh.setter
        def sector_mesh(self, sector_mesh):
            self._sector_mesh.connect(sector_mesh)

        @property
        def requested_location(self):
            """location needed in output"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def read_cyclic(self):
            """if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)"""
            return self._read_cyclic

        @read_cyclic.setter
        def read_cyclic(self, read_cyclic):
            self._read_cyclic.connect(read_cyclic)

        @property
        def expanded_meshed_region(self):
            """mesh expanded."""
            return self._expanded_meshed_region

        @expanded_meshed_region.setter
        def expanded_meshed_region(self, expanded_meshed_region):
            self._expanded_meshed_region.connect(expanded_meshed_region)

        @property
        def cyclic_support(self):
            return self._cyclic_support

        @cyclic_support.setter
        def cyclic_support(self, cyclic_support):
            self._cyclic_support.connect(cyclic_support)

        @property
        def sectors_to_expand(self):
            """sectors to expand (start at 0), for multistage: use scopings container with 'stage' label."""
            return self._sectors_to_expand

        @sectors_to_expand.setter
        def sectors_to_expand(self, sectors_to_expand):
            self._sectors_to_expand.connect(sectors_to_expand)

        @property
        def phi(self):
            """phi angle (default value 0.0)"""
            return self._phi

        @phi.setter
        def phi(self, phi):
            self._phi.connect(phi)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='FieldsContainer filled in')), (1, OutputSpec(name='expanded_meshed_region', type_names=['abstract_meshed_region'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            self._expanded_meshed_region = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """FieldsContainer filled in"""
            return self._fields_container

        @property
        def expanded_meshed_region(self):
            """"""
            return self._expanded_meshed_region


    def __init__(self, data_sources, time_scoping=None, mesh_scoping=None, fields_container=None, streams_container=None, bool_rotate_to_global=None, sector_mesh=None, requested_location=None, read_cyclic=None, expanded_meshed_region=None, cyclic_support=None, sectors_to_expand=None, phi=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapdl::rst::ENG_VOL_cyclic"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """FieldsContainer filled in"""
        return self.outputs._fields_container

    @property
    def expanded_meshed_region(self):
        """"""
        return self.outputs._expanded_meshed_region



