"""Autogenerated DPF operator classes.

Created on 01/04/2021, 09:21:00
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class Mass(dpf.Operator):
    """DPF "topology::mass" Operator

    Compute the mass of a set of elements.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``mesh_scoping`` : Scoping, optional
         Mesh scoping, if not set, all the elements of the mesh are considered.

     -   ``field`` : Field, optional
         Elemental or nodal ponderation used in computation.


    Available outputs:
     -   field


    Parameters
    ----------


    mesh : MeshedRegion, optional


    mesh_scoping : Scoping, optional
        Mesh scoping, if not set, all the elements of the mesh are
        considered.

    field : Field, optional
        Elemental or nodal ponderation used in computation.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Mass(my_mesh,
                                my_mesh, # optional
                                my_mesh_scoping, # optional
                                my_field)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Mass()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.field.connect(my_field)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (1, InputSpec(document='Mesh scoping, if not set, all the elements of the mesh are considered.', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document='Elemental or nodal ponderation used in computation.', ellipsis=False, name='field', optional=True, type_names=['field']))])
        def __init__(self, oper):
            self._mesh = None
            self._mesh_scoping = None
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def mesh_scoping(self):
            """Mesh scoping, if not set, all the elements of the mesh are considered."""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def field(self):
            """Elemental or nodal ponderation used in computation."""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, , mesh=None, mesh_scoping=None, field=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "topology::mass"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Normals(dpf.Operator):
    """DPF "normals_provider" Operator

    compute the normals at the given nodes or element scoping based on
    the given mesh (first version, the element normal is only handled
    on the shell elements)

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``mesh_scoping`` : Scoping, optional

     -   ``field`` : Field, optional


    Available outputs:
     -   field


    Parameters
    ----------


    mesh : MeshedRegion, optional


    mesh_scoping : Scoping, optional


    field : Field, optional


    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Normals(my_mesh,
                                   my_mesh, # optional
                                   my_mesh_scoping, # optional
                                   my_field)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Normals()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.field.connect(my_field)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (3, InputSpec(document='', ellipsis=False, name='field', optional=True, type_names=['field']))])
        def __init__(self, oper):
            self._mesh = None
            self._mesh_scoping = None
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, , mesh=None, mesh_scoping=None, field=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "normals_provider"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class IntegrateOverElements(dpf.Operator):
    """DPF "element::integrate" Operator

    Integration of an input field over mesh.

    Available inputs:
     -   ``field`` : Field

     -   ``scoping`` : Scoping, optional
         Integrate the input field over a specific scoping.

     -   ``mesh`` : MeshedRegion, optional
         Mesh to integrate on, if not provided the one from input field is
         provided.


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field


    scoping : Scoping, optional
        Integrate the input field over a specific scoping.

    mesh : MeshedRegion, optional
        Mesh to integrate on, if not provided the one from input field
        is provided.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.IntegrateOverElements(my_field,
                                                 my_scoping, # optional
                                                 my_mesh)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.IntegrateOverElements()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field'])), (1, InputSpec(document='Integrate the input field over a specific scoping.', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document='Mesh to integrate on, if not provided the one from input field is provided.', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._field = None
            self._scoping = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def scoping(self):
            """Integrate the input field over a specific scoping."""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def mesh(self):
            """Mesh to integrate on, if not provided the one from input field is provided."""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, scoping=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "element::integrate"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class CenterOfGravity(dpf.Operator):
    """DPF "topology::center_of_gravity" Operator

    Compute the center of gravity of a set of elements

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``mesh_scoping`` : Scoping, optional
         Mesh scoping, if not set, all the elements of the mesh are considered.

     -   ``field`` : Field, optional
         Elemental or nodal ponderation used in computation.


    Available outputs:
     -   field
     -   mesh


    Parameters
    ----------


    mesh : MeshedRegion, optional


    mesh_scoping : Scoping, optional
        Mesh scoping, if not set, all the elements of the mesh are
        considered.

    field : Field, optional
        Elemental or nodal ponderation used in computation.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.CenterOfGravity(my_mesh,
                                           my_mesh, # optional
                                           my_mesh_scoping, # optional
                                           my_field)  # optional
    >>> my_field = op.field
    >>> my_mesh = op.mesh

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.CenterOfGravity()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.field.connect(my_field)  # optional
    >>> my_field = op.outputs.field()
    >>> my_mesh = op.outputs.mesh()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (1, InputSpec(document='Mesh scoping, if not set, all the elements of the mesh are considered.', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document='Elemental or nodal ponderation used in computation.', ellipsis=False, name='field', optional=True, type_names=['field']))])
        def __init__(self, oper):
            self._mesh = None
            self._mesh_scoping = None
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def mesh_scoping(self):
            """Mesh scoping, if not set, all the elements of the mesh are considered."""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def field(self):
            """Elemental or nodal ponderation used in computation."""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document='')), (1, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document='Center of gravity as a mesh'))])
        def __init__(self, oper):
            self._field = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field

        @property
        def mesh(self):
            """Center of gravity as a mesh"""
            return self._mesh


    def __init__(self, , mesh=None, mesh_scoping=None, field=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "topology::center_of_gravity"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field

    @property
    def mesh(self):
        """Center of gravity as a mesh"""
        return self.outputs._mesh



class MomentOfInertia(dpf.Operator):
    """DPF "topology::moment_of_inertia" Operator

    Compute the inertia tensor of a set of elements.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional

     -   ``mesh_scoping`` : Scoping, optional
         Mesh scoping, if not set, all the elements of the mesh are considered.

     -   ``field`` : Field, optional
         Elemental or nodal ponderation used in computation.

     -   ``boolean`` : B, optional
         Default true, compute inertia tensor at center of gravity.


    Available outputs:
     -   field


    Parameters
    ----------


    mesh : MeshedRegion, optional


    mesh_scoping : Scoping, optional
        Mesh scoping, if not set, all the elements of the mesh are
        considered.

    field : Field, optional
        Elemental or nodal ponderation used in computation.

    boolean : bool, optional
        Default true, compute inertia tensor at center of gravity.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.MomentOfInertia(my_mesh,
                                           my_mesh, # optional
                                           my_mesh_scoping, # optional
                                           my_field, # optional
                                           my_boolean)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.MomentOfInertia()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.field.connect(my_field)  # optional
    >>> op.inputs.boolean.connect(my_boolean)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (1, InputSpec(document='Mesh scoping, if not set, all the elements of the mesh are considered.', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document='Elemental or nodal ponderation used in computation.', ellipsis=False, name='field', optional=True, type_names=['field'])), (3, InputSpec(document='default true, compute inertia tensor at center of gravity.', ellipsis=False, name='boolean', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._mesh = None
            self._mesh_scoping = None
            self._field = None
            self._boolean = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def mesh_scoping(self):
            """Mesh scoping, if not set, all the elements of the mesh are considered."""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def field(self):
            """Elemental or nodal ponderation used in computation."""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def boolean(self):
            """default true, compute inertia tensor at center of gravity."""
            return self._boolean

        @boolean.setter
        def boolean(self, boolean):
            self._boolean.connect(boolean)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, , mesh=None, mesh_scoping=None, field=None, boolean=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "topology::moment_of_inertia"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ToCylindricalCs(dpf.Operator):
    """DPF "transform_cylindricalCS" Operator

    Transform a field (not defined with a cynlindrical coordinate
    system) to its corresponding values into the specified cylindrical
    coordinate system (corresponding to the field position). If no
    coordinate system is set in the coordinate_system pin, field is
    rotated on each node following the local polar coordinate system.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``coordinate_system`` : Field, optional
         3-3 rotation matrix and origin coordinates must be set here to define
         a coordinate system.


    Available outputs:
     -   fields_container


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    coordinate_system : Field, optional
        3-3 rotation matrix and origin coordinates must be set here to
        define a coordinate system.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ToCylindricalCs(my_field,
                                           my_coordinate_system)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ToCylindricalCs()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.coordinate_system.connect(my_coordinate_system)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='3-3 rotation matrix and origin coordinates must be set here to define a coordinate system.', ellipsis=False, name='coordinate_system', optional=True, type_names=['field']))])
        def __init__(self, oper):
            self._field = None
            self._coordinate_system = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def coordinate_system(self):
            """3-3 rotation matrix and origin coordinates must be set here to define a coordinate system."""
            return self._coordinate_system

        @coordinate_system.setter
        def coordinate_system(self, coordinate_system):
            self._coordinate_system.connect(coordinate_system)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, field, coordinate_system=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "transform_cylindricalCS"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ToCylindricalCsFc(dpf.Operator):
    """DPF "transform_cylindrical_cs_fc" Operator

    Transform all the fields of a fields container (not defined with a
    cynlindrical coordinate system) to its corresponding values into
    the specified cylindrical coordinate system (corresponding to the
    field position). If no coordinate system is set in the
    coordinate_system pin, field is rotated on each node following the
    local polar coordinate system.

    Available inputs:
     -   ``field`` : Field, FieldsContainer

     -   ``coordinate_system`` : Field, optional
         3-3 rotation matrix and origin coordinates must be set here to define
         a coordinate system.


    Available outputs:
     -   fields_container


    Parameters
    ----------
    field : Field or FieldsContainer


    coordinate_system : Field, optional
        3-3 rotation matrix and origin coordinates must be set here to
        define a coordinate system.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ToCylindricalCsFc(my_field,
                                             my_coordinate_system)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ToCylindricalCsFc()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.coordinate_system.connect(my_coordinate_system)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='3-3 rotation matrix and origin coordinates must be set here to define a coordinate system.', ellipsis=False, name='coordinate_system', optional=True, type_names=['field']))])
        def __init__(self, oper):
            self._field = None
            self._coordinate_system = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def coordinate_system(self):
            """3-3 rotation matrix and origin coordinates must be set here to define a coordinate system."""
            return self._coordinate_system

        @coordinate_system.setter
        def coordinate_system(self, coordinate_system):
            self._coordinate_system.connect(coordinate_system)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, field, coordinate_system=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "transform_cylindrical_cs_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementsVolumesOverTime(dpf.Operator):
    """DPF "volumes_provider" Operator

    Calculation of the volume of each element over time of a mesh for
    each specified time step.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional
         Mesh must be defined if the displacement field's container does not
         contain it, or if there is no displacement.

     -   ``scoping`` : Scoping, optional

     -   ``displacement`` : FieldsContainer, optional
         Displacement field's container. must contain the mesh if mesh not
         specified in input.


    Available outputs:
     -   fields_container


    Parameters
    ----------


    scoping : Scoping, optional


    displacement : FieldsContainer, optional
        Displacement field's container. must contain the mesh if mesh
        not specified in input.

    mesh : MeshedRegion, optional
        Mesh must be defined if the displacement field's container
        does not contain it, or if there is no displacement.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementsVolumesOverTime(my_scoping,
                                                   my_scoping, # optional
                                                   my_displacement, # optional
                                                   my_mesh)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementsVolumesOverTime()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> op.inputs.displacement.connect(my_displacement)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(1, InputSpec(document='', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document="Displacement field's container. Must contain the mesh if mesh not specified in input.", ellipsis=False, name='displacement', optional=True, type_names=['fields_container'])), (7, InputSpec(document="Mesh must be defined if the displacement field's container does not contain it, or if there is no displacement.", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._scoping = None
            self._displacement = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def scoping(self):
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def displacement(self):
            """Displacement field's container. Must contain the mesh if mesh not specified in input."""
            return self._displacement

        @displacement.setter
        def displacement(self, displacement):
            self._displacement.connect(displacement)

        @property
        def mesh(self):
            """Mesh must be defined if the displacement field's container does not contain it, or if there is no displacement."""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, , scoping=None, displacement=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "volumes_provider"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ElementsFacetsSurfacesOverTime(dpf.Operator):
    """DPF "surfaces_provider" Operator

    Calculation of the surface of each element's facet over time of a
    mesh for each specified time step. Moreover, it gives as output a
    new mesh made with only surface elements.

    Available inputs:
     -   ``mesh`` : MeshedRegion, optional
         Mesh must be defined if the displacement field's container does not
         contain it, or if there is no displacement.

     -   ``scoping`` : Scoping, optional

     -   ``displacement`` : FieldsContainer, optional
         Displacement field's container.


    Available outputs:
     -   mesh
     -   fields_container


    Parameters
    ----------


    scoping : Scoping, optional


    displacement : FieldsContainer, optional
        Displacement field's container.

    mesh : MeshedRegion, optional
        Mesh must be defined if the displacement field's container
        does not contain it, or if there is no displacement.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementsFacetsSurfacesOverTime(my_scoping,
                                                          my_scoping, # optional
                                                          my_displacement, # optional
                                                          my_mesh)  # optional
    >>> my_mesh = op.mesh
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementsFacetsSurfacesOverTime()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> op.inputs.displacement.connect(my_displacement)  # optional
    >>> my_mesh = op.outputs.mesh()
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(1, InputSpec(document='', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document="Displacement field's container.", ellipsis=False, name='displacement', optional=True, type_names=['fields_container'])), (7, InputSpec(document="Mesh must be defined if the displacement field's container does not contain it, or if there is no displacement.", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._scoping = None
            self._displacement = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def scoping(self):
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def displacement(self):
            """Displacement field's container."""
            return self._displacement

        @displacement.setter
        def displacement(self, displacement):
            self._displacement.connect(displacement)

        @property
        def mesh(self):
            """Mesh must be defined if the displacement field's container does not contain it, or if there is no displacement."""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document='Surfaces field.')), (1, OutputSpec(name='mesh', type_names=['abstract_meshed_region'], document='Mesh made of surface elements only.'))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """Surfaces field."""
            return self._fields_container

        @property
        def mesh(self):
            """Mesh made of surface elements only."""
            return self._mesh


    def __init__(self, , scoping=None, displacement=None, mesh=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "surfaces_provider"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """Surfaces field."""
        return self.outputs._fields_container

    @property
    def mesh(self):
        """Mesh made of surface elements only."""
        return self.outputs._mesh



class ElementNodalContribution(dpf.Operator):
    """DPF "element::nodal_contribution" Operator

    Compute the fraction of volume attributed to each node of each
    element.

    Available inputs:
     -   ``volume_fraction`` : B, optional
         If true, returns influence volume, if false, return influence volume
         fraction (i.e. integrated value of shape function for each node).

     -   ``mesh`` : MeshedRegion

     -   ``scoping`` : Scoping, optional
         Integrate the input field over a specific scoping.


    Available outputs:
     -   field


    Parameters
    ----------
    mesh : MeshedRegion


    scoping : Scoping, optional
        Integrate the input field over a specific scoping.

    volume_fraction : bool, optional
        If true, returns influence volume, if false, return influence
        volume fraction (i.e. integrated value of shape function for
        each node).

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ElementNodalContribution(my_mesh,
                                                    my_scoping, # optional
                                                    my_volume_fraction)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ElementNodalContribution()
    >>> op.inputs.volume_fraction.connect(my_volume_fraction)  # optional
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (1, InputSpec(document='Integrate the input field over a specific scoping.', ellipsis=False, name='scoping', optional=True, type_names=['scoping'])), (2, InputSpec(document='if true, returns influence volume, if false, return influence volume fraction (i.e. integrated value of shape function for each node).', ellipsis=False, name='volume_fraction', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._mesh = None
            self._scoping = None
            self._volume_fraction = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def scoping(self):
            """Integrate the input field over a specific scoping."""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def volume_fraction(self):
            """if true, returns influence volume, if false, return influence volume fraction (i.e. integrated value of shape function for each node)."""
            return self._volume_fraction

        @volume_fraction.setter
        def volume_fraction(self, volume_fraction):
            self._volume_fraction.connect(volume_fraction)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, mesh, scoping=None, volume_fraction=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "element::nodal_contribution"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



