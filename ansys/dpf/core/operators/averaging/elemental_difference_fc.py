"""Autogenerated DPF operator classes.

Created on 10/06/2021, 13:12:29
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class ElementalDifferenceFc(dpf.Operator):
    """DPF "elemental_difference_fc" Operator

    Transform ElementalNodal or Nodal field into Elemental field. Each
    elemental value is the maximum difference between the unaveraged
    or averaged (depending on the input fields) computed result for
    all nodes in this element. Result is computed on a given element
    scoping. If the input fields are mixed shell/solid and the shells
    layers are not asked to be collapsed, then the fields are splitted
    by element shape and the output fields container has elshape
    label.

    Available inputs:
     -   mesh : MeshedRegion, MeshesContainer, optional
         The mesh region in this pin is used to perform the averaging,
         if there is no field's support it is used
     -   fields_container : FieldsContainer
     -   collapse_shell_layers : bool, optional
         The max elemental difference is taken through the different
         shell layers if true (default is false)
     -   scoping : Scoping, ScopingsContainer, optional
         Average only on these elements, if it is scoping container,
         the label must correspond to the one of the fields container
    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh : MeshedRegion or meshes_container, optional
        The mesh region in this pin is used to perform the averaging,
        if there is no field's support it is used

    scoping : Scoping or scopings_container, optional
        Average only on these elements, if it is scoping container,
        the label must correspond to the one of the fields container

    collapse_shell_layers : bool, optional
        The max elemental difference is taken through the different
        shell layers if true (default is false)

    Examples
    --------
    >>> op = dpf.operators.ElementalDifferenceFc()
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.collapse_shell_layers.connect(my_collapse_shell_layers)  # optional
    >>> op.inputs.scoping.connect(my_scoping)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """  # noqa: E501

    class _Inputs(dpf.inputs.Inputs):

        # fmt: off
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used", ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region', 'meshes_container'])), (3, InputSpec(document='average only on these elements, if it is scoping container, the label must correspond to the one of the fields container', ellipsis=False, name='scoping', optional=True, type_names=['scoping', 'scopings_container'])), (10, InputSpec(document='the max elemental difference is taken through the different shell layers if true (default is false)', ellipsis=False, name='collapse_shell_layers', optional=True, type_names=['bool']))]) # noqa: E501
        # fmt: on

        def __init__(self, oper):
            self._fields_container = None
            self._mesh = None
            self._scoping = None
            self._collapse_shell_layers = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh(self):
            """the mesh region in this pin is used to perform the
            averaging, if there is no field's support it is used"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def scoping(self):
            """average only on these elements, if it is scoping
            container, the label must correspond to the one of the
            fields container"""
            return self._scoping

        @scoping.setter
        def scoping(self, scoping):
            self._scoping.connect(scoping)

        @property
        def collapse_shell_layers(self):
            """the max elemental difference is taken through the
            different shell layers if true (default is false)"""
            return self._collapse_shell_layers

        @collapse_shell_layers.setter
        def collapse_shell_layers(self, collapse_shell_layers):
            self._collapse_shell_layers.connect(collapse_shell_layers)

    class _Outputs(dpf.outputs.Outputs):

        # fmt: off
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))]) # noqa: E501
        # fmt: on

        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

    def __init__(
        self, fields_container, mesh=None, scoping=None, collapse_shell_layers=None
    ):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "elemental_difference_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        return self.outputs._fields_container
