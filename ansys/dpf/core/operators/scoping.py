"""Autogenerated DPF operator classes.

Created on 01/15/2021, 00:24:02
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class Intersect(dpf.Operator):
    """DPF "scoping::intersect" Operator

    Intersect 2 scopings and return the intersection and the
    difference between the intersection and the first scoping.

    Available inputs:
     -   ``scopingB`` : Scoping

     -   ``scopingA`` : Scoping


    Available outputs:
     -   intersection
     -   scopingA_min_intersection


    Parameters
    ----------
    scopingA : Scoping


    scopingB : Scoping




    Examples
    --------
    >>> op = dpf.operators.Intersect()
    >>> op.inputs.scopingB.connect(my_scopingB)
    >>> op.inputs.scopingA.connect(my_scopingA)
    >>> my_intersection = op.outputs.intersection()
    >>> my_scopingA_min_intersection = op.outputs.scopingA_min_intersection()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='scopingA', optional=False, type_names=['scoping'])), (1, InputSpec(document='', ellipsis=False, name='scopingB', optional=False, type_names=['scoping']))])
        def __init__(self, oper):
            self._scopingA = None
            self._scopingB = None
            super().__init__(self._spec, oper)

        @property
        def scopingA(self):
            return self._scopingA

        @scopingA.setter
        def scopingA(self, scopingA):
            self._scopingA.connect(scopingA)

        @property
        def scopingB(self):
            return self._scopingB

        @scopingB.setter
        def scopingB(self, scopingB):
            self._scopingB.connect(scopingB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='intersection', type_names=['scoping'], document='')), (1, OutputSpec(name='scopingA_min_intersection', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._intersection = None
            self._scopingA_min_intersection = None
            super().__init__(self._spec, oper)

        @property
        def intersection(self):
            """"""
            return self._intersection

        @property
        def scopingA_min_intersection(self):
            """"""
            return self._scopingA_min_intersection


    def __init__(self, scopingA, scopingB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scoping::intersect"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def intersection(self):
        """"""
        return self.outputs._intersection

    @property
    def scopingA_min_intersection(self):
        """"""
        return self.outputs._scopingA_min_intersection



class ElementalFromMesh(dpf.Operator):
    """DPF "GetElementScopingFromMesh" Operator

    Get the elements ids scoping of a given input mesh.

    Available inputs:
     -   ``mesh`` : MeshedRegion


    Available outputs:
     -   mesh_scoping


    Parameters
    ----------
    mesh : MeshedRegion




    Examples
    --------
    >>> op = dpf.operators.ElementalFromMesh()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> my_mesh_scoping = op.outputs.mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_scoping', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """"""
            return self._mesh_scoping


    def __init__(self, mesh):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "GetElementScopingFromMesh"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_scoping(self):
        """"""
        return self.outputs._mesh_scoping



class OnProperty(dpf.Operator):
    """DPF "scoping_provider_by_prop" Operator

    Provides a scoping at a given location based on a given property
    name and a property number.

    Available inputs:
     -   ``property_id`` : int

     -   ``property_name`` : str
         Ex: "mapdl_element_type", "apdl_type_index", "mapdl_type_id",
         "material", "apdl_section_id", "apdl_real_id", "shell_axi",
         "volume_axi"...

     -   ``data_sources`` : DataSources

     -   ``streams_container`` : StreamsContainer, optional

     -   ``requested_location`` : str
         Nodal or elemental location are expected

     -   ``inclusive`` : int, optional
         If element scoping is requested on a nodal named selection, if
         inclusive == 1 then all the elements adjacent to the nodes ids in
         input are added, if inclusive == 0, only the elements which have all
         their nodes in the scoping are included


    Available outputs:
     -   mesh_scoping


    Parameters
    ----------
    requested_location : str
        Nodal or elemental location are expected

    property_name : str
        Ex: 'mapdl_element_type', 'apdl_type_index', 'mapdl_type_id',
        'material', 'apdl_section_id', 'apdl_real_id', 'shell_axi',
        'volume_axi'...

    property_id : int


    data_sources : DataSources


    streams_container : streams_container, optional


    inclusive : int, optional
        If element scoping is requested on a nodal named selection, if
        inclusive == 1 then all the elements adjacent to the nodes ids
        in input are added, if inclusive == 0, only the elements which
        have all their nodes in the scoping are included

    Examples
    --------
    >>> op = dpf.operators.OnProperty()
    >>> op.inputs.property_id.connect(my_property_id)
    >>> op.inputs.property_name.connect(my_property_name)
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)
    >>> op.inputs.inclusive.connect(my_inclusive)  # optional
    >>> my_mesh_scoping = op.outputs.mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='Nodal or Elemental location are expected', ellipsis=False, name='requested_location', optional=False, type_names=['string'])), (1, InputSpec(document="ex: 'mapdl_element_type', 'apdl_type_index', 'mapdl_type_id', 'material', 'apdl_section_id', 'apdl_real_id', 'shell_axi', 'volume_axi'...", ellipsis=False, name='property_name', optional=False, type_names=['string'])), (2, InputSpec(document='', ellipsis=False, name='property_id', optional=False, type_names=['int32'])), (3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='If element scoping is requested on a nodal named selection, if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included', ellipsis=False, name='inclusive', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._requested_location = None
            self._property_name = None
            self._property_id = None
            self._streams_container = None
            self._data_sources = None
            self._inclusive = None
            super().__init__(self._spec, oper)

        @property
        def requested_location(self):
            """Nodal or Elemental location are expected"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def property_name(self):
            """ex: 'mapdl_element_type', 'apdl_type_index', 'mapdl_type_id', 'material', 'apdl_section_id', 'apdl_real_id', 'shell_axi', 'volume_axi'..."""
            return self._property_name

        @property_name.setter
        def property_name(self, property_name):
            self._property_name.connect(property_name)

        @property
        def property_id(self):
            return self._property_id

        @property_id.setter
        def property_id(self, property_id):
            self._property_id.connect(property_id)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def inclusive(self):
            """If element scoping is requested on a nodal named selection, if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included"""
            return self._inclusive

        @inclusive.setter
        def inclusive(self, inclusive):
            self._inclusive.connect(inclusive)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_scoping', type_names=['scoping'], document='Scoping'))])
        def __init__(self, oper):
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """Scoping"""
            return self._mesh_scoping


    def __init__(self, requested_location, property_name, property_id, data_sources, streams_container=None, inclusive=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scoping_provider_by_prop"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_scoping(self):
        """Scoping"""
        return self.outputs._mesh_scoping



class Transpose(dpf.Operator):
    """DPF "transpose_scoping" Operator

    Transposes the input scoping or scopings container (Elemental -->
    Nodal, or Nodal ---> Elemental), based on the input mesh region.

    Available inputs:
     -   ``inclusive`` : int, optional
         If inclusive == 1 then all the elements adjacent to the nodes ids in
         input are added, if inclusive == 0, only the elements which have all
         their nodes in the scoping are included

     -   ``meshed_region`` : MeshedRegion

     -   ``mesh_scoping`` : Scoping, ScopingsContainer
         Scoping or scopings container (the input type is the output type)


    Available outputs:
     -   mesh_scoping


    Parameters
    ----------
    mesh_scoping : Scoping or scopings_container
        Scoping or scopings container (the input type is the output
        type)

    meshed_region : meshed_region


    inclusive : int, optional
        If inclusive == 1 then all the elements adjacent to the nodes
        ids in input are added, if inclusive == 0, only the elements
        which have all their nodes in the scoping are included

    Examples
    --------
    >>> op = dpf.operators.Transpose()
    >>> op.inputs.inclusive.connect(my_inclusive)  # optional
    >>> op.inputs.meshed_region.connect(my_meshed_region)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)
    >>> my_mesh_scoping = op.outputs.mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='Scoping or scopings container (the input type is the output type)', ellipsis=False, name='mesh_scoping', optional=False, type_names=['scoping', 'scopings_container'])), (1, InputSpec(document='', ellipsis=False, name='meshed_region', optional=False, type_names=['meshed_region'])), (2, InputSpec(document='if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included', ellipsis=False, name='inclusive', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._mesh_scoping = None
            self._meshed_region = None
            self._inclusive = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """Scoping or scopings container (the input type is the output type)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def meshed_region(self):
            return self._meshed_region

        @meshed_region.setter
        def meshed_region(self, meshed_region):
            self._meshed_region.connect(meshed_region)

        @property
        def inclusive(self):
            """if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included"""
            return self._inclusive

        @inclusive.setter
        def inclusive(self, inclusive):
            self._inclusive.connect(inclusive)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_scoping', type_names=['scoping'], document='Scoping or scopings container (the input type is the output type)'))])
        def __init__(self, oper):
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """Scoping or scopings container (the input type is the output type)"""
            return self._mesh_scoping


    def __init__(self, mesh_scoping, meshed_region, inclusive=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "transpose_scoping"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_scoping(self):
        """Scoping or scopings container (the input type is the output type)"""
        return self.outputs._mesh_scoping



class SplittedOnPropertyType(dpf.Operator):
    """DPF "scoping::by_property" Operator

    Splits a given scoping or the mesh scoping (nodal or elemental) on
    given properties (elshape and/or material) and returns a scopings
    container with those splitted scopings.

    Available inputs:
     -   ``requested_location`` : str
         Location (default is elemental)

     -   ``label`` : str, Vector<String>, optional
         Properties to apply the filtering 'mat' and/or 'elshape' (default is
         'elshape)
         is ellipsis

     -   ``mesh`` : MeshedRegion
         Mesh region

     -   ``mesh_scoping`` : Scoping, optional
         Scoping


    Available outputs:
     -   mesh_scoping


    Parameters
    ----------
    mesh : MeshedRegion
        Mesh region

    requested_location : str
        Location (default is elemental)

    mesh_scoping : Scoping, optional
        Scoping

    label : str or vector<string>, optional
        Properties to apply the filtering 'mat' and/or 'elshape'
        (default is 'elshape)

    Examples
    --------
    >>> op = dpf.operators.SplittedOnPropertyType()
    >>> op.inputs.requested_location.connect(my_requested_location)
    >>> op.inputs.label.connect(my_label)  # optional
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_mesh_scoping = op.outputs.mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(1, InputSpec(document='Scoping', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scoping'])), (7, InputSpec(document='mesh region', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (9, InputSpec(document='location (default is elemental)', ellipsis=False, name='requested_location', optional=False, type_names=['string'])), (13, InputSpec(document="properties to apply the filtering 'mat' and/or 'elshape' (default is 'elshape)", ellipsis=True, name='label', optional=True, type_names=['string', 'vector<string>']))])
        def __init__(self, oper):
            self._mesh_scoping = None
            self._mesh = None
            self._requested_location = None
            self._label = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """Scoping"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def mesh(self):
            """mesh region"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """location (default is elemental)"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def label(self):
            """properties to apply the filtering 'mat' and/or 'elshape' (default is 'elshape)"""
            return self._label

        @label.setter
        def label(self, label):
            self._label.connect(label)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_scoping', type_names=['scopings_container'], document='Scoping'))])
        def __init__(self, oper):
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """Scoping"""
            return self._mesh_scoping


    def __init__(self, mesh, requested_location, mesh_scoping=None, label=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scoping::by_property"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_scoping(self):
        """Scoping"""
        return self.outputs._mesh_scoping



class Rescope(dpf.Operator):
    """DPF "Rescope" Operator

    Rescope a field on the given scoping. If an id does not exists in
    the original field, default value (in 2) is used if defined.

    Available inputs:
     -   ``mesh_scoping`` : Scoping

     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    mesh_scoping : Scoping




    Examples
    --------
    >>> op = dpf.operators.Rescope()
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='mesh_scoping', optional=False, type_names=['scoping']))])
        def __init__(self, oper):
            self._fields_container = None
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, mesh_scoping):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "Rescope"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class OnNamedSelection(dpf.Operator):
    """DPF "scoping_provider_by_ns" Operator

    provides a scoping at a given location based on a given named
    selection

    Available inputs:
     -   ``streams_container`` : StreamsContainer, optional

     -   ``int_inclusive`` : int, optional
         If element scoping is requested on a nodal named selection, if
         inclusive == 1 then add all the elements adjacent to the nodes.if
         inclusive == 0, only the elements which have all their nodes in the
         named selection are included

     -   ``data_sources`` : DataSources

     -   ``named_selection_name`` : str
         The string is expected to be in upper case

     -   ``requested_location`` : str


    Available outputs:
     -   mesh_scoping


    Parameters
    ----------
    requested_location : str


    named_selection_name : str
        The string is expected to be in upper case

    data_sources : DataSources


    int_inclusive : int, optional
        If element scoping is requested on a nodal named selection, if
        inclusive == 1 then add all the elements adjacent to the
        nodes.if inclusive == 0, only the elements which have all
        their nodes in the named selection are included

    streams_container : streams_container, optional


    Examples
    --------
    >>> op = dpf.operators.OnNamedSelection()
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.int_inclusive.connect(my_int_inclusive)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.named_selection_name.connect(my_named_selection_name)
    >>> op.inputs.requested_location.connect(my_requested_location)
    >>> my_mesh_scoping = op.outputs.mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='requested_location', optional=False, type_names=['string'])), (1, InputSpec(document='the string is expected to be in upper case', ellipsis=False, name='named_selection_name', optional=False, type_names=['string'])), (2, InputSpec(document='If element scoping is requested on a nodal named selection, if Inclusive == 1 then add all the elements adjacent to the nodes.If Inclusive == 0, only the elements which have all their nodes in the named selection are included', ellipsis=False, name='int_inclusive', optional=True, type_names=['int32'])), (3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))])
        def __init__(self, oper):
            self._requested_location = None
            self._named_selection_name = None
            self._int_inclusive = None
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def named_selection_name(self):
            """the string is expected to be in upper case"""
            return self._named_selection_name

        @named_selection_name.setter
        def named_selection_name(self, named_selection_name):
            self._named_selection_name.connect(named_selection_name)

        @property
        def int_inclusive(self):
            """If element scoping is requested on a nodal named selection, if Inclusive == 1 then add all the elements adjacent to the nodes.If Inclusive == 0, only the elements which have all their nodes in the named selection are included"""
            return self._int_inclusive

        @int_inclusive.setter
        def int_inclusive(self, int_inclusive):
            self._int_inclusive.connect(int_inclusive)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_scoping', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """"""
            return self._mesh_scoping


    def __init__(self, requested_location, named_selection_name, data_sources, int_inclusive=None, streams_container=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scoping_provider_by_ns"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_scoping(self):
        """"""
        return self.outputs._mesh_scoping



class ConnectivityIds(dpf.Operator):
    """DPF "scoping::connectivity_ids" Operator

    Returns the ordered node ids corresponding to the element ids
    scoping in input. For each element the node ids are its
    connectivity.

    Available inputs:
     -   ``take_mid_nodes`` : B, optional
         Default is true

     -   ``mesh`` : MeshedRegion, optional
         The support of the scoping is expected if there is no mesh in input

     -   ``mesh_scoping`` : Scoping
         Elemental scoping


    Available outputs:
     -   elemental_scoping
     -   mesh_scoping


    Parameters
    ----------
    mesh_scoping : Scoping
        Elemental scoping

    mesh : MeshedRegion, optional
        The support of the scoping is expected if there is no mesh in
        input

    take_mid_nodes : bool, optional
        Default is true

    Examples
    --------
    >>> op = dpf.operators.ConnectivityIds()
    >>> op.inputs.take_mid_nodes.connect(my_take_mid_nodes)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)
    >>> my_elemental_scoping = op.outputs.elemental_scoping()
    >>> my_mesh_scoping = op.outputs.mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(1, InputSpec(document='Elemental scoping', ellipsis=False, name='mesh_scoping', optional=False, type_names=['scoping'])), (7, InputSpec(document='the support of the scoping is expected if there is no mesh in input', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region'])), (10, InputSpec(document='default is true', ellipsis=False, name='take_mid_nodes', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._mesh_scoping = None
            self._mesh = None
            self._take_mid_nodes = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """Elemental scoping"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def mesh(self):
            """the support of the scoping is expected if there is no mesh in input"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def take_mid_nodes(self):
            """default is true"""
            return self._take_mid_nodes

        @take_mid_nodes.setter
        def take_mid_nodes(self, take_mid_nodes):
            self._take_mid_nodes.connect(take_mid_nodes)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_scoping', type_names=['scoping'], document='')), (1, OutputSpec(name='elemental_scoping', type_names=['scoping'], document='same as the input scoping but with ids dupplicated to havve the same size as nodal output scoping'))])
        def __init__(self, oper):
            self._mesh_scoping = None
            self._elemental_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """"""
            return self._mesh_scoping

        @property
        def elemental_scoping(self):
            """same as the input scoping but with ids dupplicated to havve the same size as nodal output scoping"""
            return self._elemental_scoping


    def __init__(self, mesh_scoping, mesh=None, take_mid_nodes=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scoping::connectivity_ids"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_scoping(self):
        """"""
        return self.outputs._mesh_scoping

    @property
    def elemental_scoping(self):
        """same as the input scoping but with ids dupplicated to havve the same size as nodal output scoping"""
        return self.outputs._elemental_scoping



class NodalFromMesh(dpf.Operator):
    """DPF "GetNodeScopingFromMesh" Operator

    Get the nodes ids scoping of an input mesh.

    Available inputs:
     -   ``mesh`` : MeshedRegion


    Available outputs:
     -   mesh_scoping


    Parameters
    ----------
    mesh : MeshedRegion




    Examples
    --------
    >>> op = dpf.operators.NodalFromMesh()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> my_mesh_scoping = op.outputs.mesh_scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='mesh_scoping', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            """"""
            return self._mesh_scoping


    def __init__(self, mesh):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "GetNodeScopingFromMesh"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_scoping(self):
        """"""
        return self.outputs._mesh_scoping



class ChangeFc(dpf.Operator):
    """DPF "rescope_fc" Operator

    Rescope a fields container to correspond to a scopings container

    Available inputs:
     -   ``scopings_container`` : ScopingsContainer

     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    scopings_container : scopings_container




    Examples
    --------
    >>> op = dpf.operators.ChangeFc()
    >>> op.inputs.scopings_container.connect(my_scopings_container)
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='scopings_container', optional=False, type_names=['scopings_container']))])
        def __init__(self, oper):
            self._fields_container = None
            self._scopings_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def scopings_container(self):
            return self._scopings_container

        @scopings_container.setter
        def scopings_container(self, scopings_container):
            self._scopings_container.connect(scopings_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, scopings_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "rescope_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class FromMesh(dpf.Operator):
    """DPF "MeshScopingProvider" Operator

    Provides the entire mesh scoping based on the requested location

    Available inputs:
     -   ``mesh`` : MeshedRegion

     -   ``requested_location`` : str, optional
         If nothing the operator returns the nodes scoping, possible locations
         are: nodal or elemental


    Available outputs:
     -   scoping


    Parameters
    ----------
    mesh : MeshedRegion


    requested_location : str, optional
        If nothing the operator returns the nodes scoping, possible
        locations are: nodal or elemental

    Examples
    --------
    >>> op = dpf.operators.FromMesh()
    >>> op.inputs.mesh.connect(my_mesh)
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_scoping = op.outputs.scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region'])), (1, InputSpec(document='if nothing the operator returns the nodes scoping, possible locations are: Nodal or Elemental', ellipsis=False, name='requested_location', optional=True, type_names=['string']))])
        def __init__(self, oper):
            self._mesh = None
            self._requested_location = None
            super().__init__(self._spec, oper)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """if nothing the operator returns the nodes scoping, possible locations are: Nodal or Elemental"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='scoping', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._scoping = None
            super().__init__(self._spec, oper)

        @property
        def scoping(self):
            """"""
            return self._scoping


    def __init__(self, mesh, requested_location=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "MeshScopingProvider"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def scoping(self):
        """"""
        return self.outputs._scoping



