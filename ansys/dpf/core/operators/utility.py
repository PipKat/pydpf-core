"""Autogenerated DPF operator classes.

Created on 01/15/2021, 00:24:02
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class BindSupport(dpf.Operator):
    """DPF "BindSupport" Operator

    Tie a support to a field.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``support`` : MeshedRegion, AbstractFieldSupport
         Meshed region or a support of the field


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    support : MeshedRegion or abstract_field_support
        Meshed region or a support of the field



    Examples
    --------
    >>> op = dpf.operators.BindSupport()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.support.connect(my_support)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='meshed region or a support of the field', ellipsis=False, name='support', optional=False, type_names=['abstract_meshed_region', 'abstract_field_support']))])
        def __init__(self, oper):
            self._field = None
            self._support = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def support(self):
            """meshed region or a support of the field"""
            return self._support

        @support.setter
        def support(self, support):
            self._support.connect(support)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, support):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "BindSupport"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ExtractField(dpf.Operator):
    """DPF "ExtractFromFC" Operator

    Extract the fields at the indeces defined in the vector (in 1)
    form the fields container (in:0).

    Available inputs:
     -   ``fields_container`` : Field, FieldsContainer
         If a field is in input, it is passed on as output

     -   ``indeces`` : list, optional
         Default is the first field


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : Field or FieldsContainer
        If a field is in input, it is passed on as output

    indeces : list, optional
        Default is the first field

    Examples
    --------
    >>> op = dpf.operators.ExtractField()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.indeces.connect(my_indeces)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='if a field is in input, it is passed on as output', ellipsis=False, name='fields_container', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='default is the first field', ellipsis=False, name='indeces', optional=True, type_names=['vector<int32>']))])
        def __init__(self, oper):
            self._fields_container = None
            self._indeces = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """if a field is in input, it is passed on as output"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def indeces(self):
            """default is the first field"""
            return self._indeces

        @indeces.setter
        def indeces(self, indeces):
            self._indeces.connect(indeces)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, indeces=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ExtractFromFC"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ChangeLocation(dpf.Operator):
    """DPF "change_location" Operator

    change the location of a field.

    Available inputs:
     -   ``field`` : Field

     -   ``new_location`` : str
         New location of the output field ex: 'nodal', 'elementalnodal',
         'elemental'...


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field


    new_location : str
        New location of the output field ex: 'nodal',
        'elementalnodal', 'elemental'...



    Examples
    --------
    >>> op = dpf.operators.ChangeLocation()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.new_location.connect(my_new_location)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field'])), (1, InputSpec(document="new location of the output field ex: 'Nodal', 'ElementalNodal', 'Elemental'...", ellipsis=False, name='new_location', optional=False, type_names=['string']))])
        def __init__(self, oper):
            self._field = None
            self._new_location = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def new_location(self):
            """new location of the output field ex: 'Nodal', 'ElementalNodal', 'Elemental'..."""
            return self._new_location

        @new_location.setter
        def new_location(self, new_location):
            self._new_location.connect(new_location)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, new_location):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "change_location"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class FieldToFc(dpf.Operator):
    """DPF "InjectToFieldContainer" Operator

    Create a field container containing the field in input.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         If a fields container is set in input, it is pass on as output.


    Available outputs:
     -   fields_container


    Parameters
    ----------
    field : Field or FieldsContainer
        If a fields container is set in input, it is pass on as
        output.



    Examples
    --------
    >>> op = dpf.operators.FieldToFc()
    >>> op.inputs.field.connect(my_field)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='if a fields container is set in input, it is pass on as output.', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """if a fields container is set in input, it is pass on as output."""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "InjectToFieldContainer"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class StrainFromVoigt(dpf.Operator):
    """DPF "strain_from_voigt" Operator

    Put strain field from Voigt notation to standard format.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.StrainFromVoigt()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "strain_from_voigt"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ScalarsToField(dpf.Operator):
    """DPF "fieldify" Operator

    take a double or a vector of double and transform it in a one
    entity field of location "numeric".

    Available inputs:
     -   ``double_or_vector_double`` : float, Vector<Double>
         Double or vector of double


    Available outputs:
     -   field


    Parameters
    ----------
    double_or_vector_double : float or vector<double>
        Double or vector of double



    Examples
    --------
    >>> op = dpf.operators.ScalarsToField()
    >>> op.inputs.double_or_vector_double.connect(my_double_or_vector_double)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='double or vector of double', ellipsis=False, name='double_or_vector_double', optional=False, type_names=['double', 'vector<double>']))])
        def __init__(self, oper):
            self._double_or_vector_double = None
            super().__init__(self._spec, oper)

        @property
        def double_or_vector_double(self):
            """double or vector of double"""
            return self._double_or_vector_double

        @double_or_vector_double.setter
        def double_or_vector_double(self, double_or_vector_double):
            self._double_or_vector_double.connect(double_or_vector_double)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, double_or_vector_double):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "fieldify"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class UnitaryField(dpf.Operator):
    """DPF "make_unit" Operator

    Take a field and returns an other field of scalars on the same
    location and scoping as the input field

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.UnitaryField()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "make_unit"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class SetProperty(dpf.Operator):
    """DPF "field::set_property" Operator

    Set a property to an input field/field container

    Available inputs:
     -   ``property_value`` : str, int, float
         Property to set

     -   ``property_name`` : str
         Property to set

     -   ``field`` : Field, FieldsContainer


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer


    property_name : str
        Property to set

    property_value : str or int or float
        Property to set



    Examples
    --------
    >>> op = dpf.operators.SetProperty()
    >>> op.inputs.property_value.connect(my_property_value)
    >>> op.inputs.property_name.connect(my_property_name)
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='Property to set', ellipsis=False, name='property_name', optional=False, type_names=['string'])), (2, InputSpec(document='Property to set', ellipsis=False, name='property_value', optional=False, type_names=['string', 'int32', 'double']))])
        def __init__(self, oper):
            self._field = None
            self._property_name = None
            self._property_value = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def property_name(self):
            """Property to set"""
            return self._property_name

        @property_name.setter
        def property_name(self, property_name):
            self._property_name.connect(property_name)

        @property
        def property_value(self):
            """Property to set"""
            return self._property_value

        @property_value.setter
        def property_value(self, property_value):
            self._property_value.connect(property_value)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field', 'fields_container'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, property_name, property_value):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "field::set_property"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ForwardField(dpf.Operator):
    """DPF "forward" Operator

    Return the input field or fields container.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.ForwardField()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "forward"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ForwardFieldsContainer(dpf.Operator):
    """DPF "forward_fc" Operator

    Return the input field or fields container.

    Available inputs:
     -   ``fields`` : FieldsContainer, Field


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields : FieldsContainer or Field




    Examples
    --------
    >>> op = dpf.operators.ForwardFieldsContainer()
    >>> op.inputs.fields.connect(my_fields)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields', optional=False, type_names=['fields_container', 'field']))])
        def __init__(self, oper):
            self._fields = None
            super().__init__(self._spec, oper)

        @property
        def fields(self):
            return self._fields

        @fields.setter
        def fields(self, fields):
            self._fields.connect(fields)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "forward_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class TxtFileToDpf(dpf.Operator):
    """DPF "text_parser" Operator

    Take an input string and parse it into dataProcessing type.

    Available inputs:
     -   ``input_string`` : str
         Ex: "double:1.0", "int:1", "vector<double>:1.0;1.0"


     Available outputs:


    Parameters
    ----------
    input_string : str
        Ex: 'double:1.0', 'int:1', 'vector<double>:1.0;1.0'



    Examples
    --------
    >>> op = dpf.operators.TxtFileToDpf()
    >>> op.inputs.input_string.connect(my_input_string)
    >>> my_any_output = op.outputs.any_output()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document="ex: 'double:1.0', 'int:1', 'vector<double>:1.0;1.0'", ellipsis=False, name='input_string', optional=False, type_names=['string']))])
        def __init__(self, oper):
            self._input_string = None
            super().__init__(self._spec, oper)

        @property
        def input_string(self):
            """ex: 'double:1.0', 'int:1', 'vector<double>:1.0;1.0'"""
            return self._input_string

        @input_string.setter
        def input_string(self, input_string):
            self._input_string.connect(input_string)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='any_output', type_names=[], document='any output'))])
        def __init__(self, oper):
            self._any_output = None
            super().__init__(self._spec, oper)

        @property
        def any_output(self):
            """any output"""
            return self._any_output


    def __init__(self, input_string):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "text_parser"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def any_output(self):
        """any output"""
        return self.outputs._any_output



class BindSupportFc(dpf.Operator):
    """DPF "BindSupportFC" Operator

    Tie a support to a fields container.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``support`` : MeshedRegion, AbstractFieldSupport
         Meshed region or a support of the field


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    support : MeshedRegion or abstract_field_support
        Meshed region or a support of the field



    Examples
    --------
    >>> op = dpf.operators.BindSupportFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.support.connect(my_support)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='meshed region or a support of the field', ellipsis=False, name='support', optional=False, type_names=['abstract_meshed_region', 'abstract_field_support']))])
        def __init__(self, oper):
            self._fields_container = None
            self._support = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def support(self):
            """meshed region or a support of the field"""
            return self._support

        @support.setter
        def support(self, support):
            self._support.connect(support)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, support):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "BindSupportFC"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ChangeShellLayers(dpf.Operator):
    """DPF "change_shellLayers" Operator

    Extract the expected shell layers from the input fields, if the
    fields contain only one layer then it returns the input fields

    Available inputs:
     -   ``e_shell_layer`` : int, N14Dataprocessing12Eshelllayerse
         0:top, 1: bottom, 2: bottomtop, 3:mid, 4:bottomtopmid

     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    e_shell_layer : int or N14dataProcessing12EShellLayersE
        0:top, 1: bottom, 2: bottomtop, 3:mid, 4:bottomtopmid



    Examples
    --------
    >>> op = dpf.operators.ChangeShellLayers()
    >>> op.inputs.e_shell_layer.connect(my_e_shell_layer)
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='0:Top, 1: Bottom, 2: BottomTop, 3:Mid, 4:BottomTopMid', ellipsis=False, name='e_shell_layer', optional=False, type_names=['int32', 'N14dataProcessing12EShellLayersE']))])
        def __init__(self, oper):
            self._fields_container = None
            self._e_shell_layer = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def e_shell_layer(self):
            """0:Top, 1: Bottom, 2: BottomTop, 3:Mid, 4:BottomTopMid"""
            return self._e_shell_layer

        @e_shell_layer.setter
        def e_shell_layer(self, e_shell_layer):
            self._e_shell_layer.connect(e_shell_layer)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, e_shell_layer):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "change_shellLayers"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



