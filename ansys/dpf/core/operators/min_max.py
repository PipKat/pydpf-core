"""Autogenerated DPF operator classes.

Created on 01/15/2021, 00:24:02
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class MinMax(dpf.Operator):
    """DPF "min_max" Operator

    Compute the component-wise minimum (out 0) and maximum (out 1)
    over a field.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field_max
     -   field_min


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.MinMax()
    >>> op.inputs.field.connect(my_field)
    >>> my_field_max = op.outputs.field_max()
    >>> my_field_min = op.outputs.field_min()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field_min', type_names=['field'], document='')), (1, OutputSpec(name='field_max', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field_min = None
            self._field_max = None
            super().__init__(self._spec, oper)

        @property
        def field_min(self):
            """"""
            return self._field_min

        @property
        def field_max(self):
            """"""
            return self._field_max


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_max"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field_min(self):
        """"""
        return self.outputs._field_min

    @property
    def field_max(self):
        """"""
        return self.outputs._field_max



class MinMaxFc(dpf.Operator):
    """DPF "min_max_fc" Operator

    Compute the component-wise minimum (out 0) and maximum (out 1)
    over a fields container.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   field_min
     -   field_max


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.MinMaxFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_field_min = op.outputs.field_min()
    >>> my_field_max = op.outputs.field_max()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field_min', type_names=['field'], document='')), (1, OutputSpec(name='field_max', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field_min = None
            self._field_max = None
            super().__init__(self._spec, oper)

        @property
        def field_min(self):
            """"""
            return self._field_min

        @property
        def field_max(self):
            """"""
            return self._field_max


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_max_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field_min(self):
        """"""
        return self.outputs._field_min

    @property
    def field_max(self):
        """"""
        return self.outputs._field_max



class MinMaxOverLabelFc(dpf.Operator):
    """DPF "min_max_over_label_fc" Operator

    Compute the component-wise minimum (out 0) and maximum (out 1)
    over all the fields having the same id for the label set in input
    in the fields container.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``label`` : str
         Label name from the fields container


    Available outputs:
     -   field_max
     -   field_min


    Parameters
    ----------
    fields_container : FieldsContainer


    label : str
        Label name from the fields container



    Examples
    --------
    >>> op = dpf.operators.MinMaxOverLabelFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.label.connect(my_label)
    >>> my_field_max = op.outputs.field_max()
    >>> my_field_min = op.outputs.field_min()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='label name from the fields container', ellipsis=False, name='label', optional=False, type_names=['string']))])
        def __init__(self, oper):
            self._fields_container = None
            self._label = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def label(self):
            """label name from the fields container"""
            return self._label

        @label.setter
        def label(self, label):
            self._label.connect(label)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field_min', type_names=['field'], document='')), (1, OutputSpec(name='field_max', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field_min = None
            self._field_max = None
            super().__init__(self._spec, oper)

        @property
        def field_min(self):
            """"""
            return self._field_min

        @property
        def field_max(self):
            """"""
            return self._field_max


    def __init__(self, fields_container, label):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_max_over_label_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field_min(self):
        """"""
        return self.outputs._field_min

    @property
    def field_max(self):
        """"""
        return self.outputs._field_max



class MinByComponent(dpf.Operator):
    """DPF "min_by_component" Operator

    Give the minimum for each element rank by comparing several
    fields.

    Available inputs:
     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected
         is ellipsis

     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected
         is ellipsis

     -   ``use_absolute_value`` : B
         Use_absolute_value


    Available outputs:
     -   field


    Parameters
    ----------
    use_absolute_value : bool
        Use_absolute_value

    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.MinByComponent()
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.use_absolute_value.connect(my_use_absolute_value)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='use_absolute_value', ellipsis=False, name='use_absolute_value', optional=False, type_names=['b'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=True, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (2, InputSpec(document='field or fields container with only one field is expected', ellipsis=True, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._use_absolute_value = None
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def use_absolute_value(self):
            """use_absolute_value"""
            return self._use_absolute_value

        @use_absolute_value.setter
        def use_absolute_value(self, use_absolute_value):
            self._use_absolute_value.connect(use_absolute_value)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, use_absolute_value, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_by_component"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class MaxByComponent(dpf.Operator):
    """DPF "max_by_component" Operator

    Give the maximum for each element rank by comparing several
    fields.

    Available inputs:
     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected
         is ellipsis

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected
         is ellipsis

     -   ``use_absolute_value`` : B
         Use_absolute_value


    Available outputs:
     -   field


    Parameters
    ----------
    use_absolute_value : bool
        Use_absolute_value

    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.MaxByComponent()
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.use_absolute_value.connect(my_use_absolute_value)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='use_absolute_value', ellipsis=False, name='use_absolute_value', optional=False, type_names=['b'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=True, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (2, InputSpec(document='field or fields container with only one field is expected', ellipsis=True, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._use_absolute_value = None
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def use_absolute_value(self):
            """use_absolute_value"""
            return self._use_absolute_value

        @use_absolute_value.setter
        def use_absolute_value(self, use_absolute_value):
            self._use_absolute_value.connect(use_absolute_value)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, use_absolute_value, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "max_by_component"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class MinMaxFcInc(dpf.Operator):
    """DPF "min_max_fc_inc" Operator

    Compute the component-wise minimum (out 0) and maximum (out 1)
    over a fields container.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   field_min
     -   field_max


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.MinMaxFcInc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_field_min = op.outputs.field_min()
    >>> my_field_max = op.outputs.field_max()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field_min', type_names=['field'], document='')), (1, OutputSpec(name='field_max', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field_min = None
            self._field_max = None
            super().__init__(self._spec, oper)

        @property
        def field_min(self):
            """"""
            return self._field_min

        @property
        def field_max(self):
            """"""
            return self._field_max


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_max_fc_inc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field_min(self):
        """"""
        return self.outputs._field_min

    @property
    def field_max(self):
        """"""
        return self.outputs._field_max



class MinMaxInc(dpf.Operator):
    """DPF "min_max_inc" Operator

    Compute the component-wise minimum (out 0) and maximum (out 1)
    over coming fields.

    Available inputs:
     -   ``domain_id`` : int, optional

     -   ``field`` : Field


    Available outputs:
     -   domain_ids_min
     -   domain_ids_max
     -   field_min
     -   field_max


    Parameters
    ----------
    field : Field


    domain_id : int, optional


    Examples
    --------
    >>> op = dpf.operators.MinMaxInc()
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.field.connect(my_field)
    >>> my_domain_ids_min = op.outputs.domain_ids_min()
    >>> my_domain_ids_max = op.outputs.domain_ids_max()
    >>> my_field_min = op.outputs.field_min()
    >>> my_field_max = op.outputs.field_max()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field'])), (17, InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']))])
        def __init__(self, oper):
            self._field = None
            self._domain_id = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field_min', type_names=['field'], document='')), (1, OutputSpec(name='field_max', type_names=['field'], document='')), (2, OutputSpec(name='domain_ids_min', type_names=['scoping'], document='')), (3, OutputSpec(name='domain_ids_max', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._field_min = None
            self._field_max = None
            self._domain_ids_min = None
            self._domain_ids_max = None
            super().__init__(self._spec, oper)

        @property
        def field_min(self):
            """"""
            return self._field_min

        @property
        def field_max(self):
            """"""
            return self._field_max

        @property
        def domain_ids_min(self):
            """"""
            return self._domain_ids_min

        @property
        def domain_ids_max(self):
            """"""
            return self._domain_ids_max


    def __init__(self, field, domain_id=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_max_inc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field_min(self):
        """"""
        return self.outputs._field_min

    @property
    def field_max(self):
        """"""
        return self.outputs._field_max

    @property
    def domain_ids_min(self):
        """"""
        return self.outputs._domain_ids_min

    @property
    def domain_ids_max(self):
        """"""
        return self.outputs._domain_ids_max



