"""Autogenerated DPF operator classes.

Created on 01/03/2021, 15:50:43
"""
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class displacement(dpf.Operator):
    """DPF "U" Operator

    Load the appropriate operator based on the data sources and
    read/compute nodal displacements. Regarding the requested location
    and the input mesh scoping, the result location can be
    Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   ``time_scoping`` : Scoping, list, optional

     -   ``domain_id`` : int, optional

     -   ``mesh_scoping`` : ScopingsContainer, Scoping, optional
         Mesh entities scoping, unordered_map<int, int> id to index (optional)
         (index is optional, to be set if a user wants the results at a given
         order)

     -   ``fields_container`` : FieldsContainer, optional
         Fields container already allocated modified inplace

     -   ``streams_container`` : StreamsContainer, optional
         Streams (result file container) (optional)

     -   ``data_sources`` : DataSources
         If the stream is null then we need to get the file path from the data
         sources

     -   ``bool_rotate_to_global`` : B, optional
         If true the field is roated to global coordinate system (default true)

     -   ``mesh`` : MeshedRegion, optional

     -   ``requested_location`` : str, optional


    Available outputs:
     -   fields_container


    Examples
    --------
    >>> op = dpf.operators.displacement()
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.domain_id.connect(my_domain_id)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = {0: InputSpec(document='', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'vector<int32>']), 17: InputSpec(document='', ellipsis=False, name='domain_id', optional=True, type_names=['int32']), 1: InputSpec(document='mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)', ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping']), 2: InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container']), 3: InputSpec(document='streams (result file container) (optional)', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container']), 4: InputSpec(document='if the stream is null then we need to get the file path from the data sources', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']), 5: InputSpec(document='if true the field is roated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['b']), 7: InputSpec(document='', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']), 9: InputSpec(document='', ellipsis=False, name='requested_location', optional=True, type_names=['string'])}
        def __init__(self, oper):
            self._time_scoping = None
            self._domain_id = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def domain_id(self):
            return self._domain_id

        @domain_id.setter
        def domain_id(self, domain_id):
            self._domain_id.connect(domain_id)

        @property
        def mesh_scoping(self):
            """mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """streams (result file container) (optional)"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """if the stream is null then we need to get the file path from the data sources"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is roated to global coordinate system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)


    class _Outputs(dpf.outputs.Outputs):
        _spec = {0: OutputSpec(name='fields_container', type_names=['fields_container'], document='')}
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "U"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)


class Dot(dpf.Operator):
    """DPF "dot" Operator

    Computes element-wise dot product between two vector fields. If
    one field's scoping has 'overall' location, then these field's
    values are applied on the entire other field.

    Available inputs:
     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Examples
    --------
    >>> op = dpf.operators.Dot()
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = {0: InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container']), 1: InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container'])}
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = {0: OutputSpec(name='field', type_names=['field'], document='')}
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "dot"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)


