"""Autogenerated DPF operator classes.

Created on 10/06/2021, 13:12:29
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class AccuEqvPlasticStrain(dpf.Operator):
    """DPF "ENL_EPEQ" Operator

    Read/compute element nodal accumulated equivalent plastic strain
    by calling the readers defined by the datasources. Regarding the
    requested location and the input mesh scoping, the result location
    can be Nodal/ElementalNodal/Elemental.

    Available inputs:
     -   bool_rotate_to_global : bool, optional
         If true the field is rotated to global coordinate system
         (default true)
     -   mesh : MeshedRegion, MeshesContainer, optional
         Prevents from reading the mesh in the result files
     -   time_scoping : Scoping, int, list, float, Field, optional
         Time/freq (use doubles or field), time/freq set ids (use ints
         or scoping) or time/freq step ids (use scoping with
         timefreq_steps location) requiered in output
     -   requested_location : str, optional
         Requested location nodal, elemental or elementalnodal
     -   mesh_scoping : ScopingsContainer, Scoping, optional
         Nodes or elements scoping requiered in output. the scoping's
         location indicates whether nodes or elements are asked. using
         scopings container enables to split the result fields
         container in domains
     -   fields_container : FieldsContainer, optional
         Fields container already allocated modified inplace
     -   data_sources : DataSources
         Result file path container, used if no streams are set
     -   streams_container : StreamsContainer, optional
         Result file container allowed to be kept open to cache data
     -   read_cyclic : Enum Dataprocessing::Ecyclicreading, int,
            optional
         If 0 cyclic symmetry is ignored, if 1 cyclic sector is read,
         if 2 cyclic expansion is done, if 3 cyclic expansion is done
         and stages are merged (default is 1)
    Available outputs:
     -   fields_container


    Parameters
    ----------
    data_sources : DataSources
        Result file path container, used if no streams are set

    time_scoping : Scoping or int or list or float or Field or list,
        optional
        Time/freq (use doubles or field), time/freq set ids (use ints
        or scoping) or time/freq step ids (use scoping with
        timefreq_steps location) requiered in output

    mesh_scoping : scopings_container or Scoping, optional
        Nodes or elements scoping requiered in output. the scoping's
        location indicates whether nodes or elements are asked. using
        scopings container enables to split the result fields
        container in domains

    fields_container : FieldsContainer, optional
        Fields container already allocated modified inplace

    streams_container : streams_container, optional
        Result file container allowed to be kept open to cache data

    bool_rotate_to_global : bool, optional
        If true the field is rotated to global coordinate system
        (default true)

    mesh : MeshedRegion or meshes_container, optional
        Prevents from reading the mesh in the result files

    requested_location : str, optional
        Requested location nodal, elemental or elementalnodal

    read_cyclic : enum dataProcessing::ECyclicReading or int, optional
        If 0 cyclic symmetry is ignored, if 1 cyclic sector is read,
        if 2 cyclic expansion is done, if 3 cyclic expansion is done
        and stages are merged (default is 1)

    Examples
    --------
    >>> op = dpf.operators.AccuEqvPlasticStrain()
    >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.time_scoping.connect(my_time_scoping)  # optional
    >>> op.inputs.requested_location.connect(my_requested_location)  # optional
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.read_cyclic.connect(my_read_cyclic)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """  # noqa: E501

    class _Inputs(dpf.inputs.Inputs):

        # fmt: off
        _spec = OrderedDict([(0, InputSpec(document='time/freq (use doubles or field), time/freq set ids (use ints or scoping) or time/freq step ids (use scoping with TimeFreq_steps location) requiered in output', ellipsis=False, name='time_scoping', optional=True, type_names=['scoping', 'int32', 'vector<int32>', 'double', 'field', 'vector<double>'])), (1, InputSpec(document="nodes or elements scoping requiered in output. The scoping's location indicates whether nodes or elements are asked. Using scopings container enables to split the result fields container in domains", ellipsis=False, name='mesh_scoping', optional=True, type_names=['scopings_container', 'scoping'])), (2, InputSpec(document='Fields container already allocated modified inplace', ellipsis=False, name='fields_container', optional=True, type_names=['fields_container'])), (3, InputSpec(document='result file container allowed to be kept open to cache data', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='result file path container, used if no streams are set', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources'])), (5, InputSpec(document='if true the field is rotated to global coordinate system (default true)', ellipsis=False, name='bool_rotate_to_global', optional=True, type_names=['bool'])), (7, InputSpec(document='prevents from reading the mesh in the result files', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region', 'meshes_container'])), (9, InputSpec(document='requested location Nodal, Elemental or ElementalNodal', ellipsis=False, name='requested_location', optional=True, type_names=['string'])), (14, InputSpec(document='if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done, if 3 cyclic expansion is done and stages are merged (default is 1)', ellipsis=False, name='read_cyclic', optional=True, type_names=['enum dataProcessing::ECyclicReading', 'int32']))]) # noqa: E501
        # fmt: on

        def __init__(self, oper):
            self._time_scoping = None
            self._mesh_scoping = None
            self._fields_container = None
            self._streams_container = None
            self._data_sources = None
            self._bool_rotate_to_global = None
            self._mesh = None
            self._requested_location = None
            self._read_cyclic = None
            super().__init__(self._spec, oper)

        @property
        def time_scoping(self):
            """time/freq (use doubles or field), time/freq set ids
            (use ints or scoping) or time/freq step ids (use scoping
            with TimeFreq_steps location) requiered in output"""
            return self._time_scoping

        @time_scoping.setter
        def time_scoping(self, time_scoping):
            self._time_scoping.connect(time_scoping)

        @property
        def mesh_scoping(self):
            """nodes or elements scoping requiered in output. The
            scoping's location indicates whether nodes or elements
            are asked. Using scopings container enables to split the
            result fields container in domains"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)

        @property
        def fields_container(self):
            """Fields container already allocated modified inplace"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def streams_container(self):
            """result file container allowed to be kept open to cache
            data"""
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            """result file path container, used if no streams are
            set"""
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

        @property
        def bool_rotate_to_global(self):
            """if true the field is rotated to global coordinate
            system (default true)"""
            return self._bool_rotate_to_global

        @bool_rotate_to_global.setter
        def bool_rotate_to_global(self, bool_rotate_to_global):
            self._bool_rotate_to_global.connect(bool_rotate_to_global)

        @property
        def mesh(self):
            """prevents from reading the mesh in the result files"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)

        @property
        def requested_location(self):
            """requested location Nodal, Elemental or
            ElementalNodal"""
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def read_cyclic(self):
            """if 0 cyclic symmetry is ignored, if 1 cyclic sector is
            read, if 2 cyclic expansion is done, if 3 cyclic
            expansion is done and stages are merged (default is 1)"""
            return self._read_cyclic

        @read_cyclic.setter
        def read_cyclic(self, read_cyclic):
            self._read_cyclic.connect(read_cyclic)

    class _Outputs(dpf.outputs.Outputs):

        # fmt: off
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))]) # noqa: E501
        # fmt: on

        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

    def __init__(
        self,
        data_sources,
        time_scoping=None,
        mesh_scoping=None,
        fields_container=None,
        streams_container=None,
        bool_rotate_to_global=None,
        mesh=None,
        requested_location=None,
        read_cyclic=None,
    ):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "ENL_EPEQ"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        return self.outputs._fields_container
