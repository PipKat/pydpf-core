"""Autogenerated DPF operator classes.

Created on 01/15/2021, 00:24:02
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class ScopingOnCoordinates(dpf.Operator):
    """DPF "scoping::on_coordinates" Operator

    Finds the Elemental scoping of a set of coordinates.

    Available inputs:
     -   ``coordinates`` : Field

     -   ``mesh`` : MeshedRegion


    Available outputs:
     -   scoping


    Parameters
    ----------
    coordinates : Field


    mesh : MeshedRegion




    Examples
    --------
    >>> op = dpf.operators.ScopingOnCoordinates()
    >>> op.inputs.coordinates.connect(my_coordinates)
    >>> op.inputs.mesh.connect(my_mesh)
    >>> my_scoping = op.outputs.scoping()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='coordinates', optional=False, type_names=['field'])), (7, InputSpec(document='', ellipsis=False, name='mesh', optional=False, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._coordinates = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def coordinates(self):
            return self._coordinates

        @coordinates.setter
        def coordinates(self, coordinates):
            self._coordinates.connect(coordinates)

        @property
        def mesh(self):
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='scoping', type_names=['scoping'], document=''))])
        def __init__(self, oper):
            self._scoping = None
            super().__init__(self._spec, oper)

        @property
        def scoping(self):
            """"""
            return self._scoping


    def __init__(self, coordinates, mesh):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scoping::on_coordinates"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def scoping(self):
        """"""
        return self.outputs._scoping



class OnCoordinates(dpf.Operator):
    """DPF "mapping" Operator

    Evaluates a result on specified coordinates (interpolates results
    inside elements with shape functions).

    Available inputs:
     -   ``mapping_on_scoping`` : B, optional
         If this pin is set to true, then the mapping between the coordinates
         and the fields is created only on the first field scoping

     -   ``create_support`` : B, optional
         If this pin is set to true, then, a support associated to the fields
         consisting of points is created

     -   ``mesh`` : MeshedRegion, optional
         If the first field in input has no mesh in support, then the mesh in
         this pin is expected (default is false)

     -   ``coordinates`` : Field

     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    coordinates : Field


    create_support : bool, optional
        If this pin is set to true, then, a support associated to the
        fields consisting of points is created

    mapping_on_scoping : bool, optional
        If this pin is set to true, then the mapping between the
        coordinates and the fields is created only on the first field
        scoping

    mesh : MeshedRegion, optional
        If the first field in input has no mesh in support, then the
        mesh in this pin is expected (default is false)

    Examples
    --------
    >>> op = dpf.operators.OnCoordinates()
    >>> op.inputs.mapping_on_scoping.connect(my_mapping_on_scoping)  # optional
    >>> op.inputs.create_support.connect(my_create_support)  # optional
    >>> op.inputs.mesh.connect(my_mesh)  # optional
    >>> op.inputs.coordinates.connect(my_coordinates)
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='coordinates', optional=False, type_names=['field'])), (2, InputSpec(document='if this pin is set to true, then, a support associated to the fields consisting of points is created', ellipsis=False, name='create_support', optional=True, type_names=['b'])), (3, InputSpec(document='if this pin is set to true, then the mapping between the coordinates and the fields is created only on the first field scoping', ellipsis=False, name='mapping_on_scoping', optional=True, type_names=['b'])), (7, InputSpec(document='if the first field in input has no mesh in support, then the mesh in this pin is expected (default is false)', ellipsis=False, name='mesh', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._fields_container = None
            self._coordinates = None
            self._create_support = None
            self._mapping_on_scoping = None
            self._mesh = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def coordinates(self):
            return self._coordinates

        @coordinates.setter
        def coordinates(self, coordinates):
            self._coordinates.connect(coordinates)

        @property
        def create_support(self):
            """if this pin is set to true, then, a support associated to the fields consisting of points is created"""
            return self._create_support

        @create_support.setter
        def create_support(self, create_support):
            self._create_support.connect(create_support)

        @property
        def mapping_on_scoping(self):
            """if this pin is set to true, then the mapping between the coordinates and the fields is created only on the first field scoping"""
            return self._mapping_on_scoping

        @mapping_on_scoping.setter
        def mapping_on_scoping(self, mapping_on_scoping):
            self._mapping_on_scoping.connect(mapping_on_scoping)

        @property
        def mesh(self):
            """if the first field in input has no mesh in support, then the mesh in this pin is expected (default is false)"""
            return self._mesh

        @mesh.setter
        def mesh(self, mesh):
            self._mesh.connect(mesh)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, coordinates, create_support=None, mapping_on_scoping=None, mesh=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "mapping"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class SolidToSkin(dpf.Operator):
    """DPF "solid_to_skin" Operator

    Maps a field defined on solid elements to a field defined on skin
    elements.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``mesh_scoping`` : MeshedRegion, optional
         Skin mesh region expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    mesh_scoping : MeshedRegion, optional
        Skin mesh region expected

    Examples
    --------
    >>> op = dpf.operators.SolidToSkin()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='skin mesh region expected', ellipsis=False, name='mesh_scoping', optional=True, type_names=['abstract_meshed_region']))])
        def __init__(self, oper):
            self._field = None
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def mesh_scoping(self):
            """skin mesh region expected"""
            return self._mesh_scoping

        @mesh_scoping.setter
        def mesh_scoping(self, mesh_scoping):
            self._mesh_scoping.connect(mesh_scoping)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, mesh_scoping=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "solid_to_skin"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



