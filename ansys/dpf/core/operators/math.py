"""Autogenerated DPF operator classes.

Created on 01/15/2021, 00:24:02
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class UnitConvertFc(dpf.Operator):
    """DPF "unit_convert_fc" Operator

    Convert an input fields container of a given unit to another unit.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``unit_name`` : str
         Unit as a string, ex 'm' for meter, 'pa' for pascal,...


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    unit_name : str
        Unit as a string, ex 'm' for meter, 'pa' for pascal,...



    Examples
    --------
    >>> op = dpf.operators.UnitConvertFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.unit_name.connect(my_unit_name)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document="unit as a string, ex 'm' for meter, 'Pa' for pascal,...", ellipsis=False, name='unit_name', optional=False, type_names=['string']))])
        def __init__(self, oper):
            self._fields_container = None
            self._unit_name = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def unit_name(self):
            """unit as a string, ex 'm' for meter, 'Pa' for pascal,..."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, unit_name):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "unit_convert_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class TimeOfMin(dpf.Operator):
    """DPF "time_of_min" Operator

    Evaluates time/frequency of minimum.

    Available inputs:
     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.

     -   ``fields_container`` : FieldsContainer

     -   ``abs_value`` : B, optional
         Should use absolute value.

     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    >>> op = dpf.operators.TimeOfMin()
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, angle=None, unit_name=None, abs_value=None, compute_amplitude=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "time_of_min"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Minus(dpf.Operator):
    """DPF "minus" Operator

    Computes the difference of two fields. If one field's scoping has
    'overall' location, then these field's values are applied on the
    entire other field.

    Available inputs:
     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Minus()
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "minus"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class CplxMultiply(dpf.Operator):
    """DPF "cplx_multiply" Operator

    Computes multiply between two field containers containing complex
    fields.

    Available inputs:
     -   ``fields_containerA`` : FieldsContainer

     -   ``fields_containerB`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_containerA : FieldsContainer


    fields_containerB : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.CplxMultiply()
    >>> op.inputs.fields_containerA.connect(my_fields_containerA)
    >>> op.inputs.fields_containerB.connect(my_fields_containerB)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_containerA', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='fields_containerB', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_containerA = None
            self._fields_containerB = None
            super().__init__(self._spec, oper)

        @property
        def fields_containerA(self):
            return self._fields_containerA

        @fields_containerA.setter
        def fields_containerA(self, fields_containerA):
            self._fields_containerA.connect(fields_containerA)

        @property
        def fields_containerB(self):
            return self._fields_containerB

        @fields_containerB.setter
        def fields_containerB(self, fields_containerB):
            self._fields_containerB.connect(fields_containerB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_containerA, fields_containerB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cplx_multiply"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class UnitConvert(dpf.Operator):
    """DPF "unit_convert" Operator

    Convert an input field of a given unit to another unit.

    Available inputs:
     -   ``unit_name`` : str
         Unit as a string, ex 'm' for meter, 'pa' for pascal,...

     -   ``field`` : Field


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field


    unit_name : str
        Unit as a string, ex 'm' for meter, 'pa' for pascal,...



    Examples
    --------
    >>> op = dpf.operators.UnitConvert()
    >>> op.inputs.unit_name.connect(my_unit_name)
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field'])), (1, InputSpec(document="unit as a string, ex 'm' for meter, 'Pa' for pascal,...", ellipsis=False, name='unit_name', optional=False, type_names=['string']))])
        def __init__(self, oper):
            self._field = None
            self._unit_name = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def unit_name(self):
            """unit as a string, ex 'm' for meter, 'Pa' for pascal,..."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, unit_name):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "unit_convert"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Add(dpf.Operator):
    """DPF "add" Operator

    Computes the sum of two fields. If one field's scoping has
    'overall' location, then these field's values are applied on the
    entire other field.

    Available inputs:
     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Add()
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "add"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class AddFc(dpf.Operator):
    """DPF "add_fc" Operator

    Compute the field-wise sum of the input fields containers.

    Available inputs:
     -   ``fields_container`` : FieldsContainer
         is ellipsis


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.AddFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=True, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "add_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PhaseOfMax(dpf.Operator):
    """DPF "phase_of_max" Operator

    Evaluates phase of maximum.

    Available inputs:
     -   ``phase_increment`` : float
         Phase increment.

     -   ``real_field`` : Field

     -   ``imaginary_field`` : Field

     -   ``abs_value`` : B, optional
         Should use absolute value.


    Available outputs:
     -   field


    Parameters
    ----------
    real_field : Field


    imaginary_field : Field


    phase_increment : float
        Phase increment.

    abs_value : bool, optional
        Should use absolute value.

    Examples
    --------
    >>> op = dpf.operators.PhaseOfMax()
    >>> op.inputs.phase_increment.connect(my_phase_increment)
    >>> op.inputs.real_field.connect(my_real_field)
    >>> op.inputs.imaginary_field.connect(my_imaginary_field)
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='real_field', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='imaginary_field', optional=False, type_names=['field'])), (2, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (3, InputSpec(document='Phase increment.', ellipsis=False, name='phase_increment', optional=False, type_names=['double']))])
        def __init__(self, oper):
            self._real_field = None
            self._imaginary_field = None
            self._abs_value = None
            self._phase_increment = None
            super().__init__(self._spec, oper)

        @property
        def real_field(self):
            return self._real_field

        @real_field.setter
        def real_field(self, real_field):
            self._real_field.connect(real_field)

        @property
        def imaginary_field(self):
            return self._imaginary_field

        @imaginary_field.setter
        def imaginary_field(self, imaginary_field):
            self._imaginary_field.connect(imaginary_field)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def phase_increment(self):
            """Phase increment."""
            return self._phase_increment

        @phase_increment.setter
        def phase_increment(self, phase_increment):
            self._phase_increment.connect(phase_increment)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, real_field, imaginary_field, phase_increment, abs_value=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "phase_of_max"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class SinFc(dpf.Operator):
    """DPF "sin_fc" Operator

    Computes element-wise sin(field[i]).

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.SinFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "sin_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class AddConstant(dpf.Operator):
    """DPF "add_constant" Operator

    Computes the sum of a field (in 0) and a scalar (in 1).

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``ponderation`` : float, Vector<Double>
         Double or vector of double


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    ponderation : float or vector<double>
        Double or vector of double



    Examples
    --------
    >>> op = dpf.operators.AddConstant()
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.ponderation.connect(my_ponderation)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='double or vector of double', ellipsis=False, name='ponderation', optional=False, type_names=['double', 'vector<double>']))])
        def __init__(self, oper):
            self._field = None
            self._ponderation = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def ponderation(self):
            """double or vector of double"""
            return self._ponderation

        @ponderation.setter
        def ponderation(self, ponderation):
            self._ponderation.connect(ponderation)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, ponderation):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "add_constant"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class AddConstantFc(dpf.Operator):
    """DPF "add_constant_fc" Operator

    Computes the sum of a field (in 0) and a scalar (in 1).

    Available inputs:
     -   ``ponderation`` : float, Vector<Double>
         Double or vector of double

     -   ``fields_container`` : FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field or fields container with only one field is expected

    ponderation : float or vector<double>
        Double or vector of double



    Examples
    --------
    >>> op = dpf.operators.AddConstantFc()
    >>> op.inputs.ponderation.connect(my_ponderation)
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='double or vector of double', ellipsis=False, name='ponderation', optional=False, type_names=['double', 'vector<double>']))])
        def __init__(self, oper):
            self._fields_container = None
            self._ponderation = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """field or fields container with only one field is expected"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def ponderation(self):
            """double or vector of double"""
            return self._ponderation

        @ponderation.setter
        def ponderation(self, ponderation):
            self._ponderation.connect(ponderation)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, ponderation):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "add_constant_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Pow(dpf.Operator):
    """DPF "Pow" Operator

    Computes element-wise field[i]^p.

    Available inputs:
     -   ``factor`` : float

     -   ``field`` : Field


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field


    factor : float




    Examples
    --------
    >>> op = dpf.operators.Pow()
    >>> op.inputs.factor.connect(my_factor)
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='factor', optional=False, type_names=['double']))])
        def __init__(self, oper):
            self._field = None
            self._factor = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def factor(self):
            return self._factor

        @factor.setter
        def factor(self, factor):
            self._factor.connect(factor)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, factor):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "Pow"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Scale(dpf.Operator):
    """DPF "scale" Operator

    Scales a field by a constant factor.

    Available inputs:
     -   ``boolean`` : B, optional
         Bool(optional, default false) if set to true, output of scale is mane
         dimensionless

     -   ``ponderation`` : float, Field
         Double/field scoped on overall

     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    ponderation : float or Field
        Double/field scoped on overall

    boolean : bool, optional
        Bool(optional, default false) if set to true, output of scale
        is mane dimensionless

    Examples
    --------
    >>> op = dpf.operators.Scale()
    >>> op.inputs.boolean.connect(my_boolean)  # optional
    >>> op.inputs.ponderation.connect(my_ponderation)
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='Double/Field scoped on overall', ellipsis=False, name='ponderation', optional=False, type_names=['double', 'field'])), (2, InputSpec(document='bool(optional, default false) if set to true, output of scale is mane dimensionless', ellipsis=False, name='boolean', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._field = None
            self._ponderation = None
            self._boolean = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def ponderation(self):
            """Double/Field scoped on overall"""
            return self._ponderation

        @ponderation.setter
        def ponderation(self, ponderation):
            self._ponderation.connect(ponderation)

        @property
        def boolean(self):
            """bool(optional, default false) if set to true, output of scale is mane dimensionless"""
            return self._boolean

        @boolean.setter
        def boolean(self, boolean):
            self._boolean.connect(boolean)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, ponderation, boolean=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scale"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class PowFc(dpf.Operator):
    """DPF "Pow_fc" Operator

    Computes element-wise field[i]^p.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``factor`` : float


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    factor : float




    Examples
    --------
    >>> op = dpf.operators.PowFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.factor.connect(my_factor)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='factor', optional=False, type_names=['double']))])
        def __init__(self, oper):
            self._fields_container = None
            self._factor = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def factor(self):
            return self._factor

        @factor.setter
        def factor(self, factor):
            self._factor.connect(factor)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, factor):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "Pow_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ScaleFc(dpf.Operator):
    """DPF "scale_fc" Operator

    Scales a field by a constant factor.

    Available inputs:
     -   ``ponderation`` : float, Field
         Double/field scoped on overall

     -   ``boolean`` : B, optional
         Bool(optional, default false) if set to true, output of scale is mane
         dimensionless

     -   ``fields_container`` : FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field or fields container with only one field is expected

    ponderation : float or Field
        Double/field scoped on overall

    boolean : bool, optional
        Bool(optional, default false) if set to true, output of scale
        is mane dimensionless

    Examples
    --------
    >>> op = dpf.operators.ScaleFc()
    >>> op.inputs.ponderation.connect(my_ponderation)
    >>> op.inputs.boolean.connect(my_boolean)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Double/Field scoped on overall', ellipsis=False, name='ponderation', optional=False, type_names=['double', 'field'])), (2, InputSpec(document='bool(optional, default false) if set to true, output of scale is mane dimensionless', ellipsis=False, name='boolean', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._ponderation = None
            self._boolean = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """field or fields container with only one field is expected"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def ponderation(self):
            """Double/Field scoped on overall"""
            return self._ponderation

        @ponderation.setter
        def ponderation(self, ponderation):
            self._ponderation.connect(ponderation)

        @property
        def boolean(self):
            """bool(optional, default false) if set to true, output of scale is mane dimensionless"""
            return self._boolean

        @boolean.setter
        def boolean(self, boolean):
            self._boolean.connect(boolean)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, ponderation, boolean=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scale_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class SweepingPhase(dpf.Operator):
    """DPF "sweeping_phase" Operator

    Shift the phase of a real and an imaginary fields (in 0 and 1) of
    a given angle (in 3) of unit (in 4).

    Available inputs:
     -   ``abs_value`` : B

     -   ``imaginary_field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``unit_name`` : str
         String unit

     -   ``imaginary_part_null`` : B
         If the imaginary part field is empty and this pin is true, then the
         imaginary part is supposed to be 0 (default is false)

     -   ``real_field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``angle`` : float


    Available outputs:
     -   field


    Parameters
    ----------
    real_field : Field or FieldsContainer
        Field or fields container with only one field is expected

    imaginary_field : Field or FieldsContainer
        Field or fields container with only one field is expected

    angle : float


    unit_name : str
        String unit

    abs_value : bool


    imaginary_part_null : bool
        If the imaginary part field is empty and this pin is true,
        then the imaginary part is supposed to be 0 (default is false)



    Examples
    --------
    >>> op = dpf.operators.SweepingPhase()
    >>> op.inputs.abs_value.connect(my_abs_value)
    >>> op.inputs.imaginary_field.connect(my_imaginary_field)
    >>> op.inputs.unit_name.connect(my_unit_name)
    >>> op.inputs.imaginary_part_null.connect(my_imaginary_part_null)
    >>> op.inputs.real_field.connect(my_real_field)
    >>> op.inputs.angle.connect(my_angle)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='real_field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='imaginary_field', optional=False, type_names=['field', 'fields_container'])), (2, InputSpec(document='', ellipsis=False, name='angle', optional=False, type_names=['double'])), (3, InputSpec(document='String Unit', ellipsis=False, name='unit_name', optional=False, type_names=['string'])), (4, InputSpec(document='', ellipsis=False, name='abs_value', optional=False, type_names=['b'])), (5, InputSpec(document='if the imaginary part field is empty and this pin is true, then the imaginary part is supposed to be 0 (default is false)', ellipsis=False, name='imaginary_part_null', optional=False, type_names=['b']))])
        def __init__(self, oper):
            self._real_field = None
            self._imaginary_field = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._imaginary_part_null = None
            super().__init__(self._spec, oper)

        @property
        def real_field(self):
            """field or fields container with only one field is expected"""
            return self._real_field

        @real_field.setter
        def real_field(self, real_field):
            self._real_field.connect(real_field)

        @property
        def imaginary_field(self):
            """field or fields container with only one field is expected"""
            return self._imaginary_field

        @imaginary_field.setter
        def imaginary_field(self, imaginary_field):
            self._imaginary_field.connect(imaginary_field)

        @property
        def angle(self):
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """String Unit"""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def imaginary_part_null(self):
            """if the imaginary part field is empty and this pin is true, then the imaginary part is supposed to be 0 (default is false)"""
            return self._imaginary_part_null

        @imaginary_part_null.setter
        def imaginary_part_null(self, imaginary_part_null):
            self._imaginary_part_null.connect(imaginary_part_null)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, real_field, imaginary_field, angle, unit_name, abs_value, imaginary_part_null):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "sweeping_phase"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Centroid(dpf.Operator):
    """DPF "centroid" Operator

    Computes centroid of field1 and field2, using fieldOut =
    field1*(1.-fact)+field2*(fact).

    Available inputs:
     -   ``factor`` : float
         Scalar

     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected

    factor : float
        Scalar



    Examples
    --------
    >>> op = dpf.operators.Centroid()
    >>> op.inputs.factor.connect(my_factor)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container'])), (2, InputSpec(document='Scalar', ellipsis=False, name='factor', optional=False, type_names=['double']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            self._factor = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)

        @property
        def factor(self):
            """Scalar"""
            return self._factor

        @factor.setter
        def factor(self, factor):
            self._factor.connect(factor)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB, factor):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "centroid"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Sin(dpf.Operator):
    """DPF "sin" Operator

    Computes element-wise sin(field[i]).

    Available inputs:
     -   ``field`` : Field


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field




    Examples
    --------
    >>> op = dpf.operators.Sin()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='field', optional=False, type_names=['field']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "sin"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Cos(dpf.Operator):
    """DPF "cos" Operator

    Computes element-wise cos(field[i]).

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Cos()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cos"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class CosFc(dpf.Operator):
    """DPF "cos_fc" Operator

    Computes element-wise cos(field[i]).

    Available inputs:
     -   ``fields_container`` : FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.CosFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """field or fields container with only one field is expected"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cos_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class SweepingPhaseFc(dpf.Operator):
    """DPF "sweeping_phase_fc" Operator

    Shift the phase of all the corresponding real and imaginary fields
    of a fields container for a given angle (in 2) of unit (in 4).

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``abs_value`` : B

     -   ``angle`` : float

     -   ``unit_name`` : str
         String unit


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float


    unit_name : str
        String unit

    abs_value : bool




    Examples
    --------
    >>> op = dpf.operators.SweepingPhaseFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.abs_value.connect(my_abs_value)
    >>> op.inputs.angle.connect(my_angle)
    >>> op.inputs.unit_name.connect(my_unit_name)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (2, InputSpec(document='', ellipsis=False, name='angle', optional=False, type_names=['double'])), (3, InputSpec(document='String Unit', ellipsis=False, name='unit_name', optional=False, type_names=['string'])), (4, InputSpec(document='', ellipsis=False, name='abs_value', optional=False, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """String Unit"""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, angle, unit_name, abs_value):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "sweeping_phase_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Sqr(dpf.Operator):
    """DPF "sqr" Operator

    Computes element-wise field[i]^2.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Sqr()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "sqr"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class LinearCombination(dpf.Operator):
    """DPF "CplxOp" Operator

    Computes aXY + bZ where a,b (in 0, in 3) are scalar and X,Y,Z (in
    1,2,4) are complex numbers.

    Available inputs:
     -   ``fields_containerB`` : FieldsContainer

     -   ``b`` : float
         Double

     -   ``a`` : float
         Double

     -   ``fields_containerA`` : FieldsContainer

     -   ``fields_containerC`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    a : float
        Double

    fields_containerA : FieldsContainer


    fields_containerB : FieldsContainer


    b : float
        Double

    fields_containerC : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.LinearCombination()
    >>> op.inputs.fields_containerB.connect(my_fields_containerB)
    >>> op.inputs.b.connect(my_b)
    >>> op.inputs.a.connect(my_a)
    >>> op.inputs.fields_containerA.connect(my_fields_containerA)
    >>> op.inputs.fields_containerC.connect(my_fields_containerC)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='Double', ellipsis=False, name='a', optional=False, type_names=['double'])), (1, InputSpec(document='', ellipsis=False, name='fields_containerA', optional=False, type_names=['fields_container'])), (2, InputSpec(document='', ellipsis=False, name='fields_containerB', optional=False, type_names=['fields_container'])), (3, InputSpec(document='Double', ellipsis=False, name='b', optional=False, type_names=['double'])), (4, InputSpec(document='', ellipsis=False, name='fields_containerC', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._a = None
            self._fields_containerA = None
            self._fields_containerB = None
            self._b = None
            self._fields_containerC = None
            super().__init__(self._spec, oper)

        @property
        def a(self):
            """Double"""
            return self._a

        @a.setter
        def a(self, a):
            self._a.connect(a)

        @property
        def fields_containerA(self):
            return self._fields_containerA

        @fields_containerA.setter
        def fields_containerA(self, fields_containerA):
            self._fields_containerA.connect(fields_containerA)

        @property
        def fields_containerB(self):
            return self._fields_containerB

        @fields_containerB.setter
        def fields_containerB(self, fields_containerB):
            self._fields_containerB.connect(fields_containerB)

        @property
        def b(self):
            """Double"""
            return self._b

        @b.setter
        def b(self, b):
            self._b.connect(b)

        @property
        def fields_containerC(self):
            return self._fields_containerC

        @fields_containerC.setter
        def fields_containerC(self, fields_containerC):
            self._fields_containerC.connect(fields_containerC)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, a, fields_containerA, fields_containerB, b, fields_containerC):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "CplxOp"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class SqrFc(dpf.Operator):
    """DPF "sqr_fc" Operator

    Computes element-wise field[i]^2.

    Available inputs:
     -   ``fields_container`` : FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.SqrFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """field or fields container with only one field is expected"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "sqr_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Sqrt(dpf.Operator):
    """DPF "sqrt" Operator

    Computes element-wise sqrt(field1).

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Sqrt()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "sqrt"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Norm(dpf.Operator):
    """DPF "norm" Operator

    Computes the element-wise L2 norm of the field elementary data.

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Norm()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "norm"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class SqrtFc(dpf.Operator):
    """DPF "sqrt_fc" Operator

    Computes element-wise sqrt(field1).

    Available inputs:
     -   ``fields_container`` : FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.SqrtFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """field or fields container with only one field is expected"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "sqrt_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class NormFc(dpf.Operator):
    """DPF "norm_fc" Operator

    Computes the element-wise L2 norm of the field elementary data.
    This process is applied on eah field of the input fields
    container.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.NormFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "norm_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ComponentWiseDivide(dpf.Operator):
    """DPF "component_wise_divide" Operator

    Computes component-wise fraction between two fields of same
    dimensionality. If one field's scoping has overall location, then
    these field's values are applied on the entire other field.

    Available inputs:
     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.ComponentWiseDivide()
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "component_wise_divide"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ComponentWiseDivideFc(dpf.Operator):
    """DPF "component_wise_divide_fc" Operator

    For every two fields with the same label space (from the two input
    fields containers), computes component-wise fraction between two
    fields of same dimensionality. If one field's scoping has overall
    location, then these field's values are applied on the entire
    other field.

    Available inputs:
     -   ``fields_containerA`` : FieldsContainer

     -   ``fields_containerB`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_containerA : FieldsContainer


    fields_containerB : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.ComponentWiseDivideFc()
    >>> op.inputs.fields_containerA.connect(my_fields_containerA)
    >>> op.inputs.fields_containerB.connect(my_fields_containerB)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_containerA', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='fields_containerB', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_containerA = None
            self._fields_containerB = None
            super().__init__(self._spec, oper)

        @property
        def fields_containerA(self):
            return self._fields_containerA

        @fields_containerA.setter
        def fields_containerA(self, fields_containerA):
            self._fields_containerA.connect(fields_containerA)

        @property
        def fields_containerB(self):
            return self._fields_containerB

        @fields_containerB.setter
        def fields_containerB(self, fields_containerB):
            self._fields_containerB.connect(fields_containerB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_containerA, fields_containerB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "component_wise_divide_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class KroneckerProd(dpf.Operator):
    """DPF "kronecker_prod" Operator

    Computes element-wise Kronecker product between two tensor fields.

    Available inputs:
     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.KroneckerProd()
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "kronecker_prod"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class RealPart(dpf.Operator):
    """DPF "realP_part" Operator

    Extracts element-wise real part of field containers containing
    complex fields.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.RealPart()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "realP_part"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Conjugate(dpf.Operator):
    """DPF "conjugate" Operator

    Computes element-wise conjugate of field containers containing
    complex fields.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.Conjugate()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "conjugate"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class ImgPart(dpf.Operator):
    """DPF "img_part" Operator

    Extracts element-wise imaginary part of field containers
    containing complex fields.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.ImgPart()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "img_part"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Amplitude(dpf.Operator):
    """DPF "amplitude" Operator

    Computes amplitude of a real and an imaginary field.

    Available inputs:
     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Amplitude()
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "amplitude"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class CplxAdd(dpf.Operator):
    """DPF "cplx_add" Operator

    Computes addition between two field containers containing complex
    fields.

    Available inputs:
     -   ``fields_containerA`` : FieldsContainer

     -   ``fields_containerB`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_containerA : FieldsContainer


    fields_containerB : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.CplxAdd()
    >>> op.inputs.fields_containerA.connect(my_fields_containerA)
    >>> op.inputs.fields_containerB.connect(my_fields_containerB)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_containerA', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='fields_containerB', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_containerA = None
            self._fields_containerB = None
            super().__init__(self._spec, oper)

        @property
        def fields_containerA(self):
            return self._fields_containerA

        @fields_containerA.setter
        def fields_containerA(self, fields_containerA):
            self._fields_containerA.connect(fields_containerA)

        @property
        def fields_containerB(self):
            return self._fields_containerB

        @fields_containerB.setter
        def fields_containerB(self, fields_containerB):
            self._fields_containerB.connect(fields_containerB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_containerA, fields_containerB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cplx_add"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class CplxDot(dpf.Operator):
    """DPF "cplx_dot" Operator

    Computes product between two field containers containing complex
    fields.

    Available inputs:
     -   ``fields_containerB`` : FieldsContainer

     -   ``fields_containerA`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_containerA : FieldsContainer


    fields_containerB : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.CplxDot()
    >>> op.inputs.fields_containerB.connect(my_fields_containerB)
    >>> op.inputs.fields_containerA.connect(my_fields_containerA)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_containerA', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='fields_containerB', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_containerA = None
            self._fields_containerB = None
            super().__init__(self._spec, oper)

        @property
        def fields_containerA(self):
            return self._fields_containerA

        @fields_containerA.setter
        def fields_containerA(self, fields_containerA):
            self._fields_containerA.connect(fields_containerA)

        @property
        def fields_containerB(self):
            return self._fields_containerB

        @fields_containerB.setter
        def fields_containerB(self, fields_containerB):
            self._fields_containerB.connect(fields_containerB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_containerA, fields_containerB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cplx_dot"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class CplxDivide(dpf.Operator):
    """DPF "cplx_divide" Operator

    Computes division between two field containers containing complex
    fields.

    Available inputs:
     -   ``fields_containerA`` : FieldsContainer

     -   ``fields_containerB`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_containerA : FieldsContainer


    fields_containerB : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.CplxDivide()
    >>> op.inputs.fields_containerA.connect(my_fields_containerA)
    >>> op.inputs.fields_containerB.connect(my_fields_containerB)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_containerA', optional=False, type_names=['fields_container'])), (1, InputSpec(document='', ellipsis=False, name='fields_containerB', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_containerA = None
            self._fields_containerB = None
            super().__init__(self._spec, oper)

        @property
        def fields_containerA(self):
            return self._fields_containerA

        @fields_containerA.setter
        def fields_containerA(self, fields_containerA):
            self._fields_containerA.connect(fields_containerA)

        @property
        def fields_containerB(self):
            return self._fields_containerB

        @fields_containerB.setter
        def fields_containerB(self, fields_containerB):
            self._fields_containerB.connect(fields_containerB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_containerA, fields_containerB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cplx_divide"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Dot(dpf.Operator):
    """DPF "dot" Operator

    Computes element-wise dot product between two vector fields. If
    one field's scoping has 'overall' location, then these field's
    values are applied on the entire other field.

    Available inputs:
     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Dot()
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "dot"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class CplxDerive(dpf.Operator):
    """DPF "cplx_derive" Operator

    Derive field containers containing complex fields.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.CplxDerive()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "cplx_derive"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class PolarToCplx(dpf.Operator):
    """DPF "polar_to_cplx" Operator

    Convert complex number from polar form to complex.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.PolarToCplx()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "polar_to_cplx"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class Modulus(dpf.Operator):
    """DPF "modulus" Operator

    Computes element-wise modulus of field containers containing
    complex fields.

    Available inputs:
     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer




    Examples
    --------
    >>> op = dpf.operators.Modulus()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container']))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "modulus"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class MinMaxOverTime(dpf.Operator):
    """DPF "min_max_over_time" Operator

    Evaluates minimum/maximum over time/frequency.

    Available inputs:
     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``fields_container`` : FieldsContainer

     -   ``int32`` : int
         Define min or max.

     -   ``abs_value`` : B, optional
         Should use absolute value.

     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    int32 : int
        Define min or max.

    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    >>> op = dpf.operators.MinMaxOverTime()
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.int32.connect(my_int32)
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b'])), (5, InputSpec(document='Define min or max.', ellipsis=False, name='int32', optional=False, type_names=['int32']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            self._int32 = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)

        @property
        def int32(self):
            """Define min or max."""
            return self._int32

        @int32.setter
        def int32(self, int32):
            self._int32.connect(int32)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, int32, angle=None, unit_name=None, abs_value=None, compute_amplitude=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_max_over_time"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Accumulate(dpf.Operator):
    """DPF "accumulate" Operator

    Sum all the elementary data of a field to get one elementary data
    at the end.

    Available inputs:
     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Accumulate()
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "accumulate"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class GeneralizedInnerProduct(dpf.Operator):
    """DPF "generalized_inner_product" Operator

    Computes a general notion of inner product between two fields of
    possibly different dimensionality.

    Available inputs:
     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.GeneralizedInnerProduct()
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "generalized_inner_product"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class OverallDot(dpf.Operator):
    """DPF "native::overall_dot" Operator

    Compute a sdot product between two fields and return a scalar.

    Available inputs:
     -   ``FieldA`` : Field

     -   ``FieldB`` : Field


    Available outputs:
     -   field


    Parameters
    ----------
    FieldA : Field


    FieldB : Field




    Examples
    --------
    >>> op = dpf.operators.OverallDot()
    >>> op.inputs.FieldA.connect(my_FieldA)
    >>> op.inputs.FieldB.connect(my_FieldB)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='FieldA', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='FieldB', optional=False, type_names=['field']))])
        def __init__(self, oper):
            self._FieldA = None
            self._FieldB = None
            super().__init__(self._spec, oper)

        @property
        def FieldA(self):
            return self._FieldA

        @FieldA.setter
        def FieldA(self, FieldA):
            self._FieldA.connect(FieldA)

        @property
        def FieldB(self):
            return self._FieldB

        @FieldB.setter
        def FieldB(self, FieldB):
            self._FieldB.connect(FieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document='Field defined on over-all location, contains a unique scalar value'))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """Field defined on over-all location, contains a unique scalar value"""
            return self._field


    def __init__(self, FieldA, FieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "native::overall_dot"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """Field defined on over-all location, contains a unique scalar value"""
        return self.outputs._field



class MaxOverTime(dpf.Operator):
    """DPF "max_over_time" Operator

    Evaluates maximum over time/frequency.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.

     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``abs_value`` : B, optional
         Should use absolute value.


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    >>> op = dpf.operators.MaxOverTime()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, angle=None, unit_name=None, abs_value=None, compute_amplitude=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "max_over_time"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class TimeOfMax(dpf.Operator):
    """DPF "time_of_max" Operator

    Evaluates time/frequency of maximum.

    Available inputs:
     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.

     -   ``abs_value`` : B, optional
         Should use absolute value.

     -   ``fields_container`` : FieldsContainer

     -   ``angle`` : float, optional
         Phase angle used for complex field container


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    >>> op = dpf.operators.TimeOfMax()
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, angle=None, unit_name=None, abs_value=None, compute_amplitude=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "time_of_max"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class MinOverTime(dpf.Operator):
    """DPF "min_over_time" Operator

    Evaluates minimum over time/frequency.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.

     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``abs_value`` : B, optional
         Should use absolute value.


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    >>> op = dpf.operators.MinOverTime()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, angle=None, unit_name=None, abs_value=None, compute_amplitude=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_over_time"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class DotTensor(dpf.Operator):
    """DPF "dot_tensor" Operator

    Computes element-wise dot product between two tensor fields.

    Available inputs:
     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.DotTensor()
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "dot_tensor"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ScaleByField(dpf.Operator):
    """DPF "scale_by_field" Operator

    Scales a field (in 0) by a scalar field (in 1). If one field's
    scoping has 'overall' location, then these field's values are
    applied on the entire other field.

    Available inputs:
     -   ``fieldB`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``fieldA`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    fieldA : Field or FieldsContainer
        Field or fields container with only one field is expected

    fieldB : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.ScaleByField()
    >>> op.inputs.fieldB.connect(my_fieldB)
    >>> op.inputs.fieldA.connect(my_fieldA)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldA', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fieldB', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._fieldA = None
            self._fieldB = None
            super().__init__(self._spec, oper)

        @property
        def fieldA(self):
            """field or fields container with only one field is expected"""
            return self._fieldA

        @fieldA.setter
        def fieldA(self, fieldA):
            self._fieldA.connect(fieldA)

        @property
        def fieldB(self):
            """field or fields container with only one field is expected"""
            return self._fieldB

        @fieldB.setter
        def fieldB(self, fieldB):
            self._fieldB.connect(fieldB)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fieldA, fieldB):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scale_by_field"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Invert(dpf.Operator):
    """DPF "invert" Operator

    Compute the element-wise, component-wise, inverse of a field
    (1./x)

    Available inputs:
     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected



    Examples
    --------
    >>> op = dpf.operators.Invert()
    >>> op.inputs.field.connect(my_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container']))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "invert"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



