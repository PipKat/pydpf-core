"""Autogenerated DPF operator classes.

Created on 01/04/2021, 09:21:00
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class TimeOfMin(dpf.Operator):
    """DPF "time_of_min" Operator

    Evaluates time/frequency of minimum.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``abs_value`` : B, optional
         Should use absolute value.

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.TimeOfMin(my_fields_container,
                                     my_angle, # optional
                                     my_unit_name, # optional
                                     my_abs_value, # optional
                                     my_compute_amplitude)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.TimeOfMin()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, angle=None, unit_name=None, abs_value=None, compute_amplitude=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "time_of_min"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class PhaseOfMax(dpf.Operator):
    """DPF "phase_of_max" Operator

    Evaluates phase of maximum.

    Available inputs:
     -   ``imaginary_field`` : Field

     -   ``abs_value`` : B, optional
         Should use absolute value.

     -   ``phase_increment`` : float
         Phase increment.

     -   ``real_field`` : Field


    Available outputs:
     -   field


    Parameters
    ----------
    real_field : Field


    imaginary_field : Field


    phase_increment : float
        Phase increment.

    abs_value : bool, optional
        Should use absolute value.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.PhaseOfMax(my_real_field,
                                      my_imaginary_field,
                                      my_phase_increment,
                                      my_abs_value)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.PhaseOfMax()
    >>> op.inputs.imaginary_field.connect(my_imaginary_field)
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> op.inputs.phase_increment.connect(my_phase_increment)
    >>> op.inputs.real_field.connect(my_real_field)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='real_field', optional=False, type_names=['field'])), (1, InputSpec(document='', ellipsis=False, name='imaginary_field', optional=False, type_names=['field'])), (2, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (3, InputSpec(document='Phase increment.', ellipsis=False, name='phase_increment', optional=False, type_names=['double']))])
        def __init__(self, oper):
            self._real_field = None
            self._imaginary_field = None
            self._abs_value = None
            self._phase_increment = None
            super().__init__(self._spec, oper)

        @property
        def real_field(self):
            return self._real_field

        @real_field.setter
        def real_field(self, real_field):
            self._real_field.connect(real_field)

        @property
        def imaginary_field(self):
            return self._imaginary_field

        @imaginary_field.setter
        def imaginary_field(self, imaginary_field):
            self._imaginary_field.connect(imaginary_field)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def phase_increment(self):
            """Phase increment."""
            return self._phase_increment

        @phase_increment.setter
        def phase_increment(self, phase_increment):
            self._phase_increment.connect(phase_increment)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, real_field, imaginary_field, phase_increment, abs_value=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "phase_of_max"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class Scale(dpf.Operator):
    """DPF "scale" Operator

    Scales a field by a constant factor.

    Available inputs:
     -   ``boolean`` : B, optional
         Bool(optional, default false) if set to true, output of scale is mane
         dimensionless

     -   ``field`` : Field, FieldsContainer
         Field or fields container with only one field is expected

     -   ``ponderation`` : float, Field
         Double/field scoped on overall


    Available outputs:
     -   field


    Parameters
    ----------
    field : Field or FieldsContainer
        Field or fields container with only one field is expected

    ponderation : float or Field
        Double/field scoped on overall

    boolean : bool, optional
        Bool(optional, default false) if set to true, output of scale
        is mane dimensionless

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.Scale(my_field,
                                 my_ponderation,
                                 my_boolean)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.Scale()
    >>> op.inputs.boolean.connect(my_boolean)  # optional
    >>> op.inputs.field.connect(my_field)
    >>> op.inputs.ponderation.connect(my_ponderation)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='field', optional=False, type_names=['field', 'fields_container'])), (1, InputSpec(document='Double/Field scoped on overall', ellipsis=False, name='ponderation', optional=False, type_names=['double', 'field'])), (2, InputSpec(document='bool(optional, default false) if set to true, output of scale is mane dimensionless', ellipsis=False, name='boolean', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._field = None
            self._ponderation = None
            self._boolean = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """field or fields container with only one field is expected"""
            return self._field

        @field.setter
        def field(self, field):
            self._field.connect(field)

        @property
        def ponderation(self):
            """Double/Field scoped on overall"""
            return self._ponderation

        @ponderation.setter
        def ponderation(self, ponderation):
            self._ponderation.connect(ponderation)

        @property
        def boolean(self):
            """bool(optional, default false) if set to true, output of scale is mane dimensionless"""
            return self._boolean

        @boolean.setter
        def boolean(self, boolean):
            self._boolean.connect(boolean)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, field, ponderation, boolean=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scale"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class ScaleFc(dpf.Operator):
    """DPF "scale_fc" Operator

    Scales a field by a constant factor.

    Available inputs:
     -   ``fields_container`` : FieldsContainer
         Field or fields container with only one field is expected

     -   ``ponderation`` : float, Field
         Double/field scoped on overall

     -   ``boolean`` : B, optional
         Bool(optional, default false) if set to true, output of scale is mane
         dimensionless


    Available outputs:
     -   fields_container


    Parameters
    ----------
    fields_container : FieldsContainer
        Field or fields container with only one field is expected

    ponderation : float or Field
        Double/field scoped on overall

    boolean : bool, optional
        Bool(optional, default false) if set to true, output of scale
        is mane dimensionless

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.ScaleFc(my_fields_container,
                                   my_ponderation,
                                   my_boolean)  # optional
    >>> my_fields_container = op.fields_container

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.ScaleFc()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.ponderation.connect(my_ponderation)
    >>> op.inputs.boolean.connect(my_boolean)  # optional
    >>> my_fields_container = op.outputs.fields_container()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='field or fields container with only one field is expected', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Double/Field scoped on overall', ellipsis=False, name='ponderation', optional=False, type_names=['double', 'field'])), (2, InputSpec(document='bool(optional, default false) if set to true, output of scale is mane dimensionless', ellipsis=False, name='boolean', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._ponderation = None
            self._boolean = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """field or fields container with only one field is expected"""
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def ponderation(self):
            """Double/Field scoped on overall"""
            return self._ponderation

        @ponderation.setter
        def ponderation(self, ponderation):
            self._ponderation.connect(ponderation)

        @property
        def boolean(self):
            """bool(optional, default false) if set to true, output of scale is mane dimensionless"""
            return self._boolean

        @boolean.setter
        def boolean(self, boolean):
            self._boolean.connect(boolean)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='fields_container', type_names=['fields_container'], document=''))])
        def __init__(self, oper):
            self._fields_container = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            """"""
            return self._fields_container


    def __init__(self, fields_container, ponderation, boolean=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scale_fc"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def fields_container(self):
        """"""
        return self.outputs._fields_container



class MinMaxOverTime(dpf.Operator):
    """DPF "min_max_over_time" Operator

    Evaluates minimum/maximum over time/frequency.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``abs_value`` : B, optional
         Should use absolute value.

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.

     -   ``int32`` : int
         Define min or max.


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    int32 : int
        Define min or max.

    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.MinMaxOverTime(my_fields_container,
                                          my_int32,
                                          my_angle, # optional
                                          my_unit_name, # optional
                                          my_abs_value, # optional
                                          my_compute_amplitude)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.MinMaxOverTime()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> op.inputs.int32.connect(my_int32)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b'])), (5, InputSpec(document='Define min or max.', ellipsis=False, name='int32', optional=False, type_names=['int32']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            self._int32 = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)

        @property
        def int32(self):
            """Define min or max."""
            return self._int32

        @int32.setter
        def int32(self, int32):
            self._int32.connect(int32)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, int32, angle=None, unit_name=None, abs_value=None, compute_amplitude=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_max_over_time"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class MaxOverTime(dpf.Operator):
    """DPF "max_over_time" Operator

    Evaluates maximum over time/frequency.

    Available inputs:
     -   ``fields_container`` : FieldsContainer

     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``abs_value`` : B, optional
         Should use absolute value.

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.MaxOverTime(my_fields_container,
                                       my_angle, # optional
                                       my_unit_name, # optional
                                       my_abs_value, # optional
                                       my_compute_amplitude)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.MaxOverTime()
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, angle=None, unit_name=None, abs_value=None, compute_amplitude=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "max_over_time"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class TimeOfMax(dpf.Operator):
    """DPF "time_of_max" Operator

    Evaluates time/frequency of maximum.

    Available inputs:
     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.

     -   ``fields_container`` : FieldsContainer

     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``abs_value`` : B, optional
         Should use absolute value.


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.TimeOfMax(my_fields_container,
                                     my_angle, # optional
                                     my_unit_name, # optional
                                     my_abs_value, # optional
                                     my_compute_amplitude)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.TimeOfMax()
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, angle=None, unit_name=None, abs_value=None, compute_amplitude=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "time_of_max"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



class MinOverTime(dpf.Operator):
    """DPF "min_over_time" Operator

    Evaluates minimum over time/frequency.

    Available inputs:
     -   ``angle`` : float, optional
         Phase angle used for complex field container

     -   ``unit_name`` : str, optional
         Phase angle unit. default is radian.

     -   ``abs_value`` : B, optional
         Should use absolute value.

     -   ``compute_amplitude`` : B, optional
         Do calculate amplitude.

     -   ``fields_container`` : FieldsContainer


    Available outputs:
     -   field


    Parameters
    ----------
    fields_container : FieldsContainer


    angle : float, optional
        Phase angle used for complex field container

    unit_name : str, optional
        Phase angle unit. default is radian.

    abs_value : bool, optional
        Should use absolute value.

    compute_amplitude : bool, optional
        Do calculate amplitude.

    Examples
    --------
    Create the operator

    >>> op = dpf.operators.MinOverTime(my_fields_container,
                                       my_angle, # optional
                                       my_unit_name, # optional
                                       my_abs_value, # optional
                                       my_compute_amplitude)  # optional
    >>> my_field = op.field

    Alternative: Connect operator using Inputs and Outputs

    >>> op = dpf.operators.MinOverTime()
    >>> op.inputs.angle.connect(my_angle)  # optional
    >>> op.inputs.unit_name.connect(my_unit_name)  # optional
    >>> op.inputs.abs_value.connect(my_abs_value)  # optional
    >>> op.inputs.compute_amplitude.connect(my_compute_amplitude)  # optional
    >>> op.inputs.fields_container.connect(my_fields_container)
    >>> my_field = op.outputs.field()
    """

    class _Inputs(dpf.inputs.Inputs):
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='fields_container', optional=False, type_names=['fields_container'])), (1, InputSpec(document='Phase angle used for complex field container', ellipsis=False, name='angle', optional=True, type_names=['double'])), (2, InputSpec(document='Phase angle unit. Default is radian.', ellipsis=False, name='unit_name', optional=True, type_names=['string'])), (3, InputSpec(document='Should use absolute value.', ellipsis=False, name='abs_value', optional=True, type_names=['b'])), (4, InputSpec(document='Do calculate amplitude.', ellipsis=False, name='compute_amplitude', optional=True, type_names=['b']))])
        def __init__(self, oper):
            self._fields_container = None
            self._angle = None
            self._unit_name = None
            self._abs_value = None
            self._compute_amplitude = None
            super().__init__(self._spec, oper)

        @property
        def fields_container(self):
            return self._fields_container

        @fields_container.setter
        def fields_container(self, fields_container):
            self._fields_container.connect(fields_container)

        @property
        def angle(self):
            """Phase angle used for complex field container"""
            return self._angle

        @angle.setter
        def angle(self, angle):
            self._angle.connect(angle)

        @property
        def unit_name(self):
            """Phase angle unit. Default is radian."""
            return self._unit_name

        @unit_name.setter
        def unit_name(self, unit_name):
            self._unit_name.connect(unit_name)

        @property
        def abs_value(self):
            """Should use absolute value."""
            return self._abs_value

        @abs_value.setter
        def abs_value(self, abs_value):
            self._abs_value.connect(abs_value)

        @property
        def compute_amplitude(self):
            """Do calculate amplitude."""
            return self._compute_amplitude

        @compute_amplitude.setter
        def compute_amplitude(self, compute_amplitude):
            self._compute_amplitude.connect(compute_amplitude)


    class _Outputs(dpf.outputs.Outputs):
        _spec = OrderedDict([(0, OutputSpec(name='field', type_names=['field'], document=''))])
        def __init__(self, oper):
            self._field = None
            super().__init__(self._spec, oper)

        @property
        def field(self):
            """"""
            return self._field


    def __init__(self, fields_container, angle=None, unit_name=None, abs_value=None, compute_amplitude=None, channel=None):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "min_over_time"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def field(self):
        """"""
        return self.outputs._field



