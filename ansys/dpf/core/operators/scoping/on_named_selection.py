"""Autogenerated DPF operator classes.

Created on 10/06/2021, 13:12:29
"""
from collections import OrderedDict
from collections import namedtuple
from ansys.dpf import core as dpf

InputSpec = namedtuple('InputSpec', ['document', 'ellipsis', 'name', 'optional',
                                     'type_names'])

OutputSpec = namedtuple('OutputSpec', ['name', 'type_names', 'document'])


class OnNamedSelection(dpf.Operator):
    """DPF "scoping_provider_by_ns" Operator

    provides a scoping at a given location based on a given named
    selection

    Available inputs:
     -   requested_location : str
     -   streams_container : StreamsContainer, optional
     -   int_inclusive : int, optional
         If element scoping is requested on a nodal named selection,
         if inclusive == 1 then add all the elements adjacent to the
         nodes.if inclusive == 0, only the elements which have all
         their nodes in the named selection are included
     -   data_sources : DataSources
     -   named_selection_name : str
         The string is expected to be in upper case
    Available outputs:
     -   mesh_scoping


    Parameters
    ----------
    requested_location : str


    named_selection_name : str
        The string is expected to be in upper case

    data_sources : DataSources


    int_inclusive : int, optional
        If element scoping is requested on a nodal named selection, if
        inclusive == 1 then add all the elements adjacent to the
        nodes.if inclusive == 0, only the elements which have all
        their nodes in the named selection are included

    streams_container : streams_container, optional


    Examples
    --------
    >>> op = dpf.operators.OnNamedSelection()
    >>> op.inputs.requested_location.connect(my_requested_location)
    >>> op.inputs.streams_container.connect(my_streams_container)  # optional
    >>> op.inputs.int_inclusive.connect(my_int_inclusive)  # optional
    >>> op.inputs.data_sources.connect(my_data_sources)
    >>> op.inputs.named_selection_name.connect(my_named_selection_name)
    >>> my_mesh_scoping = op.outputs.mesh_scoping()
    """  # noqa: E501

    class _Inputs(dpf.inputs.Inputs):

        # fmt: off
        _spec = OrderedDict([(0, InputSpec(document='', ellipsis=False, name='requested_location', optional=False, type_names=['string'])), (1, InputSpec(document='the string is expected to be in upper case', ellipsis=False, name='named_selection_name', optional=False, type_names=['string'])), (2, InputSpec(document='If element scoping is requested on a nodal named selection, if Inclusive == 1 then add all the elements adjacent to the nodes.If Inclusive == 0, only the elements which have all their nodes in the named selection are included', ellipsis=False, name='int_inclusive', optional=True, type_names=['int32'])), (3, InputSpec(document='', ellipsis=False, name='streams_container', optional=True, type_names=['streams_container'])), (4, InputSpec(document='', ellipsis=False, name='data_sources', optional=False, type_names=['data_sources']))]) # noqa: E501
        # fmt: on

        def __init__(self, oper):
            self._requested_location = None
            self._named_selection_name = None
            self._int_inclusive = None
            self._streams_container = None
            self._data_sources = None
            super().__init__(self._spec, oper)

        @property
        def requested_location(self):
            return self._requested_location

        @requested_location.setter
        def requested_location(self, requested_location):
            self._requested_location.connect(requested_location)

        @property
        def named_selection_name(self):
            """the string is expected to be in upper case"""
            return self._named_selection_name

        @named_selection_name.setter
        def named_selection_name(self, named_selection_name):
            self._named_selection_name.connect(named_selection_name)

        @property
        def int_inclusive(self):
            """If element scoping is requested on a nodal named
            selection, if Inclusive == 1 then add all the elements
            adjacent to the nodes.If Inclusive == 0, only the
            elements which have all their nodes in the named
            selection are included"""
            return self._int_inclusive

        @int_inclusive.setter
        def int_inclusive(self, int_inclusive):
            self._int_inclusive.connect(int_inclusive)

        @property
        def streams_container(self):
            return self._streams_container

        @streams_container.setter
        def streams_container(self, streams_container):
            self._streams_container.connect(streams_container)

        @property
        def data_sources(self):
            return self._data_sources

        @data_sources.setter
        def data_sources(self, data_sources):
            self._data_sources.connect(data_sources)

    class _Outputs(dpf.outputs.Outputs):

        # fmt: off
        _spec = OrderedDict([(0, OutputSpec(name='mesh_scoping', type_names=['scoping'], document=''))]) # noqa: E501
        # fmt: on

        def __init__(self, oper):
            self._mesh_scoping = None
            super().__init__(self._spec, oper)

        @property
        def mesh_scoping(self):
            return self._mesh_scoping

    def __init__(
        self,
        requested_location,
        named_selection_name,
        data_sources,
        int_inclusive=None,
        streams_container=None,
    ):
        if channel is None:
            channel = dpf.server._global_channel()

        self._channel = channel
        self._stub = self._connect()
        self._message = None
        self._description = None
        self.name = "scoping_provider_by_ns"

        self._Operator__send_init_request()

        self.inputs = self._Inputs(self)
        self.outputs = self._Outputs(self)

    @property
    def mesh_scoping(self):
        return self.outputs._mesh_scoping
